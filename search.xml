<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AspNetCore中的依赖注入框架</title>
    <url>/2020/07/10/AspNetCore%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<ul>
<li><p>在AspNetCore中会默认地配备一个依赖注入框架，该框架有下面两个组件包：</p>
<ol>
<li>Microsoft.Extensions.DependencyInjection.Abstractions</li>
<li>Microsoft.Extensions.DependencyInjection</li>
</ol>
<p>一个是抽象包，另一个是实现包</p>
</li>
<li><p>依赖注入框架有以下四个核心类型：</p>
<ol>
<li>IServiceCollection：负责服务的注册</li>
<li>ServiceDescriptor：每一个服务注册时的信息</li>
<li>IServiceProvider：注册时注入服务的容器，由ServiceCollection的Build方法构建出来</li>
<li>IServiceScope：表示一个容器的子容器的生命周期</li>
</ol>
</li>
<li><p>生命周期：ServiceLifetime</p>
<ol>
<li>单例：Singleton，指在整个跟容器的生命周期内，都是同一个实例，即作用域是全局的。</li>
<li>作用域：Scoped，指在Scope的生存周期内，也就是容器的生存周期内，或者子容器的生存周期内，若容器释放掉，实例也会被释放掉，即作用域是局部的。</li>
<li>瞬时：Transient，指每一次去从容器中获取对象时，都可以得到一个新的实例。</li>
</ol>
</li>
<li><p>注册服务的方式：</p>
<ol>
<li>花式注册</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">services.AddSingleton&lt;接口&gt;(实现接口的类);&#x2F;&#x2F;单例模式</span><br><span class="line">services.AddScoped&lt;接口&gt;(实现接口的类);&#x2F;&#x2F;作用域模式</span><br><span class="line">services.AddTransient&lt;接口&gt;(实现接口的类);&#x2F;&#x2F;瞬时模式</span><br><span class="line">services.AddSingleton&lt;接口，实现接口的类&gt;();&#x2F;&#x2F;单例模式</span><br><span class="line">services.AddScoped&lt;接口，实现接口的类&gt;();&#x2F;&#x2F;作用域模式</span><br><span class="line">services.AddTransient&lt;接口，实现接口的类&gt;();&#x2F;&#x2F;瞬时模式</span><br><span class="line">*&#x2F;</span><br><span class="line">services.AddSingleton&lt;IOrderService&gt;(new OrderService());</span><br><span class="line">services.AddSingleton&lt;IOrderService, OrderService&gt;();</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>使用工厂方式来注册</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line"> services.AddSingleton&lt;IOrderService&gt;(service &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var logger &#x3D; service.GetService&lt;ILogger&gt;();</span><br><span class="line">    return new OrderService();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>使用工厂方式来注册可以对实例来进行一系列的操作，比如用其他的组件来组装新的实例，即实现依赖了容器内另外一个实现</p>
<ol start="3">
<li>使用TryAdd方式来注册</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">TryAddxxx表示尝试注册，即若服务已经被注册了，这该语句不会被执行，否则被执行</span><br><span class="line">*&#x2F;</span><br><span class="line">services.TryAddSingleton&lt;IOrderService, OrderService&gt;();</span><br><span class="line">services.TryAddScoped&lt;IOrderService, OrderService&gt;();</span><br><span class="line">services.TryAddTransient&lt;IOrderService, OrderService&gt;();</span><br><span class="line">&#x2F;*</span><br><span class="line">TryAddEnumerable和上面的三种注册方法有一些区别，表示的是如果服务的实现类已经被注册了，则该方法不被执行，否则被执行，即可以用该方法注册同一个服务的不同实现类</span><br><span class="line">*&#x2F;</span><br><span class="line">services.TryAddEnumerable(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;());</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>使用Replace来替换服务,使用RemoveAll来移除服务</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">使用Replace来将IOrderService服务中的OrderService替换成OrderServiceEx</span><br><span class="line">使用RemoveAll来将所有的实现IOrderService的实现从容器中移除</span><br><span class="line">*&#x2F;</span><br><span class="line">services.AddSingleton&lt;IOrderService, OrderService&gt;();</span><br><span class="line">services.Replace(ServiceDescriptor.Singleton&lt;IOrderService, OrderServiceEx&gt;());</span><br><span class="line">services.RemoveAll&lt;IOrderService&gt;();</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>泛型模板的注册</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">services.AddSingleton(typeof(IGenericService&lt;&gt;), typeof(GenericService&lt;&gt;));</span><br><span class="line">&#x2F;&#x2F;使用时，可以在&lt;&gt;放容器中的组件，即IGenericService依赖了IOrderService</span><br><span class="line">IGenericService&lt;IOrderService&gt;</span><br></pre></td></tr></table></figure></div>



</li>
</ul>
<ul>
<li><p>获取服务实例的方法</p>
<ol>
<li>在构造函数中注入服务，一般用于服务适用于整个类</li>
<li>使用[FromService]特性注册服务，一般用于服务适用于类的某个方法或属性等</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>-AspNetCore</category>
      </categories>
      <tags>
        <tag>-C# -AspNetCore</tag>
      </tags>
  </entry>
  <entry>
    <title>AspNetCore——缓存</title>
    <url>/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>缓存是一种通过存储资源的备份，在请求时返回资源备份的技术。使用缓存能够减少服务器的压力和网络带宽，并减少客户端延迟。AspNetCore支持多种形式的缓存，Http的、内存的、分布式的，还提供了响应缓存中间件。</li>
</ul>
<h4 id="过期模型"><a href="#过期模型" class="headerlink" title="过期模型"></a>过期模型</h4><p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache1.PNG" alt="捕获1"></p>
<h4 id="验证模型"><a href="#验证模型" class="headerlink" title="验证模型"></a>验证模型</h4><p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache2.PNG" alt="捕获2"></p>
<h3 id="Http缓存"><a href="#Http缓存" class="headerlink" title="Http缓存"></a>Http缓存</h3><h4 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h4><ul>
<li>Http有三种缓存：<ol>
<li>客户端/浏览器缓存，存在于客户端，并且是私有的。</li>
<li>网关缓存，它是共享的缓存，位于服务器端，所有的客户端都会共享这个缓存，它的别名还有反向代理服务器缓存，HTTP加速器等。</li>
<li>代理缓存，位于网络上，是共享的，它既不位于客户端，也不位于服务器，类似于云存储或CDN。这种缓存经常被大型企业或ISP使用，用来服务大规模的用户。</li>
</ol>
</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache3.PNG" alt="捕3"></p>
<h4 id="缓存相关的消息头"><a href="#缓存相关的消息头" class="headerlink" title="缓存相关的消息头"></a>缓存相关的消息头</h4><ul>
<li><p>Http缓存的形式在Web应用程序的使用非常普遍，它主要是通过与缓存相关的消息头实现的，这些消息头指明了缓存行为（是否使用缓存、缓存的有效时间等），主要包括Cache-Control和Expires。</p>
</li>
<li><p>缓存相关的响应头的含义：</p>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache.PNG" alt="捕获"></p>
</li>
</ul>
<blockquote>
<p>HTTP1.1 200 OK<br>Cache-Control:public, max-age=60</p>
</blockquote>
<ul>
<li>Expires消息头也可以用来指定缓存的有效时间，但它的值是一个绝对时间</li>
</ul>
<h4 id="缓存是否有效"><a href="#缓存是否有效" class="headerlink" title="缓存是否有效"></a>缓存是否有效</h4><ul>
<li>上面则表示了该响应支持缓存，并且在任何地方都可以存储该响应，有效时间为60s；当缓存的响应失效后，此时当客户端再次使用资源时，就需要请求服务器，已验证缓存的响应是否有效（是否被改变）。如果有效，则服务器返回304Not Modified状态码，响应中也不会包含任何响应体；如果失效，服务器则返回200OK状态码以及最新资源。</li>
</ul>
<h4 id="如何验证缓存是否有效"><a href="#如何验证缓存是否有效" class="headerlink" title="如何验证缓存是否有效"></a>如何验证缓存是否有效</h4><ul>
<li>验证缓存资源的方式有两种，一种是Last-Modified，另一种是ETag<ol>
<li>Last-Modified的值是资源最后更新的时间，在验证时，需要在请求消息中添加If-Modified-Since消息头，这个值是客户端最近一次收到该资源响应中Last-Modified的值，服务器就可以拿If-Modified-Since的值跟资源最后的更新时间进行比较，如果相同则缓存有效，不同则缓存无效。</li>
<li>ETag可以看作是由服务器为当前资源生成的唯一标识，当客户端在请求验证时需要在消息头中添加If-None-Match，它的值为该资源最近异常从服务器中获得的ETag值。当服务器中资源发生改变时，它的ETag值会更改，所以服务器可以用它来识别缓存的响应是否和资源的最新状态一致。</li>
</ol>
</li>
<li>建议使用ETag，因为Last-Modified是以秒为单位来进行验证的，有可能在一秒内对api进行了多次修改请求，Last-Modified的验证就会失效了。</li>
</ul>
<blockquote>
<p>服务器<br>HTTP1.1 200OK<br>Cache-Control:public, max-age=60<br>ETag: “ead145f”<br>客户端<br>GET /api/authors<br>If-None-Match: “ead145f”<br>服务器<br>HTTP1.1 304 NotModified<br>Cache-Control:public, max-age=60<br>ETag: “ead145f”</p>
</blockquote>
<ul>
<li>注意，只有请求方法为GET或HEAD，并且服务器返回200时的响应才支持缓存。</li>
</ul>
<h3 id="让WebApi支持Http缓存"><a href="#让WebApi支持Http缓存" class="headerlink" title="让WebApi支持Http缓存"></a>让WebApi支持Http缓存</h3><ul>
<li>在AspNetCore中实现Http缓存需要提供两样东西：<ol>
<li>表明资源的缓存信息，即响应的消息头，它由<code>ResponseCache</code>特性来支持，它只设置了响应消息头项的信息，并没有缓存任何的数据。</li>
<li>缓存的存储器，它可以由response cache中间件来支持，也可以使用其他的存储器，比如redis等等。</li>
</ol>
</li>
<li>在想要被缓存的Action上添加<code>ResponseCache</code>特性</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 添加响应缓存，有效期为60秒，响应缓存有三种类型：</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Any：对应Cache-Control的值为public，表示响应可以被任何对象缓存</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Client：对应Cache-Control的值为private，表示响应只能为单个用户缓存，不能作为共享缓存</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> None：对应Cache-Control的值为no-cache，表示必须到服务器验证才能使用缓存</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 默认是public</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="parameters"&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"&#123;authorId&#125;"</span>, Name = nameof(GetAuthorAsync))</span>]</span><br><span class="line">[<span class="meta">ResponseCache(Duration = 60, Location = ResponseCacheLocation.Client)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;AuthorDto&gt;&gt; GetAuthorAsync(Guid authorId)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> author = <span class="keyword">await</span> _repositoryWrapper.Author.GetByIdAsync(authorId);</span><br><span class="line">    <span class="keyword">if</span> (author==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NotFound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> authorDto = _mapper.Map&lt;AuthorDto&gt;(author);</span><br><span class="line">    <span class="keyword">return</span> Ok(authorDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在Startup.cs添加缓存的中间件，在ConfigureServices方法添加以下代码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">services.AddResponseCaching();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在Configure方法添加以下代码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要在UseRouting之前</span></span><br><span class="line">app.UseResponseCaching();</span><br></pre></td></tr></table></figure></div>

<h3 id="添加缓存的Profile（属性的模板）"><a href="#添加缓存的Profile（属性的模板）" class="headerlink" title="添加缓存的Profile（属性的模板）"></a>添加缓存的Profile（属性的模板）</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">services.AddControllers(config =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                config.ReturnHttpNotAcceptable = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//添加缓存的设置模板</span></span><br><span class="line">                config.CacheProfiles.Add(<span class="string">"120sCacheProfile"</span>, <span class="keyword">new</span> CacheProfile</span><br><span class="line">                &#123;</span><br><span class="line">                    Duration = <span class="number">120</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在AuthorController添加全局的Profile，除了上面GetAuthorAsync方法外，其他方法的缓存有效期就都是120s</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Route(<span class="meta-string">"api/authors"</span>)</span>]</span><br><span class="line">[<span class="meta">ApiController</span>]</span><br><span class="line">[<span class="meta">ResponseCache(CacheProfileName = <span class="meta-string">"120sCacheProfile"</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorController</span>:<span class="title">ControllerBase</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="缓存请求响应的Cache-Control的指令"><a href="#缓存请求响应的Cache-Control的指令" class="headerlink" title="缓存请求响应的Cache-Control的指令"></a>缓存请求响应的Cache-Control的指令</h3><ul>
<li>请求</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache6.PNG" alt="捕获6"></p>
<ul>
<li>响应</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache5.PNG" alt="捕获5"></p>
<h3 id="让WebApi支持ETag"><a href="#让WebApi支持ETag" class="headerlink" title="让WebApi支持ETag"></a>让WebApi支持ETag</h3><ul>
<li>一般WebApi不会只对过期模型进行配置，还会对验证模型进行配置，验证模型分为强验证器（ETag）和弱验证器（Last-Modified）；实现ETag需要添加一个依赖<code>Marvin.Cache.Headers</code>。</li>
<li>在Startup.cs添加全局的过期模型和验证模型的配置：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">services.AddHttpCacheHeaders();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在Configure方法中添加<code>app.UseHttpCacheHeaders();</code>。</li>
<li>使用Postman进行请求后，可以看到Header如下：HttpCacheHeaders帮我们自动加上了强验证器和弱验证器。</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache7.PNG" alt="捕获7"></p>
<h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><ul>
<li>可以在AddHttpCacheHeaders方法参数中对过期模型和验证模型进行配置</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加过期模型和验证模型的配置</span></span><br><span class="line"><span class="comment">//在这里的配置是全局的配置</span></span><br><span class="line">services.AddHttpCacheHeaders(expires =&gt;</span><br><span class="line">                             &#123;</span><br><span class="line">                                 expires.CacheLocation = CacheLocation.Private;</span><br><span class="line">                                 expires.MaxAge = <span class="number">60</span>;</span><br><span class="line">                             &#125;, validation =&gt;</span><br><span class="line">                             &#123;</span><br><span class="line">                                 validation.MustRevalidate = <span class="literal">true</span>;</span><br><span class="line">                             &#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>请求结果是这样的，由于缓存的类型为private，Api并不会帮我们保存缓存，所以就没有Age这个项。</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache8.PNG" alt="捕获8"></p>
<ul>
<li>Vary项的含义是：当请求的Accept的媒体类型和缓存中的数据类型不一致的时候，响应并不会从缓存返回，而会去请求Api的数据。</li>
</ul>
<h4 id="在Action或Controller级别上的配置"><a href="#在Action或Controller级别上的配置" class="headerlink" title="在Action或Controller级别上的配置"></a>在Action或Controller级别上的配置</h4><ul>
<li>在GetAuthorsAsync这个Action上添加配置</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HttpGet(Name = nameof(GetAuthorsAsync))</span>]</span><br><span class="line"><span class="comment">//过期模型配置</span></span><br><span class="line">[<span class="meta">HttpCacheExpiration(CacheLocation = CacheLocation.Private, MaxAge = 120)</span>]</span><br><span class="line"><span class="comment">//验证模型配置</span></span><br><span class="line">[<span class="meta">HttpCacheValidation(MustRevalidate = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;ActionResult&lt;IEnumerable&lt;AuthorDto&gt;&gt;&gt; GetAuthorsAsync</span><br><span class="line">    ([FromQuery] AuthorResourceParameters parameters)&#123;...&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Controller级别的类似，这里就不写了。</li>
</ul>
<h3 id="测试ETag（验证器）"><a href="#测试ETag（验证器）" class="headerlink" title="测试ETag（验证器）"></a>测试ETag（验证器）</h3><ul>
<li>先请求一次，然后可以在响应头中获取到ETag，然后在请求头中添加If-None-Match，值为ETag的值，请求。返回结果可以看到304状态码，没有响应体，同时带回最新的ETag。</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache9.PNG" alt="捕获10"></p>
<ul>
<li>然后我们进行一次Put请求，修改资源成功</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache11.PNG" alt="捕获11"></p>
<ul>
<li>再用第一次的Get请求加If-None-Match项请求相同的数据，返回了200OK，并且返回了最新的ETag。</li>
</ul>
<p><img src="/2020/10/24/AspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98/.%5CAspNetCore%E2%80%94%E2%80%94%E7%BC%93%E5%AD%98%5Ccache12.PNG" alt="捕获12"></p>
<hr>
<p>学习资源：<a href>B站杨旭</a></p>
]]></content>
      <categories>
        <category>-AspNetCore</category>
      </categories>
      <tags>
        <tag>-AspNetCore -C#</tag>
      </tags>
  </entry>
  <entry>
    <title>AspNetCore的Program类</title>
    <url>/2020/07/10/AspNetCore%E7%9A%84Program%E7%B1%BB/</url>
    <content><![CDATA[<ul>
<li>IHostBuilder中的相关配置方法</li>
</ul>
<ol>
<li>ConfigureWebHostDefaults：该方法注册了应用程序必要的几个组件，比如配置的组件、容器的组件等。</li>
<li>ConfigureHostConfiguration：该方法配置了应用程序启动时需要的配置，比如端口和url</li>
<li>ConfigureAppConfiguration：该方法可以让我们来嵌入我们自己的配置文件，供应用程序读取</li>
<li>ConfigureServices：该方法是用来往容器里注入我们应用需要的组件</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">执行的顺序是：</span><br><span class="line">ConfigureWebHostDefaults</span><br><span class="line">ConfigureHostConfiguration</span><br><span class="line">ConfigureAppConfiguration</span><br><span class="line">Startup.ConfigureServices</span><br><span class="line">ConfigureServices</span><br><span class="line">Startup.Configure</span><br><span class="line">*&#x2F;</span><br><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureAppConfiguration(builder &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureAppConfiguration&quot;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureServices(service &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureServices&quot;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureHostConfiguration(builder &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureHostConfiguration&quot;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureWebHostDefaults&quot;);</span><br><span class="line">                    webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过CreateHostBuilder(args).Build().Run()，就可以在IHostBuilder配置完后运行整个项目</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">执行的顺序是：</span><br><span class="line">ConfigureWebHostDefaults</span><br><span class="line">ConfigureHostConfiguration</span><br><span class="line">ConfigureAppConfiguration</span><br><span class="line">webBuilder.ConfigureServices</span><br><span class="line">ConfigureServices</span><br><span class="line">webBuilder.Configure</span><br><span class="line">*&#x2F;</span><br><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">            Host.CreateDefaultBuilder(args)</span><br><span class="line">                .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureWebHostDefaults&quot;);</span><br><span class="line">                    &#x2F;&#x2F;webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                    webBuilder.ConfigureServices(services &#x3D;&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(&quot;webBuilder.ConfigureServices&quot;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                    webBuilder.Configure(app &#x3D;&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(&quot;webBuilder.Configure&quot;);</span><br><span class="line"></span><br><span class="line">                        app.UseRouting();</span><br><span class="line"></span><br><span class="line">                        app.UseEndpoints(endpoints &#x3D;&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            endpoints.MapGet(&quot;&#x2F;&quot;, async context &#x3D;&gt;</span><br><span class="line">                            &#123;</span><br><span class="line">                                await context.Response.WriteAsync(&quot;Hello World!&quot;);</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureServices(service &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureServices&quot;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .ConfigureHostConfiguration(builder &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureHostConfiguration&quot;);</span><br><span class="line">                &#125;).ConfigureAppConfiguration(builder &#x3D;&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;ConfigureAppConfiguration&quot;);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从这段代码不难看出，Startup类并不是必需的，它可以直接写在webBuilder下，但通常使用Startup类可以使我们的代码更有结构。</li>
</ul>
]]></content>
      <categories>
        <category>-AspNetCore</category>
      </categories>
      <tags>
        <tag>-C# -AspNetCore</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2020/09/16/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>1 <strong>docker images</strong> 查看镜像信息列表 镜像是静态的</p>
<p>2 <strong>docker ps -a</strong> 查看运行中的所有容器</p>
<p>3 <strong>docker pull [images]:[version]</strong>从dockerhub拉取指定镜像</p>
<p>4 <strong>docker run -p 8000:80 -tdi –privileged [imageID] [command]</strong> 后台启动docker,并指定宿主机端口和docker映射端口。</p>
<p> <strong>-i:</strong>以交互模式运行容器，通常与 -t 同时使用；</p>
<p> <strong>-d:</strong>后台运行容器，并返回容器ID；</p>
<p><strong>-t:</strong>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p>
<p><strong>–privileged</strong> 容器将拥有访问主机所有设备的权限</p>
<p>通常情况下 [command] 填下 <strong>/bin/bash</strong> 即可。</p>
<p>特殊情况下，如需要在centos镜像中使用<strong>systemctl</strong> . 则应添加<strong>–privileged</strong> 并设置[command ]为 <strong>init</strong>。</p>
<p>5 当镜像通过run 启动后，便会载入到一个动态的container(容器)中运行，此时若需要进入终端交互模式：</p>
<p><strong>sudo docker exec -it [containerID] /bin/bash</strong></p>
<p>交互模式中，使用 ctrl+p+q退出交互 保持运行,使用 exit命令退出并停止容器。</p>
<p>6 在容器非交互模式下，通过docker start/stop 命令来启动/停止已部署的容器服务。</p>
<p>7 <strong>docker rm [containerID]</strong> 删除容器</p>
<p>8 <strong>docker rmi [imageID]</strong> 删除镜像</p>
<p>9 <strong>docker cp [YourHostFilePath] [containerID]:[DockerPath]</strong> 将宿主机内的指定文件传输至容器内部的指定地址。</p>
<p><strong>镜像制作：</strong></p>
<p>1 <strong>docker commit [containerID] [ImageName]:[Version]</strong> 将修改后的容器重新打包成镜像</p>
<p>2 <strong>docker commit -a “runoob.com” -m “my apache” a404c6c174a2 mymysql:v1</strong> 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p>
<p><strong>-a</strong> :提交的镜像作者；</p>
<p> <strong>-c</strong> :使用Dockerfile指令来创建镜像；</p>
<p> <strong>-m</strong> :提交时的说明文字；</p>
<p> <strong>-p</strong> :在commit时，将容器暂停。</p>
<p>3 <strong>docker push [ImageID] [repertory_address]</strong>提交镜像到云仓库</p>
<hr>
<h3 id="与镜像相关"><a href="#与镜像相关" class="headerlink" title="与镜像相关"></a>与镜像相关</h3><ul>
<li>docker pull <image></image></li>
<li>docker search <image></image></li>
</ul>
<h3 id="与容器相关"><a href="#与容器相关" class="headerlink" title="与容器相关"></a>与容器相关</h3><ul>
<li>docker run</li>
<li>docker start/stop <container></container></li>
<li>docker ps <container></container></li>
<li>docker logs <container></container></li>
</ul>
<h3 id="docker-run-的常用选项"><a href="#docker-run-的常用选项" class="headerlink" title="docker run 的常用选项"></a>docker run 的常用选项</h3><ul>
<li><p>docker run [options] image [command] [args…]</p>
</li>
<li><p>选项说明：</p>
<ul>
<li>-d，后台运行容器</li>
<li>-e，设置环境变量</li>
<li>-expose / -p，宿主端口：容器端口</li>
<li>–name，指定容器名称</li>
<li>–link，链接不同容器</li>
<li>-v，宿主目录:容器目录，挂载磁盘卷</li>
</ul>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="STAN"><figure class="iseeu highlight /stan"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如，创建一个mongoDB容器</span></span><br><span class="line">docker run --name mongo -p <span class="number">27017</span>:<span class="number">27017</span> -v ~/docker-<span class="title">data</span>/mongo:/<span class="title">data</span>/db -<span class="built_in">e</span> MONGO_INITDB_ROOT_USERNAME=admin -<span class="built_in">e</span> MONGO_INITDB_ROOT_PASSWORD=admin -d mongo</span><br></pre></td></tr></table></figure></div>

<h3 id="通过docker启动mongodb"><a href="#通过docker启动mongodb" class="headerlink" title="通过docker启动mongodb"></a>通过docker启动mongodb</h3><ul>
<li>登录到MongoDB容器中，<code>docker exec -it mongo bash</code></li>
<li>通过Shell连接MongoDB，<code>mongo -u admin -p admin</code></li>
</ul>
]]></content>
      <categories>
        <category>-docker</category>
      </categories>
      <tags>
        <tag>-docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM——类加载器子系统</title>
    <url>/2020/11/22/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="/2020/11/22/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F/D:%5CMy_blog%5Csource_posts%5CJVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F%5CSnipaste_2020-11-06_23-02-22.png" alt="Snipaste_2020-11-06_23-02-22"></p>
<ul>
<li>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</li>
<li>ClassLoader只负责class文件的加载，至于它是否可以运行，则由执行引擎决定。</li>
<li>加载的类信息存放于一块称为方法去的内存空间，除了类的信息外，方法区中还会存放运行时常量池的信息、字符串字面量和数字常量。</li>
<li>sun.misc.Launcher是一个Java虚拟机的应用入口</li>
</ul>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><ul>
<li>加载阶段分为3部分：<ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问入口。</li>
</ol>
</li>
</ul>
<h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul>
<li>链接阶段分为3部分：<ol>
<li>验证：在于确保Class文件的字节流中包含信息符合当前虚拟机的要求，保证被加载类的正确性，不会危害到虚拟机。主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。</li>
<li>准备：为变量分配内存并且设置该类变量的默认初始值，即0。这里的初始化不包含final修饰的static，因为final在编译的时候就已经分配了。不会为实例变量分配初始化。</li>
<li>解析：将常量池中的符号引用转换为直接引用的过程</li>
</ol>
</li>
</ul>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul>
<li>初始化阶段就是执行类构造方法<code>&lt;clinit&gt;()</code>的过程，此方法不需要定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>JVM会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</li>
<li>JVM必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁。</li>
</ul>
<h3 id="加载器的类型"><a href="#加载器的类型" class="headerlink" title="加载器的类型"></a>加载器的类型</h3><ul>
<li>JVM支持两种类型的类加载器，分别是引导类加载器（BootstrapClassLoader）和自定义加载器</li>
<li>从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义加载器。所以ExtensionClassLoader和SystemClassLoader也是自定义加载器，</li>
<li>而最常见的类加载器就只有三个：BootstrapClassLoader（引导加载器）、ExtensionClassLoader（扩展加载器）、SystemClassLoader（系统加载器）</li>
<li>加载器的继承关系如下：其中引导类加载器采用C++语言编写，其他用的是Java</li>
</ul>
<p><img src="/2020/11/22/JVM%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F/Snipaste_2020-11-07_20-50-56.png" alt="Snipaste_2020-11-07_20-50-56"></p>
<ul>
<li>对于用户自定义类来说，默认使用系统类加载器进行加载；对于Java的核心类库，都是使用引导类来加载的。</li>
</ul>
<h4 id="引导类加载器（BootstrapClassLoader）"><a href="#引导类加载器（BootstrapClassLoader）" class="headerlink" title="引导类加载器（BootstrapClassLoader）"></a>引导类加载器（BootstrapClassLoader）</h4><ul>
<li>引导类加载器使用C/C++语言实现的，嵌套在JVM内部</li>
<li>它用来加载Java的核心库（rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。</li>
<li>并不继承自java.lang.ClassLoader，没有父类加载器，用于加载扩展类和系统类加载器，并指定为它们的父类加载器</li>
<li>出于安全考虑，引导类加载器只加载包名为java、javax、sun等开头的类。执行<code>getURLs()</code>就可以获取类加载器加载的类库路径。</li>
</ul>
<h4 id="扩展类加载器（ExtClassLoader）"><a href="#扩展类加载器（ExtClassLoader）" class="headerlink" title="扩展类加载器（ExtClassLoader）"></a>扩展类加载器（ExtClassLoader）</h4><ul>
<li>派生于ClassLoader类，父类为引导类加载器，从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre.lib/ext子目录下加载类库。</li>
<li>通过<code>System.getProperty(&quot;java.ext.dirs&quot;);</code>可以获取扩展类加载器加载的类库路径</li>
</ul>
<h4 id="系统类加载器（AppClassLoader）"><a href="#系统类加载器（AppClassLoader）" class="headerlink" title="系统类加载器（AppClassLoader）"></a>系统类加载器（AppClassLoader）</h4><ul>
<li>派生于ClassLoader类，父类为扩展类加载器，它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库，一般来说，Java应用的类都是由它来完成加载。</li>
<li>可以通过个<code>getSystemClassLoader()</code>来获取该加载器</li>
</ul>
<h4 id="用户自定义加载器"><a href="#用户自定义加载器" class="headerlink" title="用户自定义加载器"></a>用户自定义加载器</h4><ul>
<li>在平时项目开发中，类的加载几乎是由上述3中类加载器相互配合执行的，那什么时候需要使用自定义类加载类：<ol>
<li>隔离加载器，当需要多个jar一起整合时，类路径和类名一样，发生冲突的时候就需要隔离</li>
<li>修改类加载的方式，除了引导类加载器是必须的外，其他都可以自定义</li>
<li>扩展加载源</li>
<li>防止源码泄露，自定义加密解密</li>
</ol>
</li>
<li>用户自定义类加载器实现步骤：<ol>
<li>继承ClassLoader类</li>
<li>把自定义类加载逻辑写在findClass()方法中</li>
<li>也可以继承URLClassLoader类，这样可以避免自己编写findClass()方法以及获取字节码流。</li>
</ol>
</li>
</ul>
<h3 id="类加载器中的方法"><a href="#类加载器中的方法" class="headerlink" title="类加载器中的方法"></a>类加载器中的方法</h3><table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>getParent()</td>
<td>返回该类加载器的父类加载器</td>
</tr>
<tr>
<td>loadClass(String name)</td>
<td>加载名称为name的类，返回该类的Class对象</td>
</tr>
<tr>
<td>findClass(String name)</td>
<td>查找名称为name的类，返回该类的Class对象</td>
</tr>
<tr>
<td>findLoadedClass(String name)</td>
<td>查找名称为name的已经被加载过的类，返回该类的Class对象</td>
</tr>
<tr>
<td>defineClass(String name, byte[] b, int off, int len)</td>
<td>把字节数组b中的内容转换称一个Java类，返回该类的Class对象</td>
</tr>
<tr>
<td>resolveClass(Class&lt;?&gt; c)</td>
<td>连接指定的一个Java类</td>
</tr>
</tbody></table>
<h3 id="获取加载器的方法"><a href="#获取加载器的方法" class="headerlink" title="获取加载器的方法"></a>获取加载器的方法</h3><ol>
<li>clazz.getClassLoader()</li>
<li>Thread.currentThread()/getContextClassLoader()</li>
<li>ClassLoader.getSystemClassLoader()</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><ol>
<li>如果一个类加载器收到了一个加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行。</li>
<li>如果父类加载器还存在其父类加载器，则进一步向上委托，直至到达顶层的启动类加载器。</li>
<li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，就会返回该子类加载器加载，判断是否能加载就是看该类的路径是否可以被加载器识别。</li>
</ol>
<ul>
<li>双亲委派机制的优点：<ol>
<li>避免类的重复加载</li>
<li>保护程序的安全，防止核心API被随意篡改</li>
</ol>
</li>
</ul>
<h3 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h3><ul>
<li>在JVM中表示两个class对象是否为同一个类存在两个必要条件：<ol>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的ClassLoader必须相同。</li>
</ol>
</li>
<li>如果一个类是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中；当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的。</li>
</ul>
<h3 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h3><ul>
<li>主动使用：<ol>
<li>创建类的实例（new）</li>
<li>访问某个类或接口的静态变量，或者堆该静态变量进行赋值</li>
<li>调用类的静态方法</li>
<li>反射</li>
<li>初始化一个类的子类</li>
<li>Java虚拟机启动时被标明为启动类的类</li>
<li>动态语言支持</li>
</ol>
</li>
<li>被动使用：除了上面七种情况，其他的都是被动使用。</li>
</ul>
]]></content>
      <categories>
        <category>-JVM——类加载器子系统</category>
      </categories>
      <tags>
        <tag>-JVM——类加载器子系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Entity Framework Core1——基础使用</title>
    <url>/2020/10/06/Entity-Framework-Core1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="EntityFrameworkCore"><a href="#EntityFrameworkCore" class="headerlink" title="EntityFrameworkCore"></a>EntityFrameworkCore</h3><ul>
<li><p>Entity Framework (EF) Core 是轻量化、可扩展、<a href="https://github.com/aspnet/EntityFrameworkCore" target="_blank" rel="noopener">开源</a>和跨平台版的常用 Entity Framework 数据访问技术。</p>
</li>
<li><p>EF Core 可用作对象关系映射程序 (O/RM)，这可以实现以下两点：</p>
</li>
</ul>
<ul>
<li>使 .NET 开发人员能够使用 .NET 对象处理数据库。</li>
<li>无需再像通常那样编写大部分数据访问代码。</li>
</ul>
<ul>
<li>EF Core 支持多个数据库引擎，请参阅<a href="https://docs.microsoft.com/zh-cn/ef/core/providers/" target="_blank" rel="noopener">数据库提供程序</a>了解详细信息。</li>
</ul>
<h3 id="使用EFCore的准备工作"><a href="#使用EFCore的准备工作" class="headerlink" title="使用EFCore的准备工作"></a>使用EFCore的准备工作</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ul>
<li>创建两个类库Linq.Domain、Linq.Data和一个控制台项目Linq.App</li>
</ul>
<h4 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h4><ul>
<li>然后再Linq.Domain中添加Entity实体，在这里我们创建Club、League和Player，分别是俱乐部、联队和足球运动员，其中联赛和俱乐部是一对多关系，俱乐部和运动员是一对多关系、</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Club</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Club</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Club</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Players = <span class="keyword">new</span> List&lt;Player&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateOfEstablishment &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> History &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> League League &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Player&gt; Players &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//League</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">League</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Country &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Player</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateOfBirth &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><ul>
<li>在Linq.Data的nuget中添加EFCore对SqlServer的支持和添加Linq.Domain的引用</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.SqlServer"</span> <span class="attr">Version</span>=<span class="string">"3.1.8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProjectReference</span> <span class="attr">Include</span>=<span class="string">"..\Linq.Domain\Linq.Domain.csproj"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在Linq.App中添加Linq.Data的引用</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProjectReference</span> <span class="attr">Include</span>=<span class="string">"..\Linq.Data\Linq.Data.csproj"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProjectReference</span> <span class="attr">Include</span>=<span class="string">"..\Linq.Domain\Linq.Domain.csproj"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="DbContext"><a href="#DbContext" class="headerlink" title="DbContext"></a>DbContext</h4><ul>
<li>DbContext是EFCore操作数据库的上下文类，使用它可以对数据库的连接进行一些配置、或对表中属性添加约束、或添加种子数据等等。</li>
<li>DbContext中对Context进行配置的方法是OnConfiguring该方法定义在DbContext这个类中</li>
<li>现在，创建一个LinqContext类：这个类必须继承于DbContext，且要将创建的数据库表以DbSet类型定义在Context中，后面可以使用这些DbSet对数据库进行访问。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LinqDbContext</span>: <span class="title">DbContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该方法可以对DbContext进行一些配置，在这里使用了本地的SqlServer，并指定了连接字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        optionsBuilder.UseSqlServer(</span><br><span class="line">            <span class="string">"Data Source=(localdb)\\MSSQLLocalDB; Initial Catalog=LinqDb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;League&gt; Leagues &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Club&gt; Clubs &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DbSet&lt;Player&gt; Players &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul>
<li><p>做好准备工作后，创建数据库只需要以下三步</p>
<ol>
<li>定义Model，这些Model在准备工作已经定义好了，他们就是对应于数据库中的数据库表。</li>
<li>创建迁移文件（Migration）。</li>
<li>使用迁移文件生成脚本或将其应用到数据库。</li>
</ol>
<p><img src="/2020/10/06/Entity-Framework-Core1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Snipaste_2020-10-06_17-17-29.png" alt="Snipaste_2020-10-06_17-17-29"></p>
</li>
</ul>
<h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><ul>
<li>迁移需要用到Migration命令，Migration命令需要用到两个库（如果使用vscode，只需要安装Design库，vs的话只需要安装Tools库，因为Tools库已经依赖了Design库）：</li>
</ul>
<blockquote>
<p>Microsoft.EntityFrameworkCore.Tools：该库添加了对包管理控制台的迁移命令的支持</p>
<p>Microsoft.EntityFrameworkCore.Design：该库添加了对迁移操作的核心支持</p>
</blockquote>
<ul>
<li><p>要想生成DbContext对应的迁移文件，必须要有一个可执行的文件，所以你可以使用控制台项目或者Web项目等可执行的项目来生成迁移文件，这里使用的是控制台（Linq.App）。</p>
</li>
<li><p>安装完Tools库后就可以在程序包管理器控制台上输入EntityFrameworkCore的命令，在这里输入<code>get-help entityframework</code>就可以查看有哪些命令</p>
<p><img src="/2020/10/06/Entity-Framework-Core1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Snipaste_2020-10-06_19-29-44.png" alt="Snipaste_2020-10-06_19-29-44"></p>
</li>
<li><p>在这里需要注意的是，在输入命令之前需要把默认项目改成安装了Tools库的项目，而且要在执行项目中安装Design库才能迁移成功。</p>
</li>
</ul>
<h4 id="添加迁移"><a href="#添加迁移" class="headerlink" title="添加迁移"></a>添加迁移</h4><ul>
<li><p>执行<code>Add-Migration [迁移名称]</code>就可以进行迁移</p>
<p><img src="/2020/10/06/Entity-Framework-Core1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Snipaste_2020-10-06_19-37-03.png" alt="Snipaste_2020-10-06_19-37-03"></p>
</li>
<li><p>执行完命令后就会自动生成两个文件：一个是迁移文件，另一个是快照文件</p>
<p><img src="/2020/10/06/Entity-Framework-Core1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Snipaste_2020-10-06_19-40-05.png" alt="Snipaste_2020-10-06_19-40-05"></p>
</li>
<li><p>迁移文件：每次迁移都会生成一个迁移文件，它会记录每一次迁移的所有改动。它的名字就是时间戳+迁移名称。</p>
</li>
<li><p>迁移类：迁移类会继承于<code>Migration</code>这个基类，它里面有两个方法：</p>
<ol>
<li>Up：该方法定义了本次迁移对数据库的修改</li>
<li>Down：该方法定义了当修改有一些问题时进行的回滚。</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Initial</span> : <span class="title">Migration</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Up</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span>&#123;...&#125;</span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Down</span>(<span class="params">MigrationBuilder migrationBuilder</span>)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>快照文件：EFCore会使用这个文件来追踪当前所有Model的状态，比如我们修改了一个Model，EFCore就会在添加迁移时根据当前Model的状态和快照中Model的状态进行对比，就可以知道下一步该如何操作。该文件不应该去修改它。</li>
</ul>
<h4 id="生成脚本"><a href="#生成脚本" class="headerlink" title="生成脚本"></a>生成脚本</h4><ul>
<li>执行<code>script-migration</code>可以生成本次迁移的Sql脚本。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">IF OBJECT_ID(N'[__EFMigrationsHistory]') IS NULL</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [__EFMigrationsHistory] (</span><br><span class="line">        [MigrationId] <span class="keyword">nvarchar</span>(<span class="number">150</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">        [ProductVersion] <span class="keyword">nvarchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">        <span class="keyword">CONSTRAINT</span> [PK___EFMigrationsHistory] PRIMARY <span class="keyword">KEY</span> ([MigrationId])</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Leagues] (</span><br><span class="line">    [<span class="keyword">Id</span>] <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [<span class="keyword">Name</span>] <span class="keyword">nvarchar</span>(<span class="keyword">max</span>) <span class="literal">NULL</span>,</span><br><span class="line">    [Country] <span class="keyword">nvarchar</span>(<span class="keyword">max</span>) <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Leagues] PRIMARY <span class="keyword">KEY</span> ([<span class="keyword">Id</span>])</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Clubs] (</span><br><span class="line">    [<span class="keyword">Id</span>] <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [<span class="keyword">Name</span>] <span class="keyword">nvarchar</span>(<span class="keyword">max</span>) <span class="literal">NULL</span>,</span><br><span class="line">    [City] <span class="keyword">nvarchar</span>(<span class="keyword">max</span>) <span class="literal">NULL</span>,</span><br><span class="line">    [DateOfEstablishment] datetime2 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    [History] <span class="keyword">nvarchar</span>(<span class="keyword">max</span>) <span class="literal">NULL</span>,</span><br><span class="line">    [LeagueId] <span class="built_in">int</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Clubs] PRIMARY <span class="keyword">KEY</span> ([<span class="keyword">Id</span>]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Clubs_Leagues_LeagueId] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> ([LeagueId]) <span class="keyword">REFERENCES</span> [Leagues] ([<span class="keyword">Id</span>]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [Players] (</span><br><span class="line">    [<span class="keyword">Id</span>] <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">IDENTITY</span>,</span><br><span class="line">    [<span class="keyword">Name</span>] <span class="keyword">nvarchar</span>(<span class="keyword">max</span>) <span class="literal">NULL</span>,</span><br><span class="line">    [DateOfBirth] datetime2 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    [ClubId] <span class="built_in">int</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [PK_Players] PRIMARY <span class="keyword">KEY</span> ([<span class="keyword">Id</span>]),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> [FK_Players_Clubs_ClubId] <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> ([ClubId]) <span class="keyword">REFERENCES</span> [Clubs] ([<span class="keyword">Id</span>]) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> [IX_Clubs_LeagueId] <span class="keyword">ON</span> [Clubs] ([LeagueId]);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> [IX_Players_ClubId] <span class="keyword">ON</span> [Players] ([ClubId]);</span><br><span class="line"></span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [__EFMigrationsHistory] ([MigrationId], [ProductVersion])</span><br><span class="line"><span class="keyword">VALUES</span> (N<span class="string">'20201006113413_Initial'</span>, N<span class="string">'3.1.8'</span>);</span><br><span class="line"></span><br><span class="line">GO</span><br></pre></td></tr></table></figure></div>

<h4 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h4><ul>
<li><p>生成脚本一般是在生产环境中使用的，而在开发环境中可以执行<code>update-database -verbose</code>来将迁移应用到数据库，这将会生成如下数据库</p>
<p><img src="/2020/10/06/Entity-Framework-Core1%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/Snipaste_2020-10-06_20-08-11.png" alt="Snipaste_2020-10-06_20-08-11"></p>
</li>
<li><p>其中的History是迁移记录表</p>
</li>
</ul>
<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV1xa4y1v7rR?p=3" target="_blank" rel="noopener">B站杨旭</a></p>
]]></content>
      <categories>
        <category>-EFCore</category>
      </categories>
      <tags>
        <tag>-EFCore -C#</tag>
      </tags>
  </entry>
  <entry>
    <title>AspNetCore作用域和对象释放</title>
    <url>/2020/07/10/AspNetCore%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AF%B9%E8%B1%A1%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<ul>
<li><p>实现IDisposable接口类型的释放</p>
<ol>
<li><p>DI只负责释放由其创建的对象实例</p>
</li>
<li><p>DI在容器或子容器释放时，会释放由其创建的对象实例</p>
</li>
<li><p>避免在根容器创建实现了IDisposable的瞬时服务（即GetService），因为这样做会在根容器中积累瞬时服务的实例，只有等根容器释放时这些实例才会被释放，这样会占用很多的应用资源。</p>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*如果IOrderService是实现了IDisposable接口，通过根容器获取该服务时，该服务的实例会一直存在，直到根容器释放为止*&#x2F;</span><br><span class="line">app.ApplicationServices.GetService&lt;IOrderService&gt;();</span><br></pre></td></tr></table></figure></div>



</li>
</ul>
<ol start="3">
<li>避免手动创建实现了IDisposable的对象，然后放到容器中，因为这样做容器就不会管理我们创建对象的生命周期。</li>
</ol>
]]></content>
      <categories>
        <category>-AspNetCore</category>
      </categories>
      <tags>
        <tag>-C# -AspNetCore</tag>
      </tags>
  </entry>
  <entry>
    <title>EntityFramework Core2——Model属性设置、Model的关系设置、日志、增删改查</title>
    <url>/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="设定属性的约束"><a href="#设定属性的约束" class="headerlink" title="设定属性的约束"></a>设定属性的约束</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"System.ComponentModel.Annotations"</span> <span class="attr">Version</span>=<span class="string">"4.7.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="在Model中添加约束"><a href="#在Model中添加约束" class="headerlink" title="在Model中添加约束"></a>在Model中添加约束</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">League</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required</span>]<span class="comment">//必添的属性</span></span><br><span class="line">    [<span class="meta">MaxLength(100)</span>]<span class="comment">//最大长度为100</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">Required, MaxLength(50)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Country &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后跟上一讲一样添加迁移，再应用到数据库中，这样就会将对Model的约束应用到数据库中</li>
</ul>
<h3 id="一对一、一对多、多对多"><a href="#一对一、一对多、多对多" class="headerlink" title="一对一、一对多、多对多"></a>一对一、一对多、多对多</h3><ul>
<li>在EFCore中体现Model之间的关系有两种方式：<ol>
<li>使用导航属性</li>
<li>在DbContext中配置</li>
</ol>
</li>
</ul>
<h4 id="使用导航属性"><a href="#使用导航属性" class="headerlink" title="使用导航属性"></a>使用导航属性</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Club</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Club</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Players = <span class="keyword">new</span> List&lt;Player&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> City &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//设置该属性在数据库中的类型为date</span></span><br><span class="line">    [<span class="meta">Column(TypeName = <span class="meta-string">"date"</span>)</span>] </span><br><span class="line">    <span class="keyword">public</span> DateTime DateOfEstablishment &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> History &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性，League跟Club属于一对多关系</span></span><br><span class="line">    <span class="keyword">public</span> League League &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性，Club跟Player属于一对多关系</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Player&gt; Players &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>每一个Club都有一个League属性，因为League属性有可能是指向同一个引用，所以它跟League是属于一对多关系，当EFCore在添加迁移时，它会扫描所有的Model，然后根据导航属性去生成Model之间的关系。</li>
</ul>
<h3 id="在DbContext中配置"><a href="#在DbContext中配置" class="headerlink" title="在DbContext中配置"></a>在DbContext中配置</h3><ul>
<li><p>新创建一个比赛类Game来模拟多对多关系，其中Game和Player是属于多对多关系。在这两个Model之间需要一个关系实体GamePlay。</p>
</li>
<li><p>再新建一个简历类Resume来模拟一对一关系</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_20-57-13.png" alt="Snipaste_2020-10-06_20-57-13"></p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Game</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Game</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GamePlayers = <span class="keyword">new</span> List&lt;GamePlayer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Round &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//类型后面加上?则表示了该属性为可空属性，对应于数据库就是null,而没加?的就是not null</span></span><br><span class="line">    <span class="keyword">public</span> DateTimeOffset? StartTime &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GamePlayer&gt; GamePlayers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Player</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Player</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        GamePlayers = <span class="keyword">new</span> List&lt;GamePlayer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime DateOfBirth &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;GamePlayer&gt; GamePlayers &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//外键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> ResumeId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> Resume Resume &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GamePlayer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GamePlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> PlayerId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> GameId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> Game Game &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> Player Player &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Resume</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Resume</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//外键</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> PlayId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">//导航属性</span></span><br><span class="line">    <span class="keyword">public</span> Player Player &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在DbContext有一个OnModelCreating方法，重写它可以对Model进行一些配置，这种配置包括：对属性的约束、对属性类型的修改、添加种子数据等等。如果不在OnModelCreating方法中指定一对一的主体，那么EFCore就会随机选择一个作为主体，所以你可以再OnModelCreating方法中进行指定，这里的主体为Resume，它有一个PlayId的外键。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">ModelBuilder modelBuilder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//联合主键</span></span><br><span class="line">    modelBuilder.Entity&lt;GamePlayer&gt;().HasKey(x =&gt; <span class="keyword">new</span> &#123; x.PlayerId, x.GameId &#125;);</span><br><span class="line">    <span class="comment">//Player和Resume的一对一关系，这样就把Resume中的PlayId指定为外键</span></span><br><span class="line">    modelBuilder.Entity&lt;Resume&gt;()</span><br><span class="line">        .HasOne(x =&gt; x.Player)</span><br><span class="line">        .WithOne(x =&gt; x.Resume)</span><br><span class="line">        .HasForeignKey&lt;Resume&gt;(x =&gt; x.PlayId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后添加迁移、应用到数据库</li>
</ul>
<h3 id="添加日志支持"><a href="#添加日志支持" class="headerlink" title="添加日志支持"></a>添加日志支持</h3><h4 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h4><ul>
<li>在Linq.Data中添加控制台日志的依赖</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.SqlServer"</span> <span class="attr">Version</span>=<span class="string">"3.1.8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.EntityFrameworkCore.Tools"</span> <span class="attr">Version</span>=<span class="string">"3.1.8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PrivateAssets</span>&gt;</span>all<span class="tag">&lt;/<span class="name">PrivateAssets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">IncludeAssets</span>&gt;</span>runtime; build; native; contentfiles; analyzers; buildtransitive<span class="tag">&lt;/<span class="name">IncludeAssets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">PackageReference</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.Extensions.Logging.Console"</span> <span class="attr">Version</span>=<span class="string">"3.1.8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在DbContext中创建一个日志工厂</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//日志工厂，添加输出Sql语句的支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> ILoggerFactory ConsoleLoggerFactory =</span><br><span class="line">    LoggerFactory.Create(builder =&gt;</span><br><span class="line">                         &#123;</span><br><span class="line">                             <span class="comment">//添加过滤，category表示输出日志的种类，这里指执行的Sql语句</span></span><br><span class="line">                             <span class="comment">//level表示日志的级别</span></span><br><span class="line">                             builder.AddFilter((category, level) =&gt;</span><br><span class="line">                                               category == DbLoggerCategory.Database.Command.Name</span><br><span class="line">                                               &amp;&amp; level == LogLevel.Information)</span><br><span class="line">                                 <span class="comment">//表示输出到控制台</span></span><br><span class="line">                                 .AddConsole();</span><br><span class="line">                         &#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>最后在OnConfiguring方法中用UseLoggerFactory()来注册日志工厂</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnConfiguring</span>(<span class="params">DbContextOptionsBuilder optionsBuilder</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    optionsBuilder</span><br><span class="line">        .UseLoggerFactory(ConsoleLoggerFactory)</span><br><span class="line">        .UseSqlServer(</span><br><span class="line">        <span class="string">"Data Source=(localdb)\\MSSQLLocalDB; Initial Catalog=LinqDb"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ul>
<li>当执行完<code>context.Leagues.Add</code>后，数据并没有真正地插入到数据库中，只有执行了<code>context.SaveChanges()</code>这条语句时，数据才更新到了数据库中。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取DbContext对象，该对象需要手动Disposable，可以使用C#8的新语法using</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> context = <span class="keyword">new</span> LinqDbContext();</span><br><span class="line">    <span class="keyword">var</span> league = <span class="keyword">new</span> League</span><br><span class="line">    &#123;</span><br><span class="line">        Country = <span class="string">"Italy"</span>,</span><br><span class="line">        Name = <span class="string">"Serie A"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    context.Leagues.Add(league);</span><br><span class="line">    <span class="keyword">var</span> count = context.SaveChanges();</span><br><span class="line">    Console.WriteLine(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行后的结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_22-31-56.png" alt="Snipaste_2020-10-06_22-31-56"></p>
</li>
<li><p>AddRange：一次可以插入多条数据</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取DbContext对象，该对象需要手动Disposable，可以使用C#8的新语法</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> context = <span class="keyword">new</span> LinqDbContext();</span><br><span class="line">    <span class="keyword">var</span> serieA = context.Leagues.Single(x=&gt;x.Name==<span class="string">"Serie A"</span>);</span><br><span class="line">    <span class="keyword">var</span> league1 = <span class="keyword">new</span> League</span><br><span class="line">    &#123;</span><br><span class="line">        Country = <span class="string">"Italy"</span>,</span><br><span class="line">        Name = <span class="string">"Serie B"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> league2 = <span class="keyword">new</span> League</span><br><span class="line">    &#123;</span><br><span class="line">        Country = <span class="string">"Italy"</span>,</span><br><span class="line">        Name = <span class="string">"Serie C"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> club = <span class="keyword">new</span> Club</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"AC Milan"</span>,</span><br><span class="line">        City = <span class="string">"Milan"</span>,</span><br><span class="line">        DateOfEstablishment = <span class="keyword">new</span> DateTime(<span class="number">1899</span>, <span class="number">12</span>, <span class="number">16</span>),</span><br><span class="line">        League = serieA</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用context.xxx.AddRange可以添加指定类型的Model</span></span><br><span class="line">    <span class="comment">//也可使用context.AddRange可以添加不同类型的Model</span></span><br><span class="line">    context.AddRange(league1, league2, club);</span><br><span class="line">    <span class="keyword">var</span> count = context.SaveChanges();</span><br><span class="line">    Console.WriteLine(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行后的结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_22-43-13.png" alt="Snipaste_2020-10-06_22-43-13"></p>
</li>
</ul>
<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取DbContext对象，该对象需要手动Disposable，可以使用C#8的新语法</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> context = <span class="keyword">new</span> LinqDbContext();</span><br><span class="line">    <span class="keyword">var</span> italy = <span class="string">"Italy"</span>;</span><br><span class="line">    <span class="comment">//当context遇到ToList或者for循环就会触发查询</span></span><br><span class="line">    <span class="keyword">var</span> leagues = context.Leagues</span><br><span class="line">        .Where(x =&gt; x.Country == italy)</span><br><span class="line">        .ToList();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> league <span class="keyword">in</span> leagues)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(league.Name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用foreach循环和ToList的区别是：使用ToList是遇到ToList时，数据库连接才会打开</span></span><br><span class="line">    <span class="comment">//而使用foreach时，当开始进行遍历的时候，连接就打开了，直到循环结束，连接才断开</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> league <span class="keyword">in</span> context.Leagues)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(league.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>在这里需要注意：</p>
<ol>
<li>ToList和foreach的区别，推荐使用ToList后再遍历集合</li>
<li>在查询leagues时，Where条件中使用的是一个变量，当执行Sql时，EFCore就会为其创建一个变量，而如果使用一个固定值”Italy”的话，EFCore会直接把固定值插到条件中。</li>
</ol>
</li>
<li><p>运行结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_22-58-07.png" alt="Snipaste_2020-10-06_22-58-07"></p>
</li>
<li><p>在DbContext中在<code>UseLoggerFactory</code>后面添加<code>.EnableSensitiveDataLogging()</code>会使输出的Sql中参数的值给输出。</p>
</li>
</ul>
<h4 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h4><ul>
<li>这里有两种写法：<ol>
<li>使用Contains</li>
<li>使用EF提供的Like方法</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取DbContext对象，该对象需要手动Disposable，可以使用C#8的新语法</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">var</span> context = <span class="keyword">new</span> LinqDbContext();</span><br><span class="line">    <span class="keyword">var</span> leagues1 = context.Leagues</span><br><span class="line">        .Where(x=&gt;x.Country.Contains(<span class="string">"a"</span>))</span><br><span class="line">        .ToList();</span><br><span class="line">    <span class="keyword">var</span> leagues2 = context.Leagues</span><br><span class="line">        .Where(x =&gt; EF.Functions.Like(x.Country, <span class="string">"%a%"</span>))</span><br><span class="line">        .ToList();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> league <span class="keyword">in</span> leagues1)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(league.Name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> league <span class="keyword">in</span> leagues2)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(league.Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_23-07-26.png" alt="Snipaste_2020-10-06_23-07-26"></p>
</li>
</ul>
<h4 id="更多常见的有关查询的方法"><a href="#更多常见的有关查询的方法" class="headerlink" title="更多常见的有关查询的方法"></a>更多常见的有关查询的方法</h4><ul>
<li>First()、FirstOrDefault()：返回第一个。</li>
<li>Single()、SingleOrDefault()：返回单个，如果Model多于一个，就会抛出异常。</li>
<li>Last() LastOrDefault()：返回最后一个，使用这个方法必须对集合进行排序。</li>
<li>Count()、LongCount()、Min()、Max()、Average()、Sum()</li>
<li>Find()：如果可以在内存中找到Model，则直接在内存中读取数据。</li>
<li>这些方法都有它们对应的异步版本，就是在方法名后面加上Async。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> single = context.Leagues</span><br><span class="line">    .SingleOrDefault(x =&gt; x.Id == <span class="number">2</span>);</span><br><span class="line"><span class="comment">//由于前面使用Single已经把数据读到了内存中，执行Find时，它是从内存在拿数据，所以只执行了一条sql语句</span></span><br><span class="line"><span class="keyword">var</span> find = context.Leagues.Find(<span class="number">2</span>);</span><br><span class="line">Console.WriteLine(single.Name);</span><br><span class="line">Console.WriteLine(find.Name);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_23-22-03.png" alt="Snipaste_2020-10-06_23-22-03"></p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> last = context.Leagues</span><br><span class="line">    <span class="comment">//倒序</span></span><br><span class="line">    .OrderByDescending(x=&gt;x.Id)</span><br><span class="line">    .LastOrDefault(x=&gt;x.Name.Contains(<span class="string">"e"</span>));</span><br><span class="line">Console.WriteLine(last.Name);</span><br></pre></td></tr></table></figure></div>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//EFCore只能删除被追踪的数据</span></span><br><span class="line"><span class="keyword">var</span> milan = context.Clubs.Single(x=&gt;x.Name==<span class="string">"AC Milan"</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">context.Remove(milan);</span><br><span class="line"><span class="comment">// context.Clubs.Remove(milan);</span></span><br><span class="line"><span class="comment">// context.RemoveRange(milan, milan);</span></span><br><span class="line"><span class="comment">// context.Clubs.RemoveRange(milan, milan);</span></span><br><span class="line"><span class="comment">//只用当遇到SaveChanges，这笔数据才会被删除</span></span><br><span class="line"><span class="keyword">var</span> count = context.SaveChanges();</span><br><span class="line">Console.WriteLine(count);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_23-37-41.png" alt="Snipaste_2020-10-06_23-37-41"></p>
</li>
</ul>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul>
<li>由于EFCore会自动地追踪我们创建的Model，所以当我们在进行增删改时，EFCore会帮我们把修改的情况给暂存，直到context执行<code>SaveChanges</code>时，EFCore才会把改动应用到数据库中</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> league = context.Leagues.First();</span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">league.Name += <span class="string">"~~"</span>;</span><br><span class="line"><span class="comment">//保存修改到数据库</span></span><br><span class="line"><span class="keyword">var</span> count = context.SaveChanges();</span><br><span class="line">Console.WriteLine(count);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_23-39-00.png" alt="Snipaste_2020-10-06_23-39-00"></p>
</li>
</ul>
<h3 id="删除追踪和附加追踪"><a href="#删除追踪和附加追踪" class="headerlink" title="删除追踪和附加追踪"></a>删除追踪和附加追踪</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当执行了AsNoTracking方法后EFCore就不会对league对象进行追踪</span></span><br><span class="line"><span class="comment">//如果现在执行SaveChanges方法，修改并不会应用到数据库</span></span><br><span class="line"><span class="keyword">var</span> league = context.Leagues.AsNoTracking().First();</span><br><span class="line">league.Name += <span class="string">"++"</span>;</span><br><span class="line"><span class="comment">//当使用Update方法时，EFCore会重新地对league附加追踪，</span></span><br><span class="line"><span class="comment">//这时执行SaveChanges方法，修改会应用到数据库</span></span><br><span class="line">context.Leagues.Update(league);</span><br><span class="line"><span class="keyword">var</span> count = context.SaveChanges();</span><br><span class="line">Console.WriteLine(count);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>运行结果：</p>
<p><img src="/2020/10/06/EntityFramework-Core2%E2%80%94%E2%80%94Model%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE%E3%80%81Model%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AE%BE%E7%BD%AE%E3%80%81%E6%97%A5%E5%BF%97%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/Snipaste_2020-10-06_23-46-29.png" alt="Snipaste_2020-10-06_23-46-29"></p>
</li>
<li><p>也可以在Context中全局设置删除追踪，在构造器中加上这一句<code>ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;</code>，这个功能一般不用，因为我们还是需要EFCore为我们追踪Model。</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinqDbContext</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV1xa4y1v7rR?p=7" target="_blank" rel="noopener">B站杨旭</a></p>
]]></content>
      <categories>
        <category>-EFCore</category>
      </categories>
      <tags>
        <tag>-EFCore -C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——对象的储存方式</title>
    <url>/2020/07/12/Java%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="存储的地方"><a href="#存储的地方" class="headerlink" title="存储的地方"></a>存储的地方</h3><p>在Java中有五个不同的地方可以存储数据：</p>
<ul>
<li>寄存器，这是最快的存储区，它位于处理器的内部，是最高效也是最少量的存储区。在Java中不能直接控制，也不能在程序中感受到寄存器的存在，它都是由系统自动分配的。</li>
<li>堆栈，位于通用的RAM中，通过堆栈指针就可以实现对堆栈的操控，若指针向下移动则分配新的内存，向上移动则释放内存。这是一种快速有效的存储方式，仅次于寄存器。但是，在分配堆栈空间时，必须向系统提供堆栈所有项的生命周期，以便上下移动指针，否则堆栈将会溢出。这一约束限制了程序的灵活性，虽然Java的一些数据存储在堆栈中，但Java对象并存储在这其中。</li>
<li>堆，也是位于RAM中，用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多久，因此，在堆里分配存储有很大的灵活性，但这种灵活性要付出相应的代价：用堆进行储存分配和清理可能比用堆栈进行存储分配需要更多的时间（这也就是Java的性能不如C++的主要原因）。</li>
<li>常量存储，常量值通常直接放在程序代码的内部，这样做比较安全，因为它永远也不会改变，也可以把它放在ROM（只读存储器）中</li>
<li>非RAM存储，数据完全存活在程序之外，不受程序控制，在程序没有运行时也能存活。一般指持久化对象（数据库等）和流对象，在流对象中，对象转化成字节流，发送到另一个机器中。在持久化对象中，对象放在磁盘上。在需要时，把对象转化成基于RAM的对象。</li>
</ul>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>大小</th>
<th>最大值</th>
<th>最小值</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1bit</td>
<td>-</td>
<td>-</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>16bit</td>
<td>Unicode0</td>
<td>Unicode2^16-1</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>8bit</td>
<td>-128</td>
<td>+127</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16bit</td>
<td>-2^15</td>
<td>+2^15-1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>32bit</td>
<td>-2^31</td>
<td>+2^31-1</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64bit</td>
<td>-2^63</td>
<td>+2^63-1</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64bit</td>
<td>IEEE754</td>
<td>IEEE754</td>
<td>Double</td>
</tr>
</tbody></table>
<p>Java提供了两个用于高精度计算的类：BigInteger和BigDecimal，一个用于整型，另一个用于浮点型。</p>
<p>通常，表达式中出现最大的数据类型决定了表达式最终结果的数据类型，如float和double相加，最终结果为double；如果要使最终结果变成其他的数据类型，则要用到类型转换，但这有可能会导致数据的丢失。</p>
]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——IO系统1</title>
    <url>/2020/09/05/Java%E2%80%94%E2%80%94IO%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><ol>
<li>含义：File指代的并不是文件，它既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称，它同时包含了许多操作真实文件的手柄。</li>
<li><code>list()</code>和<code>listFiles()</code>：调用File对象的list方法可以返回当前文件（夹）下的所有文件的文件名，而listFiles方法则返回当前文件（夹）下的所有文件的文件对象</li>
<li><code>FilenameFilter</code>：当使用<code>list</code>或者是<code>listFiles</code>方法时，可以配合实现了<code>FilenameFilter</code>的类对象来对返回的文件进行过滤，这个接口拥有一个accept方法，可以将过滤的规则逻辑写在该方法中，下面是一个例子：</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//File代表的并不是文件，而是一个特定文件的名称，又能代表一个目录下的一组文件的名称</span></span><br><span class="line">        <span class="keyword">final</span> File file = <span class="keyword">new</span> File(<span class="string">"D:/"</span>);</span><br><span class="line">        String[] list;</span><br><span class="line">        <span class="comment">//使用list方法可以让文件对象返回一个字符数组，该字符数组里存放着File文件的名称列表</span></span><br><span class="line">        list = file.list();</span><br><span class="line">        <span class="comment">//往list中传入过滤器可以使它回调filter中的accept方法（策略模式），即filter完善了list提供服务时所需要的算法</span></span><br><span class="line">        <span class="keyword">final</span> String[] asps = file.list(<span class="keyword">new</span> DirFilter(<span class="string">"Java"</span>));</span><br><span class="line">        <span class="keyword">for</span> (String asp : asps) &#123;</span><br><span class="line">            System.out.println(<span class="string">"asp = "</span> + asp);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for (String s : list) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println("s = " + s);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DirFilter是一个过滤器，创建这个类的目的是把accept方法提供给list使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pattern pattern;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirFilter</span><span class="params">(String regex)</span> </span>&#123;</span><br><span class="line">        pattern = Pattern.compile(regex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir 文件对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用正则表达式过滤文件名</span></span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用匿名内部类过滤"><a href="#使用匿名内部类过滤" class="headerlink" title="使用匿名内部类过滤"></a>使用匿名内部类过滤</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirList2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> File file = <span class="keyword">new</span> File(<span class="string">"D:/"</span>);</span><br><span class="line">        <span class="keyword">final</span> String[] list = file.list(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="keyword">private</span> Pattern pattern = Pattern.compile(<span class="string">"Java"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="目录实用工具"><a href="#目录实用工具" class="headerlink" title="目录实用工具"></a>目录实用工具</h3><ul>
<li>通过递归来输出目录下所有文件的文件名，这里的TreeInfo相当于Directory中的目录树信息，第一个TreeInfo将会存储所有文件的文件信息。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> net.mindview.util.PPrint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Spliterator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(File dir, <span class="keyword">final</span> String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="keyword">private</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> pattern.matcher(<span class="keyword">new</span> File(name).getName()).matches();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> File[] local(String path, <span class="keyword">final</span> String regex)&#123;</span><br><span class="line">        <span class="keyword">return</span> local(<span class="keyword">new</span> File(path), regex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeInfo</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">File</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//文件列表</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//目录列表</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;File&gt; dirs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;File&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> files.iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> File&gt; action)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(TreeInfo other)</span></span>&#123;</span><br><span class="line">            files.addAll(other.files);</span><br><span class="line">            dirs.addAll(other.dirs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"dirs: "</span>+ PPrint.pformat(dirs)+<span class="string">"\n\nfiles: "</span>+PPrint.pformat(files);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String start, String regex)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recurseDirs(<span class="keyword">new</span> File(start), regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start, String regex)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recurseDirs(start, regex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(File start)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recurseDirs(start, <span class="string">".*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeInfo <span class="title">walk</span><span class="params">(String start)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> recurseDirs(<span class="keyword">new</span> File(start), <span class="string">".*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断当前文件是否是目录，若是目录，就将当前的目录列表添加到目录树中，然后递归创建新的目录树再进行迭代</span></span><br><span class="line"><span class="comment">         * 若不是目录就是普通文件，直接将其添加到当前目录树的文件列表中</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> startDir 开始的目录</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> regex 正则表达式</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 返回目录树，递归后里面存储的是开始目录中所有的文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeInfo <span class="title">recurseDirs</span><span class="params">(File startDir, String regex)</span> </span>&#123;</span><br><span class="line">            TreeInfo result = <span class="keyword">new</span> TreeInfo();</span><br><span class="line">            <span class="keyword">for</span> (File file : startDir.listFiles()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">                    result.dirs.add(file);</span><br><span class="line">                    result.addAll(recurseDirs(file, regex));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (file.getName().matches(regex))</span><br><span class="line">                    result.files.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//            if (args.length == 0)</span></span><br><span class="line"><span class="comment">//                System.out.println(walk("."));</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//                for (String arg : args) &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.println(walk(arg));</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            System.out.println(walk(<span class="keyword">new</span> File(<span class="string">"D://CloudMusic"</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用策略模式来输出目录"><a href="#使用策略模式来输出目录" class="headerlink" title="使用策略模式来输出目录"></a>使用策略模式来输出目录</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFiles</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProcessFiles</span><span class="params">(Strategy strategy, String ext)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">        <span class="keyword">this</span>.ext = ext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.length == <span class="number">0</span>)&#123;</span><br><span class="line">                processDirectoryTree(<span class="keyword">new</span> File(<span class="string">"."</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">                    File fileArg = <span class="keyword">new</span> File(arg);</span><br><span class="line">                    <span class="keyword">if</span> (fileArg.isDirectory())</span><br><span class="line">                        processDirectoryTree(fileArg);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!arg.endsWith(<span class="string">"."</span>+ext))</span><br><span class="line">                            arg += <span class="string">"."</span>+ext;</span><br><span class="line">                        strategy.process(<span class="keyword">new</span> File(arg).getCanonicalFile());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDirectoryTree</span><span class="params">(File root)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : Directory.TreeInfo.walk(root.getAbsolutePath(), <span class="string">".*\\."</span> + ext)) &#123;</span><br><span class="line">            strategy.process(file.getCanonicalFile());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的Strategy是实现策略模式的一个实例，ProcessFile通过Strategy某种策略来对某些对象执行策略规定的操作</span></span><br><span class="line">        <span class="keyword">new</span> ProcessFiles(<span class="keyword">new</span> ProcessFiles.Strategy()&#123;</span><br><span class="line">            <span class="comment">//搜寻特定的扩展名，然后对搜寻到的文件执行特定的操作</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"class"</span>).start(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="File的一些常用方法"><a href="#File的一些常用方法" class="headerlink" title="File的一些常用方法"></a>File的一些常用方法</h3><ol>
<li><p>isDirectory()：判断当前文件是否为目录</p>
</li>
<li><p>isFile()：判断当前文件是否为普通文件</p>
</li>
<li><p>exists()：判断当前文件是否存在</p>
</li>
<li><p>mkdir()：创建目录</p>
</li>
<li><p>mkdirs()：创建目录，它可以创建任意复杂的目录路径</p>
</li>
<li><p>delete()：删除目录</p>
</li>
<li><p>canRead()/canWrite()：判断当前文件是否可读可写</p>
</li>
<li><p>length()：文件的长度</p>
<p>。。。</p>
</li>
</ol>
<ul>
<li>File有很多方法，可以去JDK文档中查看</li>
</ul>
<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><ul>
<li>通常I/O类库经常使用流这个抽象概念，他代表了任何有能力产出数据的数据源对象或有能力接收数据的接收端对象。</li>
<li>任何自<code>Inputstream</code>或<code>Reader</code>派生而来的类都含有名为<code>read()</code>的基本方法，用于读取单个字节或字节数组；而任何自<code>Outputstream</code>或<code>Writer</code>派生而来的类都含有名为<code>writer()</code>的基本方法，用于写单个字节或字节数组。而我们通常不会使用这些方法，它们一般都是其他JDK类去使用的。</li>
</ul>
<h4 id="InputStream类型"><a href="#InputStream类型" class="headerlink" title="InputStream类型"></a>InputStream类型</h4><ul>
<li><code>InputStream</code>的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：<ol>
<li>字节数组</li>
<li>String对象</li>
<li>文件</li>
<li>”管道“</li>
<li>其他</li>
</ol>
</li>
<li>每一种数据源都有相对应的<code>InputStream</code>子类，下面是各种<code>InputStream</code>类型</li>
</ul>
<table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
<th align="center">如何使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ByteArrayInputStream</td>
<td align="center">允许将内存的缓存区当作InputStream使用</td>
<td align="center">缓存区，字节将从中取出</td>
</tr>
<tr>
<td align="center">StringBufferInputStream</td>
<td align="center">将String转换成InputStream</td>
<td align="center">字符串，底层实际上是使用StringBuffer</td>
</tr>
<tr>
<td align="center">FileInputStream</td>
<td align="center">用于从文件中读取信息</td>
<td align="center">字符串，表示文件名、文件或FileDescriptor对象</td>
</tr>
<tr>
<td align="center">PipedInputStream</td>
<td align="center">产生用于写入相关PipedOutputStream的数据，实现管道化</td>
<td align="center">作为多线程中的数据源</td>
</tr>
<tr>
<td align="center">SequenceInputStream</td>
<td align="center">将多个InputStream对象转换成单一InputStream</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FilterInputStream</td>
<td align="center">抽象类，作为”装饰器“的接口。为其他的InputStream类提供有用的功能</td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="OutputStream类型"><a href="#OutputStream类型" class="headerlink" title="OutputStream类型"></a>OutputStream类型</h4><table>
<thead>
<tr>
<th align="center">类</th>
<th align="center">功能</th>
<th align="center">如何使用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ByteArrayOutputStream</td>
<td align="center">在内存中创建缓存区</td>
<td align="center">缓冲区初始化，用于指定数据的目的地</td>
</tr>
<tr>
<td align="center">FileOutputStream</td>
<td align="center">用于将信息写入文件</td>
<td align="center">字符串，指定数据的目的地</td>
</tr>
<tr>
<td align="center">PipedOutputStream</td>
<td align="center">任何写入其中的信息都会自动作为相关PipedOutputStream的输出</td>
<td align="center">指定用于多线程数据的目的地</td>
</tr>
<tr>
<td align="center">FilterOutputStream</td>
<td align="center">抽象类，作为”装饰器“的接口。为其他的OutputStream类提供有用的功能</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="Reader和Writer"><a href="#Reader和Writer" class="headerlink" title="Reader和Writer"></a>Reader和Writer</h3><ul>
<li>设计Reader和Writer主要是为了国际化，老的I/O系统继承层次结果仅支持8位字节流，并不能很好地处理16位地Unicode字符；而添加Reader和Writer的目的就是让I/O可以处理16位的Unicode字符。所以，尽量地使用Reader和Writer。</li>
<li>每个旧的I/O流都会有新的I/O流类型</li>
</ul>
<table>
<thead>
<tr>
<th>旧的Java1.0</th>
<th>新的Java1.1</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>OutputStream</td>
<td>Writer</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>FileInputStreamWriter</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>FileOutputStreamWriter</td>
</tr>
<tr>
<td>StringBufferInputStream</td>
<td>StringReader</td>
</tr>
<tr>
<td>StringBufferOutputStream</td>
<td>StringWriter</td>
</tr>
<tr>
<td>ByteArrayInputStream</td>
<td>CharArrayReader</td>
</tr>
<tr>
<td>ByteArrayOutputStream</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>PipedReader</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>PipedWriter</td>
</tr>
</tbody></table>
<h3 id="独立的类：RandomAccessFile"><a href="#独立的类：RandomAccessFile" class="headerlink" title="独立的类：RandomAccessFile"></a>独立的类：RandomAccessFile</h3><ul>
<li>RandomAccessFile是用来操作由大小已知的记录组成的文件，它实现了DataInput和DataOutput接口，它跟InputStream和OutputStream没有任何关系，这是因为该类有别于其他I/O类本质不同的行为，使用它可以中一个文件内向前或向后移动。</li>
<li><code>getFilePointer()</code>用于查找当前所处的文件位置，<code>seek()</code>用于在文件内移至新的位置，<code>length()</code>用于判断文件的最大尺寸，另外，构造器还需要第二个参数，它表示的是”随机读“（r）还是”既读又写“（rw），它并不支持只写文件。</li>
</ul>
<h3 id="输入示例"><a href="#输入示例" class="headerlink" title="输入示例"></a>输入示例</h3><h4 id="缓冲输入文件"><a href="#缓冲输入文件" class="headerlink" title="缓冲输入文件"></a>缓冲输入文件</h4><ul>
<li>使用BufferedReader可以对文件进行缓冲，它需要一个Reader对象，这里使用一个FileReader，用来输出文件的内容。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//将文件进行缓存，可以提高速度</span></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line"></span><br><span class="line">        String s;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//该对象每读取文件中的一行，就将行数据添加到StringBuilder对象中</span></span><br><span class="line">        <span class="keyword">while</span>((s = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(s + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        in.close();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(read(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\BufferedInputFile.java"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="从内存中输入"><a href="#从内存中输入" class="headerlink" title="从内存中输入"></a>从内存中输入</h4><ul>
<li>read()是以int形式返回下一个字节，所以必须把它转换成char才能正确打印</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.StringReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//从BufferedInputFile读取出来的字符串被用来创建一个StringReader对象</span></span><br><span class="line">        StringReader reader = <span class="keyword">new</span> StringReader(</span><br><span class="line">                BufferedInputFile.read(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\MemoryInput.java"</span>));</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="comment">//该对象每读取一个字符，就把它输出到控制台</span></span><br><span class="line">        <span class="keyword">while</span>((c = reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="格式化内存输入"><a href="#格式化内存输入" class="headerlink" title="格式化内存输入"></a>格式化内存输入</h4><ul>
<li>必须把字符串转换成<code>ByteArrayInputStream</code>可接受的字节数组，然后使用一个<code>InputStream</code>初始化<code>DataInputStream</code></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormattedMemoryInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果是面向字节的I/O类。则我们必须使用InputStream，而不是Reader，在这里可以使用DataInputStream</span></span><br><span class="line">            <span class="keyword">final</span> DataInputStream reader = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                    <span class="comment">//ByteArrayInputStream需要一个字节数组</span></span><br><span class="line">                    <span class="keyword">new</span> ByteArrayInputStream(</span><br><span class="line">                            BufferedInputFile.read(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\FormattedMemoryInput.java"</span>).getBytes()));</span><br><span class="line">            <span class="comment">//返回的字节并不能来检测输入是否结束</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)reader.readByte());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"End of stream"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>若想判断输入是否结束，可以使用<code>DataInputSream</code>的<code>available</code>方法来进行检测，这里使用<code>FileInputStream</code>来指定文件。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEOF</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\TestEOF.java"</span>)));</span><br><span class="line">        <span class="comment">//使用available来查看还有多少可供存取的字符</span></span><br><span class="line">        <span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a>输出示例</h3><h4 id="基本的文件输出"><a href="#基本的文件输出" class="headerlink" title="基本的文件输出"></a>基本的文件输出</h4><ul>
<li><code>FileWriter</code>对象可以向文件写入数据，先创建一个<code>FileWriter</code>对象指定文件，然后使用<code>BufferedWriter</code>将其包装用以缓存输出，为了提供格式化机制，它继续被包装成了<code>PrintWriter</code>对象，使用该对象就可以进行格式化的输出。也可以使用快捷的方式避免重复的包装<code>PrintWriter out = new PrintWriter(file);</code>。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicFileOutput</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"BasicFileOutput.out"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\BasicFileOutput.java"</span>)));</span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(file)));</span><br><span class="line">        <span class="keyword">int</span> lineCount = <span class="number">1</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="comment">//这里仍需使用Reader来判断是否读取完毕</span></span><br><span class="line">        <span class="keyword">while</span>((s = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            out.println(lineCount++ +<span class="string">": "</span>+s);</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        System.out.println(BufferedInputFile.read(file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="存储和恢复数据"><a href="#存储和恢复数据" class="headerlink" title="存储和恢复数据"></a>存储和恢复数据</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.crypto.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoringAndRecoveringData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用OutputStream来写入数据</span></span><br><span class="line">        DataOutputStream out = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">        <span class="comment">//进行写入</span></span><br><span class="line">        out.writeDouble(<span class="number">3.14</span>);</span><br><span class="line">        out.writeUTF(<span class="string">"That is pi"</span>);</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">//使用InputStream来恢复数据</span></span><br><span class="line">        DataInputStream in = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>)));</span><br><span class="line">        <span class="comment">//进行读取</span></span><br><span class="line">        System.out.println(in.readDouble());</span><br><span class="line">        System.out.println(in.readUTF());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="RandomAccessFile示例"><a href="#RandomAccessFile示例" class="headerlink" title="RandomAccessFile示例"></a>RandomAccessFile示例</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsingRandomAccessFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String file = <span class="string">"rtest.dat"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            System.out.println(rf.readDouble());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(rf.readUTF());</span><br><span class="line">        rf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            rf.writeDouble(i*<span class="number">1.414</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读写字符串使用UTF的格式更为可靠，因为UTF是一种多字节格式，其编码长度会根据实际使用的字符集会有所变化</span></span><br><span class="line">        rf.writeUTF(<span class="string">"The end of the file"</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">        rf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"rw"</span>);</span><br><span class="line">        <span class="comment">//这里的double类型是8字节长，使用seek(5*8)可以把光标移动到第五个double值下方，然后覆盖重写</span></span><br><span class="line">        rf.seek(<span class="number">5</span>*<span class="number">8</span>);</span><br><span class="line">        rf.writeDouble(<span class="number">47.0001</span>);</span><br><span class="line">        rf.close();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>管道流：<code>PipedInputStream</code>、<code>PipedOutputStream</code>、<code>PipedReader</code>、<code>PipedWriter</code>用于任务之间的通信，到后面讲到多线程的时候再提及。</li>
</ul>
<h3 id="自定义文件读写实用工具"><a href="#自定义文件读写实用工具" class="headerlink" title="自定义文件读写实用工具"></a>自定义文件读写实用工具</h3><ul>
<li>为了简化每一次读写文件的编码，我们可以自定义一个工具类来进行文件读写。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.soap.Text;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">read</span><span class="params">(String fileName)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(fileName));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                String s;</span><br><span class="line">                <span class="keyword">while</span> ((s = in.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    builder.append(s + <span class="string">"\n"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName, String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            PrintWriter out = new PrintWriter(new File(fileName).getAbsoluteFile());</span></span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                out.println(text);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName, String splitter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Arrays.asList(read(fileName).split(splitter)));</span><br><span class="line">        <span class="keyword">if</span> (get(<span class="number">0</span>).equals(<span class="string">""</span>))</span><br><span class="line">            remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TextFile</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(fileName, <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileOutputStream(fileName));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (String s : <span class="keyword">this</span>) &#123;</span><br><span class="line">                    out.println(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String file = read(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\TextFile.java"</span>);</span><br><span class="line">        write(<span class="string">"text.txt"</span>, file);</span><br><span class="line">        <span class="comment">//在创建对象的时候，会把文件中的内容填充到this的字符串列表上，使用"\n"分割</span></span><br><span class="line">        <span class="keyword">final</span> TextFile textFile = <span class="keyword">new</span> TextFile(<span class="string">"text.txt"</span>);</span><br><span class="line">        <span class="comment">//把列表中的字符串写到text2.txt中</span></span><br><span class="line">        textFile.write(<span class="string">"text2.txt"</span>);</span><br><span class="line">        TreeSet&lt;String&gt; words = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> TextFile(<span class="string">"D:\\Java\\JavaBasicCode\\IO\\src\\com\\muchlab\\io\\TextFile.java"</span>, <span class="string">"\\W+"</span>));</span><br><span class="line">        System.out.println(words.headSet(<span class="string">"a"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="读二进制文件"><a href="#读二进制文件" class="headerlink" title="读二进制文件"></a>读二进制文件</h3><ul>
<li>与TextFile类似，它也是简化读取二进制文件的工具类</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryFile</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 读</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(File bFile) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedInputStream bf = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(bFile));</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                data = <span class="keyword">new</span> <span class="keyword">byte</span>[bf.available()];</span><br><span class="line">                bf.read(data);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                bf.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] read(String fileName)&#123;</span><br><span class="line">        <span class="keyword">return</span> read(<span class="keyword">new</span> File(fileName).getAbsoluteFile());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//对二进制图片进行读取</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = BinaryFile.read(<span class="string">"C:\\Users\\14276\\OneDrive\\图片\\本机照片\\1.jpg"</span>);</span><br><span class="line">        <span class="keyword">final</span> ByteArrayInputStream byteArrayInputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        <span class="keyword">final</span> DataInputStream in = <span class="keyword">new</span> DataInputStream(byteArrayInputStream);</span><br><span class="line">        <span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="标准I-O"><a href="#标准I-O" class="headerlink" title="标准I/O"></a>标准I/O</h3><ul>
<li>程序所有的输入都可以来自于<code>标准输入</code>,它的所有输出也可以发送到<code>标准输出</code>，以及所有的错误信息都可以发送到<code>标准错误</code>,它的意义在于可以让我们很容易地将程序串联起来，即一个程序的标准输出可以成为另一个程序的标准输入。</li>
</ul>
<h4 id="从标准输入中读取"><a href="#从标准输入中读取" class="headerlink" title="从标准输入中读取"></a>从标准输入中读取</h4><ul>
<li>Java提供了<code>System.in</code>、<code>System.out</code>、<code>System.err</code>三个标准IO，其中<code>System.out</code>和<code>System.err</code>的底层是<code>PrintStream</code>对象，而<code>System.in</code>的底层是<code>InputStream</code>对象，所以，我们可以立即地使用out和err，但是在读取System.in之前必须对其进行包装。通常我们使用的是一行一行的读取，所以可以使用<code>BufferedReader</code>的readLine方法进行读取输入，这时就可以使用<code>InputStreamReader</code>把<code>System.in</code>转换成<code>Reader</code>。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Echo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader stdin = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = stdin.readLine())!=<span class="keyword">null</span> &amp;&amp; s.length()!=<span class="number">0</span>)</span><br><span class="line">            System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="将System-out转换成PrintWriter"><a href="#将System-out转换成PrintWriter" class="headerlink" title="将System.out转换成PrintWriter"></a>将System.out转换成PrintWriter</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeSystemOut</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out, <span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——内部类</title>
    <url>/2020/07/20/Java%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>将一个类的定义放在另一个类的定义内部，这就是内部类，外部类没有访问内部类成员的权限，它只能通过创建内部类的对象来调用内部类的成员。</p>
<h3 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Essay</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Content</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String content = <span class="string">"ABC"</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> content;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Content <span class="title">createContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Content();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Essay essay = <span class="keyword">new</span> Essay();</span><br><span class="line">        Content content = essay.createContent();</span><br><span class="line">        System.out.println(content.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链接到外部类"><a href="#链接到外部类" class="headerlink" title="链接到外部类"></a>链接到外部类</h3><p>当创建一个非静态内部类的对象时，它不能像正常创建对象那样去创建，它必须由一个外部类的对象去创建。所以，一个内部类会自动地保存创建它的外部类的引用，即它会自动拥有外部类的所有访问权（包括private成员）。如下，这是一个迭代器设计模式的例子，SequenceSelector可以访问Sequence中的items成员，通过items来实现对序列的end（判断是否结束）、current（取出当前元素）、next（下移）操作，这里的SequenceSelector对于Sequence来说是一个辅助类，它为Sequence提供了一个迭代的功能。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">current</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sequence <span class="title">getSequence</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequence</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> Object[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count&lt;items.length)</span><br><span class="line">            items[count++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若想为类创建一个辅助类，但不想向外部暴露这个辅助类的话，可以考虑使用内部类</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceSelector</span> <span class="keyword">implements</span> <span class="title">Selector</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (next&lt;items.length)</span><br><span class="line">                next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Sequence <span class="title">getSequence</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Sequence.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> items[next];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next == items.length;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Selector <span class="title">getSelector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//其实这里相当于this.new</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SequenceSelector();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sequence s = <span class="keyword">new</span> Sequence(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.items.length; i++) &#123;</span><br><span class="line">            s.add(<span class="string">"ABC"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Selector selector = s.getSelector();</span><br><span class="line">        <span class="keyword">while</span> (!selector.end())&#123;</span><br><span class="line">            System.out.print(selector.current()+<span class="string">" "</span>);</span><br><span class="line">            selector.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="内部类的访问修饰符"><a href="#内部类的访问修饰符" class="headerlink" title="内部类的访问修饰符"></a>内部类的访问修饰符</h3><p>跟普通类一样，内部类有本类、子类、包的这几个范围，根据修饰符的不同而有所变化。若把内部类声明为private，该内部类就只能在外部类的范围内进行访问。</p>
<table>
<thead>
<tr>
<th align="center">访问修饰符</th>
<th align="center">本类</th>
<th align="center">同包（无论是否继承）</th>
<th align="center">不同包的子类</th>
<th align="center">不同包的非子类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">true</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="使用-this与-new"><a href="#使用-this与-new" class="headerlink" title="使用.this与.new"></a>使用.this与.new</h3><p>在内部类中可以使用<code>外部类的类名.this</code>来表示外部类的引用，在外部类中，如果想要在创建某一个外部类对象关联的内部类，则可以使用<code>外部类的对象名.new</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DotThis.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//相当于Inner inner = this.new Inner()</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DotThis dotThis = <span class="keyword">new</span> DotThis();</span><br><span class="line">        <span class="comment">//由于在静态方法下没有this关键字，所以在静态方法下创建内部类对象时，必须指定其外部类的对象，</span></span><br><span class="line">        Inner inner = dotThis.<span class="keyword">new</span> Inner();</span><br><span class="line"></span><br><span class="line">        DotThis outer = inner.outer();</span><br><span class="line">        System.out.println(dotThis==outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="在不同的位置嵌入内部类"><a href="#在不同的位置嵌入内部类" class="headerlink" title="在不同的位置嵌入内部类"></a>在不同的位置嵌入内部类</h3><ol>
<li>定义在方法中的内部类</li>
<li>定义在作用域内的类，比如if作用域</li>
<li>实现了接口的匿名类</li>
<li>扩展了非默认构造器的匿名类</li>
<li>执行字段初始化的匿名类</li>
<li>通过实例初始化实现构造的匿名类</li>
</ol>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>没有类名的类，即匿名类，一般这种类只能定义在别的类内部，所以，也叫匿名内部类，它是用来创建一个继承自某个类的匿名类的对象，通过new表达式会自动向上转型为对父类的引用。如下content方法中创建了一个继承自Contents的匿名类对象，该对象在返回时，自动向上转型为Contents类型。即匿名内部类是继承机制的一个简写。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contents <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类，即创建一个继承自Contents的匿名类对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line">        Contents content = parcel.content();</span><br><span class="line">        System.out.println(content.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="通过有参构造来创建匿名内部类"><a href="#通过有参构造来创建匿名内部类" class="headerlink" title="通过有参构造来创建匿名内部类"></a>通过有参构造来创建匿名内部类</h3><p>由于Wrapping类中只有一个带参的构造器，在创建继承自Wrapping的匿名内部类对象时，如果不传参数，程序会因找不到构造器而报错。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrappinng</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wrappinng</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        i = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当基类没有默认构造器时，就需要传递相应的参数到基类的有参构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wrappinng <span class="title">wrappinng</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrappinng(x)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel2 parcel2 = <span class="keyword">new</span> Parcel2();</span><br><span class="line">        Wrappinng wrappinng = parcel2.wrappinng(<span class="number">10</span>);</span><br><span class="line">        System.out.println(wrappinng.value());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="通过实例初始化来实现匿名内部类的构造效果"><a href="#通过实例初始化来实现匿名内部类的构造效果" class="headerlink" title="通过实例初始化来实现匿名内部类的构造效果"></a>通过实例初始化来实现匿名内部类的构造效果</h3><p>由于匿名内部类没有类名，所以不能为该类去定义一个构造器，但可以使用初始化实例来实现构造器的效果，如下{…}就是一个初始化代码，可以起到构造的效果。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Destination</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="string">""</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当传入的参数是在匿名内部类中使用的就必须声明是final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Destination()&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">            <span class="comment">//通过对实例的初始化来达到在匿名内部类创建一个构造器的效果</span></span><br><span class="line">            &#123;</span><br><span class="line">                cost = Math.round(price);</span><br><span class="line">                <span class="keyword">if</span> (cost&gt;<span class="number">100</span>)</span><br><span class="line">                    System.out.println(<span class="string">"Over budget"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> String label = dest;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> label;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Parcel3 parcel3 = <span class="keyword">new</span> Parcel3();</span><br><span class="line">        Destination destination = parcel3.destination(<span class="string">"ABC"</span>, <span class="number">110F</span>);</span><br><span class="line">        System.out.println(destination.readLabel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用匿名内部类来简化工厂方法"><a href="#使用匿名内部类来简化工厂方法" class="headerlink" title="使用匿名内部类来简化工厂方法"></a>使用匿名内部类来简化工厂方法</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> MOVE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameFactory gameFactory = <span class="keyword">new</span> GameFactory()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Checkers Move "</span>+move);</span><br><span class="line">        <span class="keyword">return</span> ++move != MOVE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> MOVE = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//静态的匿名内部类对象，可以来简化工厂模式的设计</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameFactory gameFactory = <span class="keyword">new</span> GameFactory() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Chess();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Chess Move "</span>+move);</span><br><span class="line">        <span class="keyword">return</span> ++move != MOVE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">(GameFactory gameFactory)</span></span>&#123;</span><br><span class="line">        Game game = gameFactory.getGame();</span><br><span class="line">        <span class="keyword">while</span> (game.move());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        playGame(Checkers.gameFactory);</span><br><span class="line">        playGame(Chess.gameFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>如果不需要内部类对象与其外部类的对象之间有联系，那可以将内部类声明为static，这通常称为嵌套类。嵌套类一般表示着三种含义：1、不需要外部类的对象；2、不能从嵌套类的对象中访问非静态的外部类成员；3、普通内部类不能有static数据和static方法，但嵌套类可以包含这些东西。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelContent</span> <span class="keyword">implements</span> <span class="title">Contents</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParcelDestination</span> <span class="keyword">extends</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ParcelDestination</span><span class="params">(String label)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.label = label;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> label+i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherLevel</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Contents <span class="title">contents</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelContent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Destination <span class="title">destination</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ParcelDestination(<span class="string">"ParcelDestination1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有static修饰的内部类称为嵌套类，它不会被外部类所限制</span></span><br><span class="line">        <span class="comment">//在创建该内部类时，不用通过外部对象来进行创建，因为嵌套类没有this这个关键字</span></span><br><span class="line">        <span class="comment">//它就相当于外部类的一个静态代码块，包含数据和方法</span></span><br><span class="line">        Contents c = contents();</span><br><span class="line">        Destination d = destination();</span><br><span class="line">        System.out.println(c.value());</span><br><span class="line">        System.out.println(d.readLabel());</span><br><span class="line">        <span class="comment">//所以在这里可以直接创建嵌套类的对象</span></span><br><span class="line">        ParcelDestination parcelDestination = <span class="keyword">new</span> ParcelDestination(<span class="string">"ParcelDestination2"</span>);</span><br><span class="line">        System.out.println(parcelDestination.label);</span><br><span class="line">        System.out.println(ParcelDestination.AnotherLevel.x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="闭包与回调"><a href="#闭包与回调" class="headerlink" title="闭包与回调"></a>闭包与回调</h3><p>关于闭包，有下面几种解释：</p>
<ol>
<li>闭包是一个可调用的对象，它包含了一些信息，这些信息来自于创建它的作用域。</li>
<li>闭包是指可以包含自由（未绑定到特定对象）变量的代码块；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。</li>
<li>是引用了自由变量的函数。这个函数通常被定义在另一个外部函数中，并且引用了外部函数中的变量。</li>
</ol>
<p>在Java中，闭包是通过“接口和内部类来实现的”，可以看出，内部类是面对对象的闭包，它不仅包含了外部类对象的信息，还自动拥有了一个指向此外部类对象的引用，即内部类可以操作所有成员。因此可以把非静态内部类当成面向对象领域的闭包。那么，通过这种仿闭包的非静态内部类可以很方便地实现回调，这是一种非常灵活的功能。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Incrementable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee1</span> <span class="keyword">implements</span> <span class="title">Incrementable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"Callee1:"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(<span class="string">"MyIncrement:"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callee2</span> <span class="keyword">extends</span> <span class="title">MyIncrement</span></span>&#123;</span><br><span class="line">    <span class="comment">//Closure是在Callee2作用域范围内的闭包，在闭包内可以操作Callee2范围的所有成员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> <span class="keyword">implements</span> <span class="title">Incrementable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Callee2.<span class="keyword">this</span>.increment();</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"Closure:"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Incrementable <span class="title">getIncrementable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Closure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Caller</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Incrementable incrementable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Caller</span><span class="params">(Incrementable incrementable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当一个内部类对象传入时，Caller对象就可以使用此引用来回调Callee类，使其能够轻松地调用闭包中的成员，来间接操作Callee2作用域的成员</span></span><br><span class="line">        <span class="keyword">this</span>.incrementable = incrementable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span></span>&#123;</span><br><span class="line">        incrementable.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Callbacks</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Caller caller1 = <span class="keyword">new</span> Caller(<span class="keyword">new</span> Callee1());</span><br><span class="line">        <span class="comment">//在这里caller2表示回调，而new Callee2().getIncrementable()则表示一个闭包</span></span><br><span class="line">        Caller caller2 = <span class="keyword">new</span> Caller(<span class="keyword">new</span> Callee2().getIncrementable());</span><br><span class="line">        caller1.go();</span><br><span class="line">        caller2.go();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="内部类的继承"><a href="#内部类的继承" class="headerlink" title="内部类的继承"></a>内部类的继承</h3><p>当一个类是继承自内部类时，它的一部分成员是依赖于其继承的内部类的外部类的对象引用，所以，该类在构造时，必须传入一个指向外部类对象的引用，指定由此外部类去创建内部类，具体做法如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">            WithInner.<span class="keyword">this</span>.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Print in withinner."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    InheritInner(WithInner withInner) &#123;</span><br><span class="line">        <span class="comment">//想要构造一个继承自内部类的对象，就必须传入一个指向外部类对象的引用</span></span><br><span class="line">        withInner.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.call();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WithInner withInner = <span class="keyword">new</span> WithInner();</span><br><span class="line">        InheritInner inheritInner = <span class="keyword">new</span> InheritInner(withInner);</span><br><span class="line">        inheritInner.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="内部类标识符"><a href="#内部类标识符" class="headerlink" title="内部类标识符"></a>内部类标识符</h3><p>由于在编译后，每个类都会产生一个.class文件，为了区别内部类和外部类，一般都在编译的时候在外部类的后面加一个”$”，比如，上面的例子生成的class文件是：WithInner$Inner.class，若是匿名内部类，系统会生成一个数字作为匿名类的名字。</p>
]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——容器1</title>
    <url>/2020/08/28/Java%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A81/</url>
    <content><![CDATA[<h3 id="常用的容器"><a href="#常用的容器" class="headerlink" title="常用的容器"></a>常用的容器</h3><ul>
<li><p>Set: HashSet，<strong><em>LinkedHashSet，TreeSet，EnumSet</em></strong>（后三个有序）</p>
</li>
<li><p>List: ArrayList，LinkedList，Stack，Vector（全部有序）</p>
</li>
<li><p>Queue：LinkedBlockingQueue，ArraysBlockingQueue（全部有序）</p>
</li>
<li><p>Map: <strong><em>HashMap，TreeMap，LinkedHashMap</em></strong>，EnumMap，ConcurrentHashMap，IdentityHashMap（前三有序）</p>
</li>
<li><p>容器的继承关系</p>
</li>
</ul>
<p><img src="/2020/08/28/Java%E2%80%94%E2%80%94%E5%AE%B9%E5%99%A81/Java%E5%AE%B9%E5%99%A81%5CSnipaste_2020-08-20_16-02-44.png" alt="Snipaste_2020-08-20_16-02-44"></p>
<h3 id="Iterable接口"><a href="#Iterable接口" class="headerlink" title="Iterable接口"></a>Iterable接口</h3><ul>
<li>Iterable是一个超级接口，被Collection所继承。它只有一个方法： Iterator<T> iterator() //即返回一个迭代器</T></li>
</ul>
<ul>
<li><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为<strong>“轻量级”</strong>对象，因为创建它的代价小。</p>
</li>
<li><p>Java中的Iterator功能比较简单，并且只能<strong>单向移动</strong>：<br>(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。<br>　　(2) 使用next()获得序列中的下一个元素。<br>　　(3) 使用hasNext()检查序列中是否还有元素。<br>　　(4) 使用remove()将迭代器新返回的元素删除。</p>
</li>
<li><p>下面有一个小例子：</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现Iterable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableClass</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String[] words = &#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> index&lt;words.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> words[index++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : <span class="keyword">new</span> IterableClass()) &#123;</span><br><span class="line">            System.out.print(s+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ul>
<li>一个独立的元素序列，JDK 不提供此接口的任何直接 实现：它提供更具体的子接口（如 Set 和 List）实现。也就是一般不会直接使用Collection，而是会使用它的子类，如List或Set。</li>
<li>Collection会针对不同的子类规定不同的规则。比如：List必须按插入顺序保存元素；Set不能有重复的元素等等。</li>
</ul>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ul>
<li>Map是与Collection同层次的接口，它可以用来规定子类储存一组成对的“键值对”对象，允许使用键来查找值，也可以将它当成映射表或字典。</li>
</ul>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul>
<li>L。list是<strong>有序</strong>的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</li>
<li>用户插入的顺序或者指定的位置就是元素插入的位置。它与Set不同，List<strong>允许插入重复的值</strong>。</li>
</ul>
<h3 id="两个实现List接口的基本类型"><a href="#两个实现List接口的基本类型" class="headerlink" title="两个实现List接口的基本类型"></a>两个实现List接口的基本类型</h3><ol>
<li><code>ArrayList</code>：它长于随机访问元素，但是在List的中间插入与移除元素时较慢</li>
<li><code>LinkedList</code>：它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢。</li>
</ol>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>对于List，add()时插入元素的方法之一，而get()是取出元素的方法之一。但要使用容器，就必须对容器的确切类型进行编程，这会使代码不具备复用性。原本是对着List编码的，后面发现如果能够把相同的代码应用在Set，将会很方便，而<code>迭代器</code>就是来解决这个问题的。</li>
<li>迭代器是一种设计模式，它的工作是遍历并选择序列中的对象，程序员不必知道改序列的底层结构。此外，迭代器通常被称为<code>轻量级对象</code>，即创建它的代价小</li>
<li>Java的<code>Iterator</code>只能单向移动，使用迭代器的步骤如下：<ol>
<li>使用集合的iterator()方法可以返回一个Iterator对象。</li>
<li>使用Iterator对象的next()获取序列中的下一个元素</li>
<li>使用Iterator对象的hasNext()检查序列中是否还有元素</li>
<li>使用Iterator对象的remove()将迭代器新近返回的元素删除</li>
</ol>
</li>
<li>下面有一个小例子：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.container;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleIteration</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在这里需要注意的是：Arrays.asList()不可添加或删除元素，因为这个方法返回的是Arrays中继承AbstractList的内部类ArrayList，这个类并没有实现添加和删除操作。</span></span><br><span class="line">        ArrayList&lt;Pet&gt; pets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(pets, <span class="keyword">new</span> Pet(<span class="string">"A"</span>), <span class="keyword">new</span> Pet(<span class="string">"B"</span>), <span class="keyword">new</span> Pet(<span class="string">"C"</span>), <span class="keyword">new</span> Pet(<span class="string">"D"</span>));</span><br><span class="line">        Iterator&lt;Pet&gt; iterator = pets.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Pet p = iterator.next();</span><br><span class="line">            System.out.print(<span class="string">"Pet:"</span>+p.getName()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (Pet pet : pets) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Pet:"</span>+pet.getName()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        iterator = pets.iterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (Pet pet : pets) &#123;</span><br><span class="line">            System.out.print(<span class="string">"Pet:"</span>+pet.getName()+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul>
<li><code>LinkedList</code>相比起<code>ArrayList</code>还添加了可以使用作栈<code>Stack</code>、队列<code>Queue</code>或双端队列的方法。</li>
<li>获取元素：getFirst()、element()完全一样，都是返回列表的第一个元素，而不移除它，若List为空，则会抛出异常<code>NoSuchElementException</code>，peek()也是获取元素的方法，但它和前面两个方法的区别是它在List为空时会返回null。</li>
<li>添加元素：addFirst()、add()、addLast()都相同，它们都将某个元素插入到列表的末尾。</li>
<li>删除元素：removeFirst()和remove()完全一样，它们移除并返回列表的头，而removeLast()移除并返回列表的最后一个元素，但列表为空时，它们都会抛出异常<code>NoSuchElementException</code>。poll()则在列表为空时返回null。</li>
</ul>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li>Set不保存重复的元素，最常被使用的是测试归属性，你可以很容易地询问某个对象是否在某个Set中，正因如此，查找是Set最重要地操作。通常的做法是选择一个HashSet的实现，专门对查找进行优化。</li>
</ul>
<h3 id="Set三种常用的实现类型"><a href="#Set三种常用的实现类型" class="headerlink" title="Set三种常用的实现类型"></a>Set三种常用的实现类型</h3><ol>
<li><code>HashSet</code>：出于速度原因的考虑，HashSet使用的是散列函数，所以输出的顺序没有任何规律。</li>
<li><code>TreeSet</code>：TreeSet则将元素存储在红黑树数据结构中。</li>
<li><code>LinkedHashSet</code>：LinkedHashSet对元素的存储是跟HashSet一样，但它跟LinkedList一样使用链表来维护插入和删除操作。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>Collection保存单一类型的元素，而Map保存相关联的键值对，这两者都不能持有基本类型，但是Java的自动包装机制对仔细地执行基本类型和其对应的包装类之间的双向转换。</li>
<li>List可以建立数字索引和对象的关联，能够自动扩充容量</li>
<li>如果需要大量的随机访问，就使用ArrayList，如果需要使用大量的插入或删除元素，则使用LinkedList</li>
<li>各种Queue和栈的行y为，由LinkedList提供支持</li>
<li>Map是一种将对象与对象相关联的设计。HashMap设计用来快速访问；TreeMap保存键始终处于排序状态，所以没有HashMap快；LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问的能力。</li>
<li>Set不接受重复元素。HashSet提供最快的查询速度；而TreeSet保持元素处于排序状态；LinkedHashSet以插入顺序保存元素</li>
<li>建议不应该使用过时的Vector、Hashtable和Stack。</li>
</ol>
]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——包和访问权限</title>
    <url>/2020/07/16/Java%E2%80%94%E2%80%94%E5%8C%85%E5%92%8C%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="Java的包和访问权限"><a href="#Java的包和访问权限" class="headerlink" title="Java的包和访问权限"></a>Java的包和访问权限</h2><h3 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h3><ul>
<li>包的命名规则</li>
</ul>
<blockquote>
<p>包名全部由小写字母（多个单词也全部小写）；</p>
<p>如果包名包含多个层次，每个层次应该用“.”分割；</p>
<p>包名一般由倒置的域名开头，比如com.baidu；——不要有www </p>
<p>自定义包不能java开头；</p>
</blockquote>
<ul>
<li>包的作用</li>
</ul>
<blockquote>
<p>有利于类的查找与管理。一个软件由很多类构成，这些类按其功能可分为vo类、dao类、工具类、service类、controller类等，将这些类按其功能分门别类地放在不同包中有利于类的查找与管理；</p>
<p>解决了同名类命名冲突；</p>
<p>有利于保护类中的成员变量及其方法。类中成员变量及其方法前面的访问控制符决定了该变量和方法的使用范围；</p>
<p>例如：</p>
<blockquote>
<p>java.lang：提供利用 Java 编程语言进行程序设计的基础类，例如：String、Math、Integer、System和Thread等。<br>java.util：java工具类，包含对集合的操作、事件模型、日期和时间设施、国际化和各种实用工具类。<br>java.io：通过数据流、序列化和文件系统提供系统输入和输出。<br>java.net：为实现网络应用程序提供类。<br>java.awt：包含用于创建用户界面和绘制图形图像的所有类。</p>
</blockquote>
</blockquote>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li>访问控制符使用范围</li>
</ul>
<blockquote>
<p>public是最大的访问权限修饰符，其修饰的成员变量、构造方法和普通方法可在任何一个类中被操作或使用；</p>
<p>protected修饰的成员变量、构造方法和普通方法可以在其定义类中、与定义类同包的其它类（可以使子类）中和与定义类不同包但是其子类的类中使用；</p>
<p>默认（友好的）修饰的成员变量、构造方法和普通方法可以在其定义类中和与定义类同包的其它类（可以使子类）中使用；</p>
<p>private是最小的访问权限控制符，其修饰的成员变量、构造方法和普通方法只能在定义它们的类中被操作或使用；</p>
</blockquote>
<ul>
<li>访问权限表</li>
</ul>
<table>
<thead>
<tr>
<th align="center">访问修饰符</th>
<th align="center">本类</th>
<th align="center">同包（无论是否继承）</th>
<th align="center">不同包的子类</th>
<th align="center">不同包的非子类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">默认</td>
<td align="center">true</td>
<td align="center">true</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">true</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li>protected</li>
</ul>
<p>在不同包下的两个类（非继承），如果其中一个类想访问另一个类的protected字段或方法，则会报错，无论字段或方法是否是静态的。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA = <span class="string">"ABC"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> com.muchlab.son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.muchlab.foo.Foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">        System.out.println(foo.DATA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果两个类是继承关系，即Son继承Foo，则子类可以创建子类对象来访问继承过来的成员，但不能通过创建父类对象来访问其非静态成员。原因是创建子类对象是再同包中发生，而创建父类对象是在不同包下发生。但可以访问通过父类对象访问静态成员</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA = <span class="string">"ABC"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> com.muchlab.son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.muchlab.foo.Foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//可以访问</span></span><br><span class="line">        System.out.println(son.age);</span><br><span class="line">        Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">        <span class="comment">//不可以访问，报错</span></span><br><span class="line">        System.out.println(foo.age);</span><br><span class="line">        <span class="comment">//可以访问</span></span><br><span class="line">        System.out.println(foo.DATA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础指令</title>
    <url>/2019/08/22/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>一个完整的指令的标准格式：指令主体 [选项][操作对象]</p>
</li>
<li><p>关于路径：</p>
<p>  路径可以分为两种：</p>
<p>  相对路径：相对于某一个路径（一般是当前路径）</p>
<p>  绝对路径：绝对路径不需要参照物，直接从根“/”开始</p>
</li>
<li><p>相对路径的写法：在相对路径中通常会用到“./”、“../”,一个是当前目录下，一个是上一级目录下</p>
</li>
</ul>
<h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a><strong>ls指令</strong></h3><ul>
<li>注意：ls列出的结果颜色说明：蓝色表示文件夹，黑色表示文件，绿色表示其权限为拥有所有权限</li>
</ul>
<ol>
<li><p>用法1: # ls</p>
<p> 含义：列出当前工作目录下的所有文件/文件夹的名称</p>
</li>
<li><p>用法2：# ls 路径</p>
<p> 含义：列出指定路径下所有文件/文件夹的名称</p>
</li>
<li><p>用法3：# ls 选项 路径</p>
<p> 含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示</p>
<p> 常见语法：</p>
<p> #ls -l 路径</p>
<p> -l：表示list，以详细的形式进行展示</p>
<p> 文件显示格式：[权限] [用户组] [时间] [文件/文件夹名称]，在Linux中隐藏文档一般都以点开头</p>
<p> #ls -la 路径</p>
<p> -la：表示显示所有的文件/文件夹（包含隐含文件/文件夹）</p>
<p> #ls -lh 路径</p>
<p> -lh：列出指定路径下的所有文件/文件夹的名称，以列表形式并在显示文档大小时以可读性较高的形式显示</p>
</li>
</ol>
<hr>
<h3 id="pwd指令"><a href="#pwd指令" class="headerlink" title="pwd指令"></a><strong>pwd指令</strong></h3><ul>
<li><p>用法：#pwd</p>
</li>
<li><p>含义：打印当前工作目录</p>
</li>
</ul>
<hr>
<h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a><strong>cd指令</strong></h3><ul>
<li><p>用法：#cd 路径</p>
</li>
<li><p>含义：用于切换当前工作目录，在Linux中有一个特殊的符号“~”，输入#cd ~可以直接切换到root目录</p>
</li>
</ul>
<hr>
<h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a><strong>mkdir指令</strong></h3><ol>
<li><p>用法1：#mkdir 路径</p>
<p> 含义：在指定路径下创建目录</p>
</li>
<li><p>用法2：#mkdir -p 路径</p>
<p> 含义：当一次性创建多层不存在的目录时，需添加-p，否则会报错</p>
</li>
<li><p>用法3：#mkdir 路径1 路径2…</p>
<p> 含义：一次性创建多个目录</p>
</li>
</ol>
<hr>
<h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a><strong>touch指令</strong></h3><ol>
<li><p>用法1：#touch 文件路径【路径可以是直接的文件名亦可以是路径】</p>
<p> 含义：在指定的路径下创建文件</p>
</li>
<li><p>用法2：#touch 文件路径1 文件路径2…</p>
<p> 含义：一次性创建多个文件</p>
</li>
</ol>
<hr>
<h3 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a><strong>cp指令</strong></h3><ol>
<li><p>用法1：#cp 被复制的文件 复制的指定路径</p>
<p> 含义：复制文件/文件夹到指定的位置</p>
<p> 注意：Linux在复制的过程中，如果不是必须的建议文件名保持前后一致</p>
</li>
<li><p>用法2：#cp -r 被复制的文件 复制的指定路径</p>
<p> 含义：当使用cp指令进行文件夹复制操作时需要添加选项“-r”,表示递归复制，否则目录将被忽略</p>
</li>
</ol>
<hr>
<h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a><strong>mv指令</strong></h3><ul>
<li><p>用法：#mv 需要移动的文档路径 需要保存的路径</p>
</li>
<li><p>含义：移动文档到新的位置</p>
</li>
<li><p>补充：在Linux中重命名的命令也是mv，语法和移动语法一样：#mv 需要重命名的文件 新的名称</p>
</li>
</ul>
<hr>
<h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a><strong>rm指令</strong></h3><ol>
<li><p>用法3：#rm 需要移除的文档路径</p>
<p> 含义：删除指定路径的文件</p>
</li>
<li><p>用法2：#rm -f 需要移除的文档路径</p>
<p> 含义：-f表示删除时不用提醒需不需要删除，直接强制删除</p>
</li>
<li><p>用法3：#rm -r 需要移除的文档路径</p>
<p> 含义：删除指定路径的文件/文件夹</p>
</li>
<li><p>用法4：#rm -rf 需要移除的文档路径</p>
<p> 含义：删除指定路径的文件/文件夹，并且是强制删除</p>
</li>
<li><p>用法5：#rm -rf 需要移除的文档路径1 需要移除的文档路径2…</p>
<p> 含义：删除多个文件/文件夹</p>
</li>
</ol>
<ul>
<li><p>补充：删除一个目录下有公共特性的文档，即例以相同开头的文档</p>
<p>  使用#rm -f …<em>,</em>号表示通配符，即表示任意字符</p>
</li>
</ul>
<hr>
<h3 id="vim指令"><a href="#vim指令" class="headerlink" title="vim指令"></a><strong>vim指令</strong></h3><ul>
<li><p>用法：#vim 文件路径</p>
</li>
<li><p>含义：打开一个文件（文件可以存在，也可以不存在）并可以进行编辑</p>
</li>
<li><p>vim的退出：按esc，再按：q回车，就可以退出了</p>
</li>
</ul>
<hr>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a><strong>输出重定向</strong></h3><ol>
<li><p>第一个符号 &gt;:覆盖输出，会覆盖原先的文件内容</p>
<p> 用法：#正常执行的指令 &gt; 文件路径</p>
</li>
<li><p>第二个符号 &gt;&gt;:追加输出，在文件内容的末尾追加</p>
<p> 用法：#正常执行的指令 &gt;&gt; 文件路径</p>
</li>
</ol>
<ul>
<li>注意：若文件不存在，则自动新建</li>
</ul>
<hr>
<h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a><strong>cat指令</strong></h3><ol>
<li><p>用法1：#cat 文件路径</p>
<p> 含义：把文件的内容直接打印到终端上</p>
</li>
<li><p>用法2：#cat 待合并的文件路径1 待合并的文件路径2… 待合并的文件路径n &gt; 合并后文件保存的路径</p>
<p> 含义：合并多个文件并把合并后的文件保存到指定目录</p>
</li>
</ol>
<hr>
<p>参考资料：<a href="https://www.bilibili.com/video/av23360560/?p=24" target="_blank" rel="noopener">B站Linux从入门到精通</a></p>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——类型信息</title>
    <url>/2020/08/27/Java%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p><strong>运行时类型信息可以让我们在程序运行时发现和使用类型的信息</strong></p>
<ul>
<li>Java中在运行时识别对象和类的信息主要有两种方式：<ol>
<li>传统的RTTI，它假定我们在编译时已经知道了所有的类型</li>
<li>反射机制，它允许我们在运行时发现和使用类型信息</li>
</ol>
</li>
</ul>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><p>在使用基本的向上转型时，就会使用到RTTI提供的类型转换，例如：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Shape&gt; list = Arrays.asList(<span class="keyword">new</span> Circle(), <span class="keyword">new</span> Square());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在这里，Circle对象和Square对象会向上转型为Shape对象，而这同时也会丢失Shape对象的具体类型。在Java中，所有的类型转换都是在运行时进行正确性检查的，而RTTI的含义就是：在运行时，识别一个对象的类型。</p>
<p>在编码时，就是使用容器和泛型来强制确保这个转换；在运行时，使用RTTI来确保这个转换</p>
<p>但是，RTTI的类型转换并不彻底：它只是将Object转型为Shape，而不是转型为Circle、Square。而后面Shape会执行什么代码就是多态机制的事情了。</p>
</blockquote>
<h3 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h3><ul>
<li><p>要理解RTTI在Java中的工作原理，就必须知道类型信息在运行时是如何表示的，而Class对象就是用来在运行时表示类型信息的，即是用来储存类型信息的。</p>
</li>
<li><p>在Java中，每编写并编译了一个新类，都会产生一个Class对象，而这些Class对象就是通过编译完后所生成的对应的.class文件来创建的，它们是一一对应的，让后JVM就可以使用Class对象来创建我们编写类的对象，在这个过程中将使用被称为”类加载器“的子系统，而将class文件加载到虚拟机的内存，这个过程称为类加载。</p>
</li>
<li><p>创建一个类对象的过程：</p>
<ol>
<li>编写一个新类；</li>
<li>编译生成.class文件；</li>
<li>加载：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象；</li>
<li>链接：验证类中的字节码，为静态域分配空间，解析这个类创建的对其他类的所有引用；</li>
<li>初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态代码块。</li>
</ol>
</li>
</ul>
<h4 id="forName方法"><a href="#forName方法" class="headerlink" title="forName方法"></a>forName方法</h4><ul>
<li>Class.forName(“类的包路径”)可以获取指定类的Class对象，使用该对象就可以获取类中包含信息</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.classinfo;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Candy</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Candy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gum</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Gum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cookie</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading Cookie"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SweetShop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"inside main"</span>);</span><br><span class="line">        <span class="keyword">new</span> Candy();</span><br><span class="line">        System.out.println(<span class="string">"After creating Candy"</span>);</span><br><span class="line"><span class="comment">//        new Gum();</span></span><br><span class="line"><span class="comment">//        System.out.println("After creating Gum");</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用Class.forName("类的包路径")可以获取指定类的Class对象，使用该对象就可以获取类中包含信息</span></span><br><span class="line">            <span class="comment">//在执行forName之前，该类还没被加载，所以，在执行forName时该类会被加载并执行static子句</span></span><br><span class="line">            <span class="keyword">final</span> Class gum = Class.forName(<span class="string">"com.muchlab.classinfo.Gum"</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Couldn't find Gum"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"After Class.forName('Gum')"</span>);</span><br><span class="line">        <span class="keyword">final</span> Cookie cookie = <span class="keyword">new</span> Cookie();</span><br><span class="line">        <span class="comment">//当你有了一个具体类的对象之后，你可以使用getClass方法来获取该对象对应的类对象引用</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Cookie&gt; aClass = cookie.getClass();</span><br><span class="line">        System.out.println(aClass.getSimpleName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"After creating Cookie"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="getxxx"><a href="#getxxx" class="headerlink" title="getxxx"></a>getxxx</h4><ul>
<li>xx.getClass：通过对象来获取该对象类型的Class对象</li>
<li>getName：通过Class对象来获取全限定类名</li>
<li>getSimpleName：通过Class对象来获取不含包名类名</li>
<li>getCanonicalName：通过Class对象来获取全限定类名</li>
<li>getInterfaces：通过Class对象来获取类实现的接口列表</li>
<li>getSuperclass：通过Class对象来获取父类</li>
<li>newInstance：通过Class对象来创建具体类的对象，使用这个方法需要注意的一点是，Class对象所指向的类必须要有一个无参构造器，如不符合条件将会获得一个异常。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.classinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HasBatteries</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Waterproof</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Shoots</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    Toy()&#123;&#125;</span><br><span class="line">    Toy(<span class="keyword">int</span> i)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyToy</span> <span class="keyword">extends</span> <span class="title">Toy</span> <span class="keyword">implements</span> <span class="title">HasBatteries</span>, <span class="title">Waterproof</span>, <span class="title">Shoots</span></span>&#123;</span><br><span class="line">    FancyToy()&#123; <span class="keyword">super</span>(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(Class cc)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class name:"</span> + cc.getName() +</span><br><span class="line">                <span class="string">", is interface? ["</span>+cc.isInterface()+<span class="string">"]"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Simple name:"</span> + cc.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">"Canonical name:"</span> + cc.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c = Class.forName(<span class="string">"com.muchlab.classinfo.FancyToy"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Can't find FancyToy"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printInfo(c);</span><br><span class="line">        <span class="keyword">for</span> (Class anInterface : c.getInterfaces()) &#123;</span><br><span class="line">            printInfo(anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Field field = c.getField(<span class="string">"name"</span>);</span><br><span class="line">            System.out.println(field.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Class superclass = c.getSuperclass();</span><br><span class="line">        Object o = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            o = superclass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Can't instantiate"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Can't access"</span>);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        printInfo(o.getClass());</span><br><span class="line">        <span class="keyword">final</span> Class&lt;FancyToy&gt; fancyToyClass = FancyToy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//类字面常量：基本类型.class等价于其包装类.TYPE</span></span><br><span class="line">        System.out.println(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>==Integer.TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h3><ul>
<li>如果使用forName方法来获取相关类的Class对象，不仅要指定类的全限定类名，而且在编译时不会受到检查，所以可以使用<code>类名.class</code>的方式来获取类的Class对象</li>
<li>当使用<code>.class</code>方式来创建Class对象的引用时，不会自动地初始化该Class对象，初始化将会被延迟到对静态方法获知非常熟静态域进行首次引用时才执行</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.classinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal = <span class="number">47</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> staticFinal2 =</span><br><span class="line">            ClassInitialization.rand.nextInt(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Initializing Initable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable2</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">147</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Initializing Initable2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Initable3</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> staticNonFinal = <span class="number">74</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Initializing Initable3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassInitialization</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//使用.class不会触发Initial的初始化</span></span><br><span class="line">        Class initable = Initable<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        <span class="comment">//Initable.staticFinal为编译期常量，所以这个值不需要对类进行初始化就可以读取</span></span><br><span class="line">        System.out.println(Initable.staticFinal);</span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        <span class="comment">//Initable.staticFinal2不是一个编译期常量，所以这个值需要对类进行初始化才可以读取</span></span><br><span class="line">        <span class="comment">//Random随机数需要在运行后才能确定其值。</span></span><br><span class="line">        System.out.println(Initable.staticFinal2);</span><br><span class="line">        System.out.println(<span class="string">"==========================="</span>);</span><br><span class="line">        <span class="comment">//Initable2.staticNonFinal由于不是一个final常量，所以需要进行链接（分配空间）和初始化</span></span><br><span class="line">        System.out.println(Initable2.staticNonFinal);</span><br><span class="line">        <span class="comment">//如果使用forName则会触发Initial3的初始化</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; initable3 = Class.forName(<span class="string">"com.muchlab.classinfo.Initable3"</span>);</span><br><span class="line">        System.out.println(Initable3.staticNonFinal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="class和-TYPE"><a href="#class和-TYPE" class="headerlink" title=".class和.TYPE"></a>.class和.TYPE</h4><p>对于基本数据类型的包装类，有一个标准字段TYPE，TYPE字段是一个引用，指向对应的基本数据类型的Class对象，即<code>基本类型.class</code>就等价于<code>包装类.TYPE</code></p>
<table>
<thead>
<tr>
<th>基本类型.class</th>
<th>包装类.TYPE</th>
</tr>
</thead>
<tbody><tr>
<td>boolean.class</td>
<td>Boolean.TYPE</td>
</tr>
<tr>
<td>char.class</td>
<td>Character.TYPE</td>
</tr>
<tr>
<td>int.class</td>
<td>Integer.TYPE</td>
</tr>
<tr>
<td>……..</td>
<td>……..</td>
</tr>
</tbody></table>
<h3 id="泛化的Class引用"><a href="#泛化的Class引用" class="headerlink" title="泛化的Class引用"></a>泛化的Class引用</h3><h4 id="Class-lt-extends-xx-gt"><a href="#Class-lt-extends-xx-gt" class="headerlink" title="Class&lt;? extends xx&gt;"></a>Class&lt;? extends xx&gt;</h4><ul>
<li>使用泛化的Class引用主要是对Class引用所指向的对象的确切类型进行限制，如下面代码所示：对Class引用所指向的对象限制为Integer</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.classinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Integer&gt; cc = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(cc.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>但有时我们会觉得这种限制太过严格了。为解决这个问题，我们可以放松一些限制，这时我们就会想使用Integer的父类Number来进行泛化。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Class&lt;Number&gt; cc = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>但这行代码其实会通不过编译，原因是Integer的Class对象并不是Number的Class对象的子类，这时就可以使用通配符来解决这个继承的问题。在Class泛型中的指向类的继承关系是这样表示的：<code>Class&lt;? extends Number&gt; cc = int.class;</code>它代表了继承于Number的某个类的Class对象</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.classinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardClassReferences</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虽然Integer继承了Number类型，但是Integer的Class对象并不是Number Class对象的子类</span></span><br><span class="line"><span class="comment">//        Class&lt;Number&gt; numberClass = int.class;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当你需要指定一个类的声明类型时，又想放松一些限制，使用通配符能满足要求</span></span><br><span class="line">        <span class="comment">//这里的?表示一个非具体的类，这个非具体类继承了Number，所以intclass才能被赋值为</span></span><br><span class="line">        <span class="comment">//int.class和double.class</span></span><br><span class="line">        <span class="comment">//指定一个类的声明类型的好处是：为了提供编译期的类型检查</span></span><br><span class="line">        Class&lt;? extends Number&gt; intclass = <span class="keyword">int</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//由于Double也是继承于Number类的，所以可以使用Double的Class对象为intClass赋值</span></span><br><span class="line">        intclass = <span class="keyword">double</span><span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Class-lt-gt"><a href="#Class-lt-gt" class="headerlink" title="Class&lt;?&gt;"></a>Class&lt;?&gt;</h4><ul>
<li>在编写Class对象时，<code>Class&lt;?&gt;</code>是要优于Class的，即便它们是等价的，<code>Class&lt;?&gt;</code>的好处就是它表示你并非是由于疏忽而忘记写泛型的类型，而是使用了一个非具体的类引用。</li>
</ul>
<h4 id="Class-lt-super-xxx-gt"><a href="#Class-lt-super-xxx-gt" class="headerlink" title="Class&lt;? super xxx&gt;"></a>Class&lt;? super xxx&gt;</h4><ul>
<li>Class&lt;? super xxx&gt;代表的是Class中的泛型为xxx的超类，这里写成Class&lt;超类&gt;并不能起到作用。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.classinfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericToyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        Class&lt;FancyToy&gt; cc = FancyToy<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//? super FancyToy表示Fancy的超类，在这里不能写成Class&lt;Toy&gt;</span></span><br><span class="line">        Class&lt;? <span class="keyword">super</span> FancyToy&gt; superClass = cc.getSuperclass();</span><br><span class="line">        System.out.println(superClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="反射，运行时的类型信息"><a href="#反射，运行时的类型信息" class="headerlink" title="反射，运行时的类型信息"></a>反射，运行时的类型信息</h3><ul>
<li>如果不知道某个对象的确切类型，RTTI可以告诉你，但是有一个限制：这个类型在编译时必须已知，这样RTTI才能识别它，而反射则没有这个限制。</li>
<li>Class类于java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时创建的，用于表示未知类对应的成员。这样就可以使用Constructor来创建对象，用get()和set()来读取和修改Field对象相关联的字段，用invoke()来调用与Method相关联的方法。</li>
<li>getxxx：<ol>
<li>getConstructors()：获取构造器</li>
<li>getFields()：获取成员变量</li>
<li>getMethods()：获取成员方法</li>
</ol>
</li>
</ul>
<h3 id="JDK的动态代理"><a href="#JDK的动态代理" class="headerlink" title="JDK的动态代理"></a>JDK的动态代理</h3><p><img src="https://img-blog.csdnimg.cn/20200530231452777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当调用被代理对象的方法时，调用将会被重定向到该方法中，可以在该方法中添加其他逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理对象的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原始方法的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"=============================Before Invoke=================================="</span>);</span><br><span class="line">        System.out.println(<span class="string">"**** proxy: "</span>+proxy.getClass()+</span><br><span class="line">                <span class="string">", method: "</span>+method+<span class="string">", arg: "</span> + args);</span><br><span class="line">        <span class="keyword">if</span> (args!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">                System.out.println(<span class="string">" "</span> + arg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invoke表示对用法的调用</span></span><br><span class="line">        Object ret = method.invoke(proxied, args);</span><br><span class="line">        System.out.println(<span class="string">"=============================After Invoke=================================="</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">(Interface iface)</span></span>&#123;</span><br><span class="line">        iface.doSomething();</span><br><span class="line">        iface.somethingElse(<span class="string">"bonobo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealObj realObj = <span class="keyword">new</span> RealObj();</span><br><span class="line">        consumer(realObj);</span><br><span class="line">        <span class="comment">//调用静态方法Proxy.newProxyInstance可以创建动态代理，这个方法需要一个类加载器</span></span><br><span class="line">        <span class="comment">//动态代理可以将所有的调用重定向到调用处理器的invoke方法，而这需要向调用处理器的构造器传递实际的对象引用（即被代理的对象）</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 参数1：类加载器</span></span><br><span class="line"><span class="comment">         * 参数2：希望代理实现的接口列表，这希望代理Interface接口</span></span><br><span class="line"><span class="comment">         * 参数3：调用处理器的实现类的实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Interface proxy = (Interface) Proxy.newProxyInstance(</span><br><span class="line">                Interface<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                new Class[]&#123;Interface.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> DynamicProxyHandler(realObj));</span><br><span class="line">        consumer(proxy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>参考资料：Java编程思想</p>
]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——并发1</title>
    <url>/2020/09/05/Java%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%911/</url>
    <content><![CDATA[<h3 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h3><ul>
<li>并发编程使我们可以将程序划分为多个分离的、独立运行的任务。通过多线程的机制，这些独立的任务（子任务）中的每一个都将由执行线程来驱动，一个线程就是在进程中的一个单一的顺序控制流，单个进程可以拥有多个并发执行的任务，其底层机制就是CPU的时分复用技术。</li>
</ul>
<h3 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h3><ul>
<li>要想定义任务，你可以实现<code>Runnable</code>接口，该接口有一个<code>run()</code>方法，通过实现该方法可以使该任务执行你的命令，下面是一个小例子</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiftOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> countDown = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> taskCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = taskCount++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">status</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + id + <span class="string">"("</span> + (countDown &gt; <span class="number">0</span> ? countDown : <span class="string">"LiftOff"</span>) + <span class="string">")."</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(countDown-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(status());</span><br><span class="line">            <span class="comment">//Thread.yield()是对线程调度器的一种使用方式，可以将CPU从一个线程转移到另一个线程</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LiftOff liftOff = <span class="keyword">new</span> LiftOff();</span><br><span class="line">        liftOff.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><ul>
<li>将<code>Runnable</code>对象转变成工作任务的传统方式是把它提交给一个<code>Thread</code>构造器，然后使用<code>Thread</code>对象来驱动<code>Runnable</code>对象，下面是一个小例子：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将Runnable对象转变为工作任务的传统方式就是把它交给一个Thread构造器，使用Thread来驱动LiftOff对象</span></span><br><span class="line">        <span class="comment">//这时，创建了一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在Thread调用start前必须对线程进行初始化，然后start会触发Runnable对象中的run方法</span></span><br><span class="line"><span class="comment">         * 这成为该新线程启动了该任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sout语句是在main线程中执行的，而Runnable对象的任务是在thread线程中进行的，</span></span><br><span class="line"><span class="comment">         * 它们两个互不干扰，在thread线程的任务完成前，main线程中的其他操作也会被并发执行，</span></span><br><span class="line"><span class="comment">         * 所以可以看到sout的输出并不是在任务输出的下面</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Thread来驱动更多的任务</span></span><br><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreBasicThreads</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//不同的任务执行在线程被换进换出时混在了一起，这种交换是由线程调度器自动控制的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> LiftOff()).start();</span><br><span class="line">            System.out.println(<span class="string">"Waiting for LiftOff"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>多个任务的执行输出说明不同任务的执行在线程被换进换出时混在了一起，这种交换是由线程调度器自动控制的，如果你的机器有多个处理器，线程调度器或在这些处理器之间默默地分发线程。所以程序的运行结果是不确定的。</li>
</ul>
<h3 id="使用Executor（执行器）"><a href="#使用Executor（执行器）" class="headerlink" title="使用Executor（执行器）"></a>使用Executor（执行器）</h3><ul>
<li>使用<code>Executor</code>可以管理你的<code>Thread</code>对象，从而简化并发编程。它的原理是<code>Executor</code>在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同，任务将由<code>Executor</code>这个中介对象来执行。它允许你管理异步任务的执行，而无须显式地管理线程的生命周期，所以，推荐使用<code>Executor</code>来执行任务。</li>
<li>执行器可以创建线程池来管理线程执行任务，下面的例子使用了<code>newCachedThreadPool()</code>方法来创建一个线程池，该线程池会为每个任务提供一个线程。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Executor在客户端和任务执行之间提供了一个间接层，这样你就可以使用中介的Executor来执行任务</span></span><br><span class="line"><span class="comment">         * 它允许你管理异步任务的执行，无须显式地管理线程的生命周期，所以，推荐使用Executor来启动任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//提交并执行任务</span></span><br><span class="line">            exec.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止新的任务提交给exec执行器</span></span><br><span class="line">        <span class="comment">//main线程会在shutdown被调用之前继续运行之前提交的所有任务</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><ul>
<li>你可以很容易地将前面示例中的<code>CachedThreadPool</code>替换为不同类型的<code>Executor</code>，<code>FixedThreadPool</code>使用了有限的线程集来执行所提交的任务。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建有限的线程池，这里限制了线程池中线程的个数为5，即不用为每个任务都固定地付出创建线程地开销</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//        final ExecutorService executorService1 = Executors.newSingleThreadExecutor();</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="SingleThreadPool"><a href="#SingleThreadPool" class="headerlink" title="SingleThreadPool"></a>SingleThreadPool</h4><ul>
<li><code>SingleThreadExecutor</code>就是线程数为1的<code>FixedThreadPool</code>,每个任务都会在下一个任务开始之前运行结束，即所有任务将使用相同的线程。若提交了多个任务，那这些任务将会排队。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用newSingleThreadExecutor方法可以创建SingleThreadExecutor</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> LiftOff());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>SingleThreadExecutor</code>对于在另一个线程中连续运行的任何事务来说，都是很有用的，比如监听进入的套接字连接任务。对于希望在线程中运行的段任务也是很有用的，比如，更新本地或者远程日志的小人物，或事件分发线程。</li>
</ul>
<h3 id="Callable接口：从任务中产生返回值"><a href="#Callable接口：从任务中产生返回值" class="headerlink" title="Callable接口：从任务中产生返回值"></a>Callable接口：从任务中产生返回值</h3><ul>
<li>如果你希望任务在完成时能够返回一个值，则你可以实现<code>Callable</code>接口而不是<code>Runnable</code>接口，它需要实现一个<code>call()</code>方法，这个方法其实就是<code>run()</code>方法加上返回值，并且必须使用<code>ExecutorService.submit()</code>方法来调用它，下面是一个小例子：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runnable接口只是执行工作的独立任务，但它不返回任何值，</span></span><br><span class="line"><span class="comment"> * Callable跟Runnable一样也是用来定义任务的，但不同的是它能够在任务完成时返回一个值</span></span><br><span class="line"><span class="comment"> * 在Callable接口中需要实现的时call方法，并且必须使用ExecutorService.submit()方法来调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskWithResult</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TaskWithResult</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Result From TaskWithResult"</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Future&lt;String&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//submit方法返回一个Future类型的结果，该结果表示异步操作后的返回结果，可以使用isDone来查询Futurn是否已经完成</span></span><br><span class="line">            results.add(executorService.submit(<span class="keyword">new</span> TaskWithResult(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;String&gt; result : results) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用get可以获取异步结果中的确切结果</span></span><br><span class="line">                System.out.println(result.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                executorService.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="休眠和优先级"><a href="#休眠和优先级" class="headerlink" title="休眠和优先级"></a>休眠和优先级</h3><h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><ul>
<li>影响任务行为的一种简单方法是调用Thread的<code>sleep()</code>方法，<code>JavaSE5</code>引进了更加显式的<code>sleep()</code>版本，使用<code>TimeUnit</code>类，能够指定<code>sleep()</code>延迟的事件单元，可以提高代码的可读性，另外，<code>TimeUnit</code>还可以被用来执行转换。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepingTask</span> <span class="keyword">extends</span> <span class="title">LiftOff</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(countDown--&gt;<span class="number">0</span>)</span><br><span class="line">                System.out.println(status());</span><br><span class="line">            <span class="comment">//指定延迟时间单元为微秒</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li>CPU处理现有的线程集的顺序是不确定的，但调度器会倾向于让优先权高的线程先执行。然而，这并不意味着优先权低的线程得不到执行（若一直执行优先权高的，会导致<code>饥饿现象</code>）。优先权低的线程仅仅是执行的频率比较低。</li>
<li>我们可以调用Thread对象中的<code>getPriority()</code>和<code>setPriority()</code>两个方法来获取和设置线程的优先级</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePriorities</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//volatile表示不会使用该变量进行运算不会进行任何编译器优化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePriorities</span><span class="params">(<span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里分别打印了线程名、优先级、线程组名：countDown的值</span></span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread() + <span class="string">": "</span> + countDown;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().setPriority(priority);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//执行了开销相当大的浮点运算，目的是观察优先级的效果</span></span><br><span class="line">            <span class="comment">//若没有这些运算，在main线程中优先级低的比较先被执行，将会看不到不同优先级抢占CPU的效果</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                d += (Math.PI + Math.E)/(<span class="keyword">double</span>)i;</span><br><span class="line">                <span class="keyword">if</span>(i%<span class="number">1000</span> ==<span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//当调用切换时，CPU会有很大概率被切换到优先级高的线程</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MIN_PRIORITY));</span><br><span class="line">        &#125;</span><br><span class="line">        exec.execute(<span class="keyword">new</span> SimplePriorities(Thread.MAX_PRIORITY));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><ul>
<li>所谓后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程不必属于程序。当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程，main线程就是一个非后台线程</li>
<li>后台线程区别于普通线程，普通线程又可以称为用户线程，只完成用户自己想要完成的任务，不提供公共服务。而有时，我们希望编写一段程序，能够提供公共的服务，保证所有用户针对该线程的请求都能有响应。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过编写线程工厂可以定制由Executor创建的线程属性：优先级、后、名称</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DaemonFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonFromFactory</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">" "</span>+<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//向线程池传入工厂对象可以使执行器在执行任务时执行工厂类中的初始化信息。</span></span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool(<span class="keyword">new</span> DaemonFactory());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> DaemonFromFactory());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"All daemons started"</span>);</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="继承Thread类来定义任务"><a href="#继承Thread类来定义任务" class="headerlink" title="继承Thread类来定义任务"></a>继承Thread类来定义任务</h3><ul>
<li>除了实现<code>Runnable</code>接口来定义任务外，也可以继承<code>Thread</code>类来定义任务，这两种方式可以说完全一致的，但一般情况下，推荐实现<code>Runnable</code>接口来定义任务，因为<code>Runnable</code>可以继承其他的类，而<code>Thread</code>则不行。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.concurrence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"thread"</span> + ++threadCount);</span><br><span class="line">        <span class="comment">//启动任务</span></span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SimpleThread&#123;"</span> +getName()+</span><br><span class="line">                <span class="string">", countDown="</span> + countDown +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span>(--countDown==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> SimpleThread simpleThread = <span class="keyword">new</span> SimpleThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络命令</title>
    <url>/2019/09/09/Linux%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="write指令"><a href="#write指令" class="headerlink" title="write指令"></a>write指令</h3><ul>
<li><p>用法：#write 用户名 发送的内容（可以按ctrl+D退出）</p>
</li>
<li><p>含义：给指定的用户发信息</p>
</li>
</ul>
<hr>
<h3 id="wall指令"><a href="#wall指令" class="headerlink" title="wall指令"></a>wall指令</h3><ul>
<li><p>用法：#wall 发送的内容</p>
</li>
<li><p>含义：给所有登录在服务器的用户发送相同的信息</p>
</li>
</ul>
<hr>
<h3 id="ping指令"><a href="#ping指令" class="headerlink" title="ping指令"></a>ping指令</h3><ul>
<li><p>用法：#ping IP地址</p>
</li>
<li><p>含义</p>
</li>
</ul>
<hr>
<h3 id="ifconfig指令"><a href="#ifconfig指令" class="headerlink" title="ifconfig指令"></a>ifconfig指令</h3><ol>
<li><p>用法1：#ifconfig</p>
<p> 含义：查看网卡信息</p>
</li>
<li><p>用法2：#ifconfig 网卡名称 IP地址</p>
<p> 含义：设置网卡的IP地址</p>
</li>
</ol>
<h3 id="mail指令"><a href="#mail指令" class="headerlink" title="mail指令"></a>mail指令</h3><ul>
<li><p>发送邮件：#mail 用户名</p>
</li>
<li><p>查看邮件：#mail</p>
</li>
</ul>
<h3 id="last指令"><a href="#last指令" class="headerlink" title="last指令"></a>last指令</h3><ul>
<li><p>用法：#last</p>
</li>
<li><p>含义：列出目前和过去登入系统的用户信息</p>
</li>
</ul>
<h3 id="lastlog指令"><a href="#lastlog指令" class="headerlink" title="lastlog指令"></a>lastlog指令</h3><ul>
<li><p>用法：#lastlogin</p>
</li>
<li><p>含义：列出过去登入系统的用户名和登入时间</p>
</li>
</ul>
<hr>
<h3 id="traceroute指令"><a href="#traceroute指令" class="headerlink" title="traceroute指令"></a>traceroute指令</h3><ul>
<li><p>用法：#traceroute 网址</p>
</li>
<li><p>含义：显示数据包到主机间的路径</p>
</li>
</ul>
<hr>
<h3 id="setup指令"><a href="#setup指令" class="headerlink" title="setup指令"></a>setup指令</h3><ul>
<li><p>用法：#setup</p>
</li>
<li><p>含义：配置网络等信息</p>
</li>
</ul>
<hr>
<h3 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a>netstat指令</h3><ol>
<li><p>用法1：#netstat -tlun</p>
<p> 含义：查看本机监听的端口</p>
</li>
<li><p>用法2：#netstat -an</p>
<p> 含义：查看本机所有的网络连接</p>
</li>
<li><p>用法3：#netstat -rn</p>
<p> 含义：查看本机路由表</p>
</li>
</ol>
<hr>
<h3 id="mount指令和umount指令"><a href="#mount指令和umount指令" class="headerlink" title="mount指令和umount指令"></a>mount指令和umount指令</h3><ul>
<li><p>#mount (-t文件系统) 设备文件名 挂载点：用来将设备文件和某个挂载点挂载到一起，设备文件名一般默认为/dev/sr0，挂载点可以在mnt目录下。</p>
</li>
<li><p>#umount 设备文件名：卸除目前挂在某一挂载点中的文件系统，在这文件系统在/dev/sr0中</p>
</li>
</ul>
<hr>
<p>参考资料：<a href="https://www.bilibili.com/video/av18156598/?p=23" target="_blank" rel="noopener">b站</a></p>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB基础知识及使用</title>
    <url>/2020/07/10/MongoDB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="MongoDB是什么"><a href="#MongoDB是什么" class="headerlink" title="MongoDB是什么"></a>MongoDB是什么</h3><ul>
<li><p>MongoDB 是一个基于分布式文件存储的数据库。由<a href="https://www.w3cschool.cn/cpp/" target="_blank" rel="noopener">C++</a>语言编写。旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p>
<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p>
</li>
</ul>
<h3 id="MongoDB的特点——高性能、易部署、易使用"><a href="#MongoDB的特点——高性能、易部署、易使用" class="headerlink" title="MongoDB的特点——高性能、易部署、易使用"></a>MongoDB的特点——高性能、易部署、易使用</h3><ul>
<li><p>面向集合存储，易存储对象类型的数据。</p>
</li>
<li><p>模式自由。</p>
</li>
<li><p>支持动态查询。</p>
</li>
<li><p>支持完全索引，包含内部对象。</p>
</li>
<li><p>支持查询。</p>
</li>
<li><p>支持复制和故障恢复。</p>
</li>
<li><p>使用高效的二进制数据存储，包括大型对象（如视频等）。</p>
</li>
<li><p>自动处理碎片，以支持云计算层次的扩展性</p>
</li>
<li><p>支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。</p>
</li>
<li><p>文件存储格式为BSON（一种JSON的扩展）。</p>
</li>
<li><p>可通过网络访问。</p>
</li>
</ul>
<h3 id="MongoDB适用场景"><a href="#MongoDB适用场景" class="headerlink" title="MongoDB适用场景"></a>MongoDB适用场景</h3><p>MongoDB 的主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS 系统（具有丰富的功能）之间架起</p>
<p><strong>Mongo 适用于以下场景:</strong></p>
<ul>
<li><p>网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</p>
</li>
<li><p>缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo 搭建的持久化缓存层可以避免下层的数据源过载。</p>
</li>
<li><p>大尺寸、低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。</p>
</li>
<li><p>高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库，Mongo 的路线图中已经包含对MapReduce 引擎的内置支持。</p>
</li>
<li><p>用于对象及JSON 数据的存储：Mongo 的BSON 数据格式非常适合文档化格式的存储及查询。</p>
</li>
</ul>
<p><strong>MongoDB 的使用也会有一些限制，例如，它不适合于以下几个地方。</strong></p>
<ul>
<li><p>高度事务性的系统：例如，银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。</p>
</li>
<li><p>传统的商业智能应用：针对特定问题的BI 数据库会产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。</p>
</li>
<li><p>需要SQL 的问题。</p>
</li>
</ul>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol>
<li>MongoDB中的 <code>database</code> 有着和你熟知的”数据库”一样的概念 (对 Oracle 来说就是 schema)。一个 MongoDB 实例中，可以有零个或多个数据库，每个都作为一个高等容器，用于存储数据。</li>
<li>数据库中可以有零个或多个 <code>collections</code> (集合)。集合和传统意义上的 <code>table</code> 基本一致，你可以简单的把两者看成是一样的东西。</li>
<li>集合是由零个或多个 <code>documents</code> (文档)组成。同样，一个文档可以看成是一 <code>row</code>。</li>
<li>文档是由零个或多个 <code>fields</code> (字段)组成。, 没错，它就是 <code>columns</code>。</li>
<li><code>Indexes</code> (索引)在 MongoDB 中扮演着和它们在 RDBMS 中一样的角色。</li>
<li><code>Cursors</code> (游标)和上面的五个概念都不一样，但是它非常重要，并且经常被忽视，因此我觉得它们值得单独讨论一下。其中最重要的你要理解的一点是，游标是，当你问 MongoDB 拿数据的时候，它会给你返回一个结果集的指针而不是真正的数据，这个指针我们叫它游标，我们可以拿游标做我们想做的任何事情，比如说计数或者跨行之类的，而无需把真正的数据拖下来，在真正的数据上操作。</li>
</ol>
<p>这些术语并不是与传统的关系型数据库完全一致，它最大的区别在于关系型数据库是在 <code>table</code> 上定义的<code>columns</code>，而面向文档数据库是在 <code>document</code> 上定义的 <code>fields</code>。也就是说，在 <code>collection</code> 中的每个 <code>document</code> 都可以有它自己独立的 <code>fields</code>。因此，对于 <code>collection</code> 来说是个简化了的 <code>table</code> ，但是一个 <code>document</code> 却比一 <code>row</code> 有更多的信息。</p>
<h3 id="创建database和user"><a href="#创建database和user" class="headerlink" title="创建database和user"></a>创建database和user</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">//当使用<span class="keyword">use</span>后，如果数据库不存在，mongodb会默认地创建数据库，并把当前数据库转换成指定的数据库</span><br><span class="line"><span class="keyword">use</span> springbucks</span><br><span class="line">//为数据库springbucks创建一个<span class="keyword">user</span>，<span class="keyword">roles</span>表示该<span class="keyword">user</span>属于哪些角色，这里的readWrite表示该<span class="keyword">user</span>有读写权限</span><br><span class="line">db.createUser(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">user</span>:<span class="string">"springbucks"</span>,</span><br><span class="line">		pwd:<span class="string">"springbucks"</span>,</span><br><span class="line">		<span class="keyword">roles</span>:[</span><br><span class="line">			&#123;<span class="keyword">role</span>:<span class="string">"readWrite"</span>, db:<span class="string">"springbucks"</span>&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>其中user的文档格式如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DTS"><figure class="iseeu highlight /dts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="symbol">  user:</span> <span class="string">"&lt;name&gt;"</span>,	<span class="comment">//用户名</span></span><br><span class="line"><span class="symbol">  pwd:</span> <span class="string">"&lt;cleartext password&gt;"</span>,	<span class="comment">//用户密码</span></span><br><span class="line"><span class="symbol">  customData:</span> &#123; <span class="params">&lt;any information&gt;</span> &#125;,	<span class="comment">//备注信息，可选</span></span><br><span class="line"><span class="symbol">  roles:</span> [</span><br><span class="line">    &#123; role: <span class="string">"&lt;role&gt;"</span>, db: <span class="string">"&lt;database&gt;"</span> &#125; | <span class="string">"&lt;role&gt;"</span>,</span><br><span class="line">    ...</span><br><span class="line">  ],	<span class="comment">//角色数组，授权给此用户的角色，[]表示无角色</span></span><br><span class="line"><span class="symbol">  authenticationRestrictions:</span> [</span><br><span class="line">     &#123;</span><br><span class="line"><span class="symbol">       clientSource:</span> [<span class="string">"&lt;IP&gt;"</span> | <span class="string">"&lt;CIDR range&gt;"</span>, ...]</span><br><span class="line"><span class="symbol">       serverAddress:</span> [<span class="string">"&lt;IP&gt;"</span> | <span class="string">"&lt;CIDR range&gt;"</span>, ...]</span><br><span class="line">     &#125;,</span><br><span class="line">     ...</span><br><span class="line">  ],	<span class="comment">//限制数组，可选</span></span><br><span class="line"><span class="symbol">  mechanisms:</span> [ <span class="string">"&lt;SCRAM-SHA-1|SCRAM-SHA-256&gt;"</span>, ... ],		<span class="comment">//指定用于创建SCRAM用户凭据的特定SCRAM机制，可选。3.6默认SCRAM-SHA-1</span></span><br><span class="line"><span class="symbol">  passwordDigestor:</span> <span class="string">"&lt;server|client&gt;"</span></span><br><span class="line">&#125;	<span class="comment">//密码摘要，可选，指定用户端/服务器是否生成密码摘要</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>权限说明具体角色：<ul>
<li>Read：允许用户读取指定数据库</li>
<li>readWrite：允许用户读写指定数据库</li>
<li>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</li>
<li>userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</li>
<li>clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</li>
<li>readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</li>
<li>readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</li>
<li>userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</li>
<li>dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</li>
<li>root：只在admin数据库中可用。超级账号，超级权限。</li>
</ul>
</li>
</ul>
<h3 id="自定义角色"><a href="#自定义角色" class="headerlink" title="自定义角色"></a>自定义角色</h3><p>创建角色<code>createRole(&lt;document&gt;);</code></p>
<p>其中role的文档格式如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CLOJURE"><figure class="iseeu highlight /clojure"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  role: <span class="string">"&lt;name&gt;"</span>,	//角色名</span><br><span class="line">  privileges: [</span><br><span class="line">     &#123; resource: &#123; &lt;resource&gt; &#125;, actions: [ <span class="string">"&lt;action&gt;"</span>, ... ] &#125;,</span><br><span class="line">     ...</span><br><span class="line">  ],	//权限数组，包括资源和权限操作 (详见附件)</span><br><span class="line">  roles: [</span><br><span class="line">     &#123; role: <span class="string">"&lt;role&gt;"</span>, db: <span class="string">"&lt;database&gt;"</span> &#125; | <span class="string">"&lt;role&gt;"</span>,</span><br><span class="line">      ...</span><br><span class="line">  ],	//父类角色数组，对于该数据库角色可直接用role字符串表示</span><br><span class="line">  authenticationRestrictions: [</span><br><span class="line">    &#123;</span><br><span class="line">      clientSource: [<span class="string">"&lt;IP&gt;"</span> | <span class="string">"&lt;CIDR range&gt;"</span>, ...],</span><br><span class="line">      serverAddress: [<span class="string">"&lt;IP&gt;"</span> | <span class="string">"&lt;CIDR range&gt;"</span>, ...]</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]		//认证限制数组，可选，确定一组可连接IP地址、CIDR范围</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注：</p>
<ul>
<li>若一个角色继承多个限制不同的角色，如IP不同，则用户不可认证</li>
<li>如果角色不是在admin数据库中创建的，则该用户只能设置此数据库下的权限且只能继承此数据库下角色</li>
<li>创建角色必须有该数据库的createRole action和grantRole action，要设置新角色的authenticationRestrictions，还必须拥有此数据库的 setAuthenticationRestriction action权限</li>
<li>resource格式分三类，Database and/or Collection Resource, Cluster Resource 以及 anyResource</li>
</ul>
]]></content>
      <categories>
        <category>-MongoDb</category>
      </categories>
      <tags>
        <tag>-MongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进阶指令</title>
    <url>/2019/09/02/Linux%E8%BF%9B%E9%98%B6%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="df指令"><a href="#df指令" class="headerlink" title="df指令"></a><strong>df指令</strong></h3><ul>
<li><p>用法：#df -h</p>
</li>
<li><p>含义：展示磁盘大小，-h表示以可读性较高的形式展示</p>
</li>
</ul>
<hr>
<h3 id="free指令"><a href="#free指令" class="headerlink" title="free指令"></a><strong>free指令</strong></h3><ul>
<li><p>用法：#free -h</p>
</li>
<li><p>含义：展示内存使用情况，-h表示以可读性较高的形式展示</p>
</li>
<li><p>补充：free和df指令都可以在后面加-m、-g，表示以Mb或Gb为单位的形式展示</p>
<p>  Mem 行(第二行)是内存的使用情况。</p>
<p>  Swap 行(第三行)是交换空间的使用情况。</p>
<p>  total 列显示系统总的可用物理内存和交换空间大小。</p>
<p>  used 列显示已经被使用的物理内存和交换空间。</p>
<p>  free 列显示还有多少物理内存和交换空间可用使用。</p>
<p>  shared 列显示被共享使用的物理内存大小。</p>
<p>  buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。</p>
<p>  available 列显示还可以被应用程序使用的物理内存大小。</p>
</li>
</ul>
<hr>
<h3 id="head指令"><a href="#head指令" class="headerlink" title="head指令"></a><strong>head指令</strong></h3><ul>
<li><p>用法：#head -n 文件路径，n表示数字</p>
</li>
<li><p>含义：展示一个文件的前n行，如果不指定n，则默认显示前10行</p>
</li>
</ul>
<hr>
<h3 id="tail指令"><a href="#tail指令" class="headerlink" title="tail指令"></a><strong>tail指令</strong></h3><ol>
<li><p>用法：#tail -n 文件路径，n表示数字</p>
<p> 含义：展示一个文件的末n行，如果不指定n，则默认显示前10行</p>
</li>
<li><p>用法2：tail -f 文件路径</p>
<p> 含义：-f表示展示一个文件的动态变化内容（变化的内容不能是用户手动增加的），这个指令一般用来查看日志</p>
</li>
</ol>
<hr>
<h3 id="less指令"><a href="#less指令" class="headerlink" title="less指令"></a><strong>less指令</strong></h3><ul>
<li><p>用法：#less 需要查看的文件路径</p>
</li>
<li><p>含义：查看文件，以较少的内容进行输出，按下辅助功能键（回车键、上下方向键按行翻看，空格键按页翻看）查看更多</p>
</li>
</ul>
<hr>
<h3 id="wc指令"><a href="#wc指令" class="headerlink" title="wc指令"></a><strong>wc指令</strong></h3><ul>
<li><p>用法：#wc -lwc 需要统计的文件路径</p>
</li>
<li><p>含义：统计文件内容信息（行数、单词数、字节数）</p>
</li>
<li><p>注意：-l表示lines，行数</p>
<p>  -w表示words，单词数,按空格去区分单词个数</p>
<p>  -c表示bytes，字节数</p>
</li>
</ul>
<hr>
<h3 id="date指令"><a href="#date指令" class="headerlink" title="date指令"></a><strong>date指令</strong></h3><ol>
<li><p>用法：#date</p>
<p> 含义：可以展示时间日期（也可以读取、设置）</p>
</li>
<li><p>用法2：#date +%F（相当于”+%y-%m-%d”）</p>
<p> 含义：+%F表示输出形式：XXXX-XX-XX</p>
</li>
<li><p>用法3：#date +%F %T（相当于”+%y-%m-%d %H:%M:%S”）</p>
<p> 含义：+%F%T表示输出形式：XXXX-XX-XX XX：XX：XX</p>
</li>
<li><p>用法4：#date -d “+/-n year/month/day” “+%F %T”</p>
<p> 含义：获取之前或之后的时间</p>
</li>
</ol>
<ul>
<li><p>补充：%F:表示完整的年月日</p>
<p>  %T:表示完整的时分秒</p>
<p>  %Y:表示四位年份</p>
<p>  %m:表示两位月份</p>
<p>  %d:表示日期</p>
<p>  %D:表示月日年</p>
<p>  %H:表示小时（带前导0）</p>
<p>  %M:表示分钟（带前导0）</p>
<p>  %S:表示秒数（带前导0）</p>
</li>
</ul>
<hr>
<h3 id="cal指令"><a href="#cal指令" class="headerlink" title="cal指令"></a><strong>cal指令</strong></h3><ol>
<li><p>用法1：#cal -m/s（-1）</p>
<p> 含义：输出当前月份的日历，-m或-s表示每月以Monday开头或以Sunday开头</p>
</li>
<li><p>用法2：#cal -3</p>
<p> 含义：输出上月+本月+下月的日历</p>
</li>
<li><p>用法3：#cal -y n（n表示年份）</p>
<p> 含义：输出某一年的日历</p>
</li>
</ol>
<hr>
<h3 id="clear或ctrl-l指令"><a href="#clear或ctrl-l指令" class="headerlink" title="clear或ctrl+l指令"></a><strong>clear或ctrl+l指令</strong></h3><ul>
<li><p>用法：#clear</p>
</li>
<li><p>含义：清除终端中已存在的命令和结果</p>
</li>
</ul>
<hr>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a><strong>管道</strong></h3><ul>
<li><p>管道符：|</p>
</li>
<li><p>作用：管道一般可以用于“过滤”、“特殊用法”、“扩展处理”,管道一般要结合以前的指令一起使用，其作用主要是辅助作用。</p>
</li>
</ul>
<ol>
<li><p>过滤</p>
<p> 用法：输出指令 文件路径|grep 字符串</p>
<p> 含义：通过管道展示出指定文件路径下包含某一字符串的文档名称</p>
<p> 例：ls /|grep y 展示根目录下包含字符y的文档名称</p>
</li>
<li><p>扩展处理</p>
<p> 用法：输出指令 文件路径|指令 [选项]</p>
<p> 含义：统计指定路径下文档的个数</p>
<p> 例：ls /|wc -l 统计根目录下文档的个数</p>
</li>
</ol>
<ul>
<li>补充：以管道作为分界线，前面的指令用于输入管道，然后经过管道处理后再进行输出，处理的标准按后面指令来确定。</li>
</ul>
<hr>
<p>参考资料：<a href="https://www.bilibili.com/video/av23360560/?p=24" target="_blank" rel="noopener">B站Linux从入门到精通</a></p>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux高级指令</title>
    <url>/2019/09/03/Linux%E9%AB%98%E7%BA%A7%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>常用的通配符有：</p>
<p>  “*”:匹配任意字符串</p>
<p>  “?”:匹配任意一个字符</p>
<p>  “[]”:匹配[]列表中的任一字符</p>
<p>  “^”:不匹配^后面的字符</p>
</li>
<li><p>例：cp <em>.c[a-z]</em>.h ~/xxx</p>
</li>
</ul>
<hr>
<h3 id="hostname指令"><a href="#hostname指令" class="headerlink" title="hostname指令"></a><strong>hostname指令</strong></h3><ul>
<li>操作服务器的主机名（读取、设置）</li>
</ul>
<ol>
<li><p>用法1：#hostname</p>
<p> 含义：表示输出完整的主机名</p>
</li>
<li><p>用法2：#hostname -f</p>
<p> 含义：-f表示输出当前主机名中的FQDN（全限定域名）</p>
</li>
</ol>
<hr>
<h3 id="id指令"><a href="#id指令" class="headerlink" title="id指令"></a><strong>id指令</strong></h3><ul>
<li>用来查看一个用户的一些基本信息（包含用户id，用户组id，附加组id…）,该指令如果不指定用户则默认当前用户</li>
</ul>
<ol>
<li><p>用法1：#id</p>
<p> 含义：展示当前执行该命令的用户基本信息</p>
</li>
<li><p>用法2：#id 用户名</p>
<p> 含义：展示指定用户的基本信息</p>
</li>
</ol>
<ul>
<li><p>验证用户信息是否正确：可以通过查看文件/etc/passwd来验证</p>
<p>  验证用户组信息是否正确：可以通过查看文件/etc/group来验证</p>
</li>
</ul>
<hr>
<h3 id="whoami指令"><a href="#whoami指令" class="headerlink" title="whoami指令"></a><strong>whoami指令</strong></h3><ul>
<li><p>用法：#whoami</p>
</li>
<li><p>含义：查看当前登录的用户名</p>
</li>
</ul>
<hr>
<h3 id="ps指令"><a href="#ps指令" class="headerlink" title="ps指令"></a><strong>ps指令</strong></h3><ol>
<li><p>用法1：#ps</p>
<p> 含义：用来查看服务器的进程信息</p>
</li>
<li><p>用法2：#ps -e</p>
<p> 含义：-e表示列出全部的进程</p>
</li>
<li><p>用法3：#ps -f</p>
<p> 含义：-f表示显示全部的列（显示全字段）</p>
</li>
<li><p>用法4（很常用）：#ps -ef |grep 进程名称</p>
<p> 含义：找出指定进程名称的进程</p>
</li>
</ol>
<ul>
<li><p>补充：在使用时一般用#ps -ef</p>
<p>  列的含义：</p>
<p>  UID：该进程执行的用户id</p>
<p>  PID：进程id</p>
<p>  PPID：该进程的父级id</p>
<p>  C：Cpu的占用率，其形式是百分数</p>
<p>  STIME：进行的启动时间</p>
<p>  TTY：终端设备，发起该进程的设备识别符号（？表示不是从终端执行的）</p>
<p>  TIME：进程的执行时间</p>
<p>  CMD：该进程的名称或者对应的路径</p>
</li>
</ul>
<hr>
<h3 id="top指令"><a href="#top指令" class="headerlink" title="top指令"></a><strong>top指令</strong></h3><ul>
<li><p>用法：进入命令：#top</p>
<p>  退出命令：q键</p>
</li>
<li><p>含义：查看服务器的进程资源</p>
</li>
<li><p>补充：</p>
<p>  表头含义：</p>
<p>  PID：进程id</p>
<p>  USER：该进程对应的用户</p>
<p>  PR：进程的优先级</p>
<p>  VIRT：虚拟内存</p>
<p>  RES：常驻内存</p>
<p>  SHR：共享内存</p>
<p>  计算一个进程实际使用的内存 = 常驻内存（RES） - 共享内存（SHR）</p>
<p>  <font color="#FF0000">S：表示进行的状态（S:Sleeping，R：Running）</font></p>
<p>  %CPU：CPU的占用百分比</p>
<p>  %MEM：内存的占用百分比</p>
<p>  TIME+：执行时间</p>
<p>  <font color="#FF0000">COMMAND：进程的名称或者路径</font></p>
<p>  在运行top的时候，可以按下方便的快捷键：</p>
<p>  M：表示将结果按照内存（MEM）从高到低进行降序排列</p>
<p>  P:表示将结果按照CPU使用率从高到低进行降序排序</p>
<p>  1：当服务器有多个cpu时可以使用”1”快捷键来切换是否展示各个cpu的详细信息</p>
</li>
</ul>
<hr>
<h3 id="du指令"><a href="#du指令" class="headerlink" title="du指令"></a><strong>du指令</strong></h3><ul>
<li><p>查看目录的真实大小</p>
</li>
<li><p>用法：#du -sh 目录路径</p>
</li>
<li><p>选项含义：</p>
<p>  -s:表示只显示汇总的大小</p>
<p>  -h:表示以高可读性的形式显示</p>
</li>
</ul>
<hr>
<h3 id="find指令"><a href="#find指令" class="headerlink" title="find指令"></a><strong>find指令</strong></h3><ul>
<li><p>用法：#find 路径范围 选项 选项的值</p>
</li>
<li><p>含义：用于查找文件（参数较多）</p>
</li>
<li><p>选项：</p>
<p>  -name：按照文档名称进行搜索，选项的值就是文档名称的关键字</p>
<p>  -type：按照文档的类型进行搜索（选项的值：”f”表示文件，”d”表示文件夹）</p>
</li>
<li><p><font color="#FF0000">查找某目录下符合某标准的文件的个数：#find 路径 -name/-type 选项的值 |wc -l</font></p>
</li>
</ul>
<hr>
<h3 id="service指令"><a href="#service指令" class="headerlink" title="service指令"></a><strong>service指令</strong></h3><ul>
<li>用于控制一些软件的服务启动/停止/重启</li>
</ul>
<ol>
<li><p>用法1：#service 服务名 start</p>
<p> 含义：服务器启动</p>
</li>
<li><p>用法2：#service 服务名 stop</p>
<p> 含义：服务器停止</p>
</li>
<li><p>用法3：#service 服务名 restart</p>
<p> 含义：服务器重启</p>
</li>
</ol>
<ul>
<li>例：启动本机安装的Apache（网站服务器软件），其服务器名为httpd,启动服务器：sevice httpd start</li>
</ul>
<hr>
<h3 id="kill指令"><a href="#kill指令" class="headerlink" title="kill指令"></a><strong>kill指令</strong></h3><ol>
<li><p>用法1：#kill PID</p>
</li>
<li><p>用法2：#killall 进程名称</p>
</li>
</ol>
<hr>
<h3 id="ifconfig指令"><a href="#ifconfig指令" class="headerlink" title="ifconfig指令"></a><strong>ifconfig指令</strong></h3><ul>
<li>用于操作网卡相关的指令</li>
</ul>
<ol>
<li><p>用法1：#ifconfig</p>
<p> 含义：获取网卡信息</p>
</li>
</ol>
<hr>
<h3 id="reboot指令"><a href="#reboot指令" class="headerlink" title="reboot指令"></a><strong>reboot指令</strong></h3><ol>
<li><p>用法1：#reboot</p>
<p> 含义：重启计算机</p>
</li>
<li><p>用法2：#reboot -w</p>
<p> 含义：模拟重启，但不真的重启（只写关机与开机的日志信息）</p>
</li>
</ol>
<hr>
<h3 id="shutdown指令"><a href="#shutdown指令" class="headerlink" title="shutdown指令"></a><strong>shutdown指令</strong></h3><ul>
<li><p>用法：#shutdown -h 时间（now：现在关机） “提醒信息”</p>
</li>
<li><p>含义：关机（服务器的慎用）</p>
</li>
<li><p>取消关机计划指令：#shutdown -c</p>
</li>
</ul>
<hr>
<h3 id="uptime指令"><a href="#uptime指令" class="headerlink" title="uptime指令"></a><strong>uptime指令</strong></h3><ul>
<li><p>用法：#uptime</p>
</li>
<li><p>含义：输出计算机的持续在线时间（计算机从开机到现在运行的时间）</p>
</li>
</ul>
<hr>
<h3 id="uname指令"><a href="#uname指令" class="headerlink" title="uname指令"></a><strong>uname指令</strong></h3><ul>
<li><p>作用：获取计算机操作系统的相关信息</p>
</li>
<li><p>用法：#uname -a</p>
</li>
<li><p>含义：表示获取全部的系统信息</p>
</li>
</ul>
<hr>
<h3 id="netstat-tnlp指令"><a href="#netstat-tnlp指令" class="headerlink" title="netstat -tnlp指令"></a><strong>netstat -tnlp指令</strong></h3><ul>
<li><p>作用：查看网络连接状态</p>
</li>
<li><p>用法：#netstat -tnlp</p>
</li>
<li><p>含义：</p>
<p>  -t:表示列出tcp协议的连接</p>
<p>  -n：表示地址从字母组合转化成ip地址，将协议转化成端口号来显示</p>
<p>  -l:表示过滤出”state(状态)”列中其值为LISTEN（监听）的连接</p>
<p>  -p：表示显示发起连接的进程pid和进程名称</p>
</li>
</ul>
<hr>
<h3 id="man指令"><a href="#man指令" class="headerlink" title="man指令"></a><strong>man指令</strong></h3><ul>
<li><p>作用：manual：手册（包含了Linux中全部指令手册，英文）</p>
</li>
<li><p>用法：#man 某个指令</p>
</li>
<li><p>含义：查看某个指令的用法和含义</p>
</li>
</ul>
<hr>
<h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a><strong>useradd</strong></h3><ul>
<li><p>用法：#useradd 用户名</p>
</li>
<li><p>含义：添加新用户</p>
</li>
</ul>
<hr>
<h3 id="passwd指令"><a href="#passwd指令" class="headerlink" title="passwd指令"></a><strong>passwd指令</strong></h3><ul>
<li><p>用法：#passwd 用户名</p>
</li>
<li><p>含义：给用户设置密码</p>
</li>
<li><p>注意：root用户可以随意更改所有用户的密码，而其他用户只能更改自己的密码且要符合一定的复杂度</p>
</li>
</ul>
<hr>
<h3 id="who指令"><a href="#who指令" class="headerlink" title="who指令"></a><strong>who指令</strong></h3><ul>
<li><p>用法：#who</p>
</li>
<li><p>含义：查看登录用户的信息</p>
</li>
<li><p>显示信息：登录用户名 登录终端（tty本地终端、pts远程终端） 登录时间 IP地址</p>
</li>
</ul>
<hr>
<h3 id="w指令"><a href="#w指令" class="headerlink" title="w指令"></a><strong>w指令</strong></h3><ul>
<li><p>用法：#who</p>
</li>
<li><p>含义：详细地查看登录用户的信息</p>
</li>
</ul>
<hr>
<h3 id="压缩指令gzip"><a href="#压缩指令gzip" class="headerlink" title="压缩指令gzip"></a><strong>压缩指令gzip</strong></h3><ul>
<li><p>用法：#gzip 文件</p>
</li>
<li><p>含义：压缩指定文件，压缩后文件格式为.gz</p>
</li>
</ul>
<hr>
<h3 id="解压缩指令gunzip"><a href="#解压缩指令gunzip" class="headerlink" title="解压缩指令gunzip"></a><strong>解压缩指令gunzip</strong></h3><ul>
<li><p>用法：#gunzip 文件</p>
</li>
<li><p>含义：解压缩指定文件，在Linux中gzip不能压缩目录</p>
</li>
<li><p>补充：也可以用gzip -d来解压缩</p>
</li>
</ul>
<hr>
<h3 id="tar指令"><a href="#tar指令" class="headerlink" title="tar指令"></a><strong>tar指令</strong></h3><ul>
<li><p>用法：</p>
<ol>
<li><p>打包：#tar -zcvf 打包文件名 目录路径</p>
</li>
<li><p>解包：#tar -zxvf</p>
</li>
</ol>
</li>
<li><p>选项含义：</p>
<p>  -c表示打包</p>
<p>  -x表示解包</p>
<p>  -v表示显示详细信息</p>
<p>  -f表示指定解压文件</p>
<p>  -z表示压缩（-c）或解压缩（-x）,压缩格式为.gz</p>
<p>  -j表示压缩（-c）或解压缩（-x）,压缩格式为.bz2</p>
</li>
</ul>
<hr>
<h3 id="unzip指令和zip指令"><a href="#unzip指令和zip指令" class="headerlink" title="unzip指令和zip指令"></a><strong>unzip指令和zip指令</strong></h3><ul>
<li><p>用法：</p>
<ol>
<li><p>压缩：#zip (-r) 压缩后文件名 文件或目录</p>
</li>
<li><p>解压缩：#unzip 压缩文件</p>
</li>
</ol>
</li>
<li><p>选项含义：</p>
<p>  -r表示可以压缩目录</p>
</li>
</ul>
<hr>
<h3 id="bunzip2指令和bzip2指令"><a href="#bunzip2指令和bzip2指令" class="headerlink" title="bunzip2指令和bzip2指令"></a><strong>bunzip2指令和bzip2指令</strong></h3><ul>
<li><p>bz2比较适合用来压缩大文件，压缩比比较大</p>
</li>
<li><p>用法：</p>
<ol>
<li><p>bzip2 -k 文件</p>
</li>
<li><p>bzip2 (-k) 压缩文件</p>
</li>
</ol>
</li>
<li><p>选项含义：</p>
<p>  -k表示压缩或解压缩后保留原文件</p>
</li>
<li><p>补充：和.gz文件一样，要压缩目录可以使用tar指令</p>
</li>
</ul>
<hr>
<ul>
<li>参考资料：<a href="https://www.bilibili.com/video/av23360560/?p=24" target="_blank" rel="noopener">B站Linux从入门到精通</a></li>
</ul>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux软件包管理</title>
    <url>/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="Linux软包的分类"><a href="#Linux软包的分类" class="headerlink" title="Linux软包的分类"></a>Linux软包的分类</h3><ol>
<li><p>源码包</p>
<p> 源码包是Linux下存储源代码的包。</p>
<p> 优点：源码包是开源的，可以看到源代码，在安装的过程中可以自由地选择自己想要安装的模块，也可以自行修改代码</p>
<p> 缺点：由于需要进行编译，安装慢；对初学者不友好，容易报错</p>
</li>
<li><p>rpm包</p>
<p> rpm包是源码包经过编译后存储机器代码的包</p>
<p> 优点：安装快，报错容易解决</p>
<p> 缺点：不能看到源代码；扩展性和裁剪性受到限制；具有严重地依赖性问题</p>
</li>
</ol>
<hr>
<h3 id="rpm包的命名规则"><a href="#rpm包的命名规则" class="headerlink" title="rpm包的命名规则"></a>rpm包的命名规则</h3><p><img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/22.PNG" alt="rpm"></p>
<ul>
<li>补充：其中rpm包的整个名字成为rpm包的包全名，而包全名的第一项成为rpm包的包名</li>
</ul>
<p><img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/23.PNG" alt="rpm"></p>
<hr>
<h3 id="rpm命令安装rpm包"><a href="#rpm命令安装rpm包" class="headerlink" title="rpm命令安装rpm包"></a>rpm命令安装rpm包</h3><p><img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/24.PNG" alt="rpm"></p>
<ul>
<li>例：使用rpm命令安装apache服务器</li>
</ul>
<hr>
<h3 id="rpm包的升级"><a href="#rpm包的升级" class="headerlink" title="rpm包的升级"></a>rpm包的升级</h3><p><img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/25.PNG" alt="rpm"></p>
<hr>
<h3 id="rpm包的卸载"><a href="#rpm包的卸载" class="headerlink" title="rpm包的卸载"></a>rpm包的卸载</h3><p><img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/26.PNG" alt="rpm"></p>
<ul>
<li>例：卸载apache的rpm包</li>
</ul>
<hr>
<h3 id="rpm包的查询命令"><a href="#rpm包的查询命令" class="headerlink" title="rpm包的查询命令"></a>rpm包的查询命令</h3><ol>
<li><p>查询rpm包是否安装</p>
<p> <img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/27.PNG" alt="rpm"></p>
</li>
<li><p>查询rpm包的详细信息</p>
<p> <img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/28.PNG" alt="rpm"></p>
</li>
<li><p>查询rpm包中文件安装位置</p>
<p> <img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/29.PNG" alt="rpm"></p>
</li>
<li><p>查询系统文件属于哪个rpm包</p>
<p> <img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/30.PNG" alt="rpm"></p>
</li>
<li><p>查询rpm包的依赖性</p>
<p> <img src="/2019/09/15/Linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86/31.PNG" alt="rpm"></p>
</li>
</ol>
<hr>
<p>参考资料：<a href="https://www.bilibili.com/video/av18156598/?p=23" target="_blank" rel="noopener">B站</a></p>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java——注解</title>
    <url>/2020/08/27/Java%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="何为注解"><a href="#何为注解" class="headerlink" title="何为注解"></a>何为注解</h3><ul>
<li>注解（也被称为元数据），它为我们在代码中添加信息提供了一种形式化的方法，使我们可以在某个时刻非常方便地使用这些数据。它使得我i们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息，它可以用来生成描述符文件，甚至可以是新的类定义，这样有助于减轻编写“样板”代码的负担。</li>
<li>通过注解我们可以将这些元数据保存在Java源代码中，同时，注解的优点还包括：更加干净易读的代码以及编译器类型检查等。我们还可以自定义注解，并按自己的方式使用它们。</li>
</ul>
<h3 id="内置的注解"><a href="#内置的注解" class="headerlink" title="内置的注解"></a>内置的注解</h3><ul>
<li>在JavaSE中内置了三种java.lang包下的注解：<ol>
<li>@Override：表示当前的方法定义将覆盖超类中的方法</li>
<li>@Deprecated：表示发出警告信息</li>
<li>@SuppressWarnings：关闭不当的编译器警告信息</li>
</ol>
</li>
<li>Java还另外提供了四种注解，专门负责新注解的创建</li>
</ul>
<h3 id="注解的基本语法"><a href="#注解的基本语法" class="headerlink" title="注解的基本语法"></a>注解的基本语法</h3><h4 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h4><ul>
<li>下面就是一个简单的注解的定义，可以看到注解的定义很像接口的定义，但注解使用的是<code>@interface</code>来定义的，与其他的Java接口一样，注解也会被编译成class文件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在定义注解时，需要一些<code>元注解</code>，如<code>@Target</code>和<code>@Retention</code>，<code>@Target</code>表示定义好的注解将会被应用在什么地方；<code>@Retention</code>则表示该注解在哪一个级别可用。</li>
<li>在注解中，一般都会包含一些元素来表示某些值，当分析处理注解时，程序可以利用这些值，而没有元素的注解称为<code>标记注解</code>，就像上面的@Test一样。</li>
</ul>
<h4 id="定义元素"><a href="#定义元素" class="headerlink" title="定义元素"></a>定义元素</h4><ul>
<li>在注解中，可以用定义接口的方式一样来定义注解的内容，而这些内容称为元素，如下面代码中的id和description，它们的定义类似于方法的定义，只是跟接口一样，是一个抽象的方法。在这里description元素有一个default值，如果在注解某个方法没有给出description的值，则该注解的处理器会使用默认值。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.anntation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h4><ul>
<li>注解的元素在使用时表现为名—值对的形式，并将其置于@xxx声明之后的括号内</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.anntation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.deploy.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@UseCase</span>(id=<span class="number">47</span>, description = <span class="string">"Password is required."</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password.matches(<span class="string">"\\w*\\d\\w*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@UseCase</span>(id = <span class="number">48</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encryptPassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuilder(password).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><ul>
<li>JavaSE内置了四种元注解：</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>@Target</td>
<td>表示定义好的注解将会被应用在什么地方；<br>CONSTRUCTOR：构造器声明<br>FIELD：域声明（包括enum实例）<br>METHOD：方法声明<br>PACKAGE：包声明<br>PARAMETER：参数声明<br>TYPE：类、接口、注解或enum声明</td>
</tr>
<tr>
<td>@Retention</td>
<td>示该注解在哪一个级别可用；<br>SOURCE：注解将被编译器丢弃<br>CLASS：注解在class文件中可用，但会被JVM丢弃<br>RUNTIME：VM在运行期会保留注解，因此可以通过反射机制来读取注解的信息，一般情况下都会使用这个值</td>
</tr>
<tr>
<td>@Documented</td>
<td>将此注解包含在Javadoc中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>允许子类继承父类中的注解</td>
</tr>
</tbody></table>
<h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><ul>
<li>在大多数时候，我们都会定义自己的注解，然后编写自己的处理器来出了它们，如果没有用来读取注解的工具，则注解将没有多大用处。所以使用注解的过程中，很重要的一部分是创建与使用<code>注解处理器</code>。</li>
<li>下面是一个注解处理器，它将读取PassUntils类，查找<code>@UseCase</code>标记，并通过注解的元素进行一些操作。下面的程序使用了两个反射方法：<code>getDeclaredMethods</code>和<code>getAnnotation</code>，它们都属于AnnotatedElement接口（Class、Field、Method都实现了该接口），getAnnotation需要提供注解的Class对象，它将返回方法的注解对象。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.anntation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            <span class="comment">//返回指定类型的注解对象，如果方法没有该注解，将返回null</span></span><br><span class="line">            UseCase uc = method.getAnnotation(UseCase<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (uc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 其中id为47的方法添加了description，而id为48的方法没有添加description</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.out.println(<span class="string">"Found Use Case "</span>+uc.id()+<span class="string">" "</span>+uc.description());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer useCase : useCases) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Warning:Missing use case:"</span>+useCase);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Integer&gt; useCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(useCases, <span class="number">47</span>, <span class="number">48</span>, <span class="number">49</span>);</span><br><span class="line">        trackUseCases(useCases, PasswordUtils<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="注解元素"><a href="#注解元素" class="headerlink" title="注解元素"></a>注解元素</h3><ul>
<li>注解中允许的元素类型如下：<ol>
<li>所有的基本类型，不包括其包装类</li>
<li>String</li>
<li>Class</li>
<li>enum</li>
<li>Annotation</li>
<li>以上类型的数组</li>
</ol>
</li>
<li>默认值的限制：<ol>
<li>元素不能有不确定的值，即元素要么具有默认值，要么在使用注解时提供元素的值</li>
<li>不能以null作为默认值</li>
</ol>
</li>
</ul>
<hr>
<p>参考资料：Java编程思想</p>
]]></content>
      <categories>
        <category>-Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis基础1</title>
    <url>/2020/07/24/MyBatis%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>创建一个父项目，导入依赖</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        mysql连接依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        mybatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        junit测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="MyBatis核心配置文件"><a href="#MyBatis核心配置文件" class="headerlink" title="MyBatis核心配置文件"></a>MyBatis核心配置文件</h3><p>在resource文件夹下创建核心配置文件，在这个文件下可以配置环境（数据源）、注册mapper、设置类别名等等。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    在这里可以配置多个环境，开发环境和生产环境，可用于数据源的切换--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            注册mapper--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/muchlab/mapper/UserMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="读取MyBatis核心配置文件"><a href="#读取MyBatis核心配置文件" class="headerlink" title="读取MyBatis核心配置文件"></a>读取MyBatis核心配置文件</h3><p>在读取配置文件前,先介绍三个关键的MyBatis类:</p>
<ol>
<li><code>SqlSessionFactoryBuilder</code>:通过读取配置文件,来创建SqlSessionFactory,这里使用了建造者模式,一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</li>
<li><code>SqlSessionFactory</code>:SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，最好不要去释放它或重新创建一个新的实例,最简单的就是使用单例模式或者静态单例模式。</li>
<li><code>SqlSession</code>:每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中或使用try语法来释放该资源。</li>
</ol>
<p>创建一个工具类,用来返回SqlSession实例</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//根据mybatis-config.xml来获取SqlSessionFactory，</span></span><br><span class="line">            <span class="comment">// SqlSessionFactory是用来获取SqlSession</span></span><br><span class="line">            <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法</span></span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回创建好的SqlSession</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建实体类和Mapper接口"><a href="#创建实体类和Mapper接口" class="headerlink" title="创建实体类和Mapper接口"></a>创建实体类和Mapper接口</h3><p>Mapper接口就相当于Dao接口或Repository接口,是外界用来操作数据库的接口</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取数据库中所有的User</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建对应的Mapper-xml"><a href="#创建对应的Mapper-xml" class="headerlink" title="创建对应的Mapper.xml"></a>创建对应的Mapper.xml</h3><p>每一个Mapper接口都应该对应一个Mapper.xml文件,该文件是用来解释Mapper接口中方法对应的sql操作,文件里的具体细节请参考<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">官方文档</a></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.muchlab.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultType</span>=<span class="string">"com.muchlab.entity.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取SqlSession对象</span></span><br><span class="line">        <span class="keyword">try</span> (SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">            <span class="comment">//方式一：getMapper</span></span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;User&gt; all = mapper.getAll();</span><br><span class="line">            all.forEach(c-&gt;&#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式二：涉及到类型强转，不推荐</span></span><br><span class="line">            List&lt;User&gt; userlist = sqlSession.selectList(<span class="string">"com.muchlab.mapper.UserMapper.getAll"</span>);</span><br><span class="line">            userlist.forEach(c-&gt;&#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol>
<li>Mapper接口定义后,必须在核心配置文件中注册Mapper.xml</li>
<li>资源过滤问题,程序运行后会生成目标文件,因为编译后默认只包含.class文件,如果没配置资源过滤,在target文件夹中会找不到Mapper.xml文件,在pom文件中添加下面代码:</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="select、insert、update、delete"><a href="#select、insert、update、delete" class="headerlink" title="select、insert、update、delete"></a>select、insert、update、delete</h3><ol>
<li>id：对应于Mapper接口中的方法名</li>
<li>resultType：接口中方法的返回类型</li>
<li>parameterType：接口中方法的传入参数类型</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.muchlab.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.muchlab.entity.User"</span>&gt;</span></span><br><span class="line">        insert into user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.muchlab.entity.User"</span>&gt;</span></span><br><span class="line">        update user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125; ;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultType</span>=<span class="string">"com.muchlab.entity.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getById"</span> <span class="attr">resultType</span>=<span class="string">"com.muchlab.entity.User"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        select * from user alias where alias.id = #&#123;id&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>插入、更新、删除需要执行commit方法，执行commit方法才会把数据提交到数据库中。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">getById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取SqlSession对象</span></span><br><span class="line">        <span class="keyword">try</span> (SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">            <span class="comment">//方式一：getMapper</span></span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;User&gt; all = mapper.getAll();</span><br><span class="line">            all.forEach(c-&gt;&#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方式二：涉及到类型强转，不推荐</span></span><br><span class="line">            List&lt;User&gt; userlist = sqlSession.selectList(<span class="string">"com.muchlab.mapper.UserMapper.getAll"</span>);</span><br><span class="line">            userlist.forEach(c-&gt;&#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            User user = mapper.getById(<span class="number">1</span>);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">int</span> result = mapper.addUser(<span class="keyword">new</span> User(<span class="number">6</span>,<span class="string">"John Lennon"</span>, <span class="string">"12345"</span>));</span><br><span class="line">            <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"插入成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;User&gt; all = mapper.getAll();</span><br><span class="line">            <span class="keyword">for</span> (User user : all) &#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//执行commit才把插入的数据提交上去</span></span><br><span class="line">            sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            User user = mapper.getById(<span class="number">1</span>);</span><br><span class="line">            user.setName(<span class="string">"Cobain"</span>);</span><br><span class="line">            <span class="keyword">int</span> i = mapper.updateUser(user);</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"修改成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;User&gt; all = mapper.getAll();</span><br><span class="line">            <span class="keyword">for</span> (User user1 : all) &#123;</span><br><span class="line">                System.out.println(user1);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">            UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mapper.deleteUser(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;User&gt; all = mapper.getAll();</span><br><span class="line">            <span class="keyword">for</span> (User user : all) &#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="万能的Map"><a href="#万能的Map" class="headerlink" title="万能的Map"></a>万能的Map</h3><p>使用实体类进行传参，在sql中是取出它的字段名；二map是取出它的key；</p>
<p>map可以进行数据塑形，根据你需要的来插入、更新，一般在局部更新和多参数中比较有用。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addUserMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUserMap"</span>&gt;</span></span><br><span class="line">    insert into user (id, name, pwd) values (#&#123;a&#125;, #&#123;b&#125;, #&#123;c&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"a"</span>, <span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">"b"</span>, <span class="string">"ChenZheKai"</span>);</span><br><span class="line">        map.put(<span class="string">"c"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="keyword">int</span> i = mapper.addUserMap(map);</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"插入成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;User&gt; <span class="title">getUserLike</span><span class="params">(String name)</span></span>;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserLike"</span> <span class="attr">resultType</span>=<span class="string">"com.muchlab.entity.User"</span>&gt;</span></span><br><span class="line">    select * from user alias where alias.name like "%"#&#123;name&#125;"%";</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUserLike</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; userLike = mapper.getUserLike(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">for</span> (User user : userLike) &#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>参考资料:<a href="https://www.bilibili.com/video/BV1NE411Q7Nx?p=3" target="_blank" rel="noopener">B站狂神</a></p>
]]></content>
      <categories>
        <category>-MyBatis</category>
      </categories>
      <tags>
        <tag>-Java -MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——如何保证主备一致</title>
    <url>/2020/11/09/MySql%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h3 id="主备的基本原理"><a href="#主备的基本原理" class="headerlink" title="主备的基本原理"></a>主备的基本原理</h3><ul>
<li>在MySQL中主备库是可以切换的，如下：在状态1中，客户端的读写都直接访问节点A，而节点B是A的备库，只是将节点A的更新都同步过来，到本地执行，这样就可以保证AB的数据是一致的。</li>
<li>当切换节点时，也就是变成状态2后，客户端的读写访问节点都是节点B，而节点A就是节点B的备库。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/fd/10/fd75a2b37ae6ca709b7f16fe060c2c10.png" alt="img"></p>
<ul>
<li>建议把备库设置为只读模式，这样做的原因有以下三点：<ol>
<li>有时候一些运营类的查询语句会被放到备库上去查，设置为只读可以防止误操作；</li>
<li>防止切换逻辑有 bug，比如切换过程中出现双写，造成主备不一致；</li>
<li>可以用 readonly 状态，来判断节点的角色。</li>
</ol>
</li>
</ul>
<h3 id="主备的执行流程"><a href="#主备的执行流程" class="headerlink" title="主备的执行流程"></a>主备的执行流程</h3><ul>
<li>上面的图中，进行主备复制的就是A和B之间的线，那这条线究竟是怎么执行的呢？</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/a6/a3/a66c154c1bc51e071dd2cc8c1d6ca6a3.png" alt="img"></p>
<ul>
<li>当需要进行主备复制时，备库B跟主库A之间需要维持一个长连接。主库A内部有一个线程，专门服务B的这个长连接，完整的执行过程时这样的：<ol>
<li>在备库B上通过<code>change master</code>命令，设置主库A的IP、端口、用户名、密码以及要从哪个位置开始请求binlog，这个位置包含了binlog的文件名和日志的偏移量。</li>
<li>在备库上执行<code>save slave</code>命令，这时备库就会启动两个线程<code>io_thread</code>和<code>sql_thread</code>，一个负责维持与主库的长连接，一个负责执行<code>relay log</code>中的sql语句。</li>
<li>而主库A在校验完用户名和密码后，开始按照备库B传来的位置，从本地读取binlog并发送给B</li>
<li>备库B拿到binlog后，写到本地文件，这个文件为<code>relay log</code>，也叫中转日志。</li>
<li><code>sql_thread</code>解析<code>relay log</code>中的命令并执行。</li>
</ol>
</li>
</ul>
<h3 id="binlog的三种格式对比"><a href="#binlog的三种格式对比" class="headerlink" title="binlog的三种格式对比"></a>binlog的三种格式对比</h3><ul>
<li>binlog一共有三种格式：可以使用<code>show binlog events in [binlog文件位置];</code>命令来查看binlog中的内容。</li>
</ul>
<h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><ul>
<li>在Statement格式下，binlog里面记录的就是SQL语句的原文，它使用commit来判断事务是否提交。</li>
<li>举个例子：执行这行语句<code>delete from t /*comment*/  where a&gt;=4 and t_modified&lt;=&#39;2018-11-10&#39; limit 1;</code>，它生成的binlog如下：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/b9/31/b9818f73cd7d38a96ddcb75350b52931.png" alt="img"></p>
<ul>
<li>由上图可以看到：statement格式下，binlog记录的都是SQL语句，而第一行 SET @@SESSION.GTID_NEXT=’ANONYMOUS’使用来做主备切换的。</li>
<li>看起来使用statement格式好像没有什么问题，但在执行这个语句时其实是不安全的，这是因为delete带了limit，这很有可能会出现主备不一致的情况：<ol>
<li>如果 delete 语句使用的是索引 a，那么会根据索引 a 找到第一个满足条件的行，也就是说删除的是 a=4 这一行；</li>
<li>但如果使用的是索引 t_modified，那么删除的就是 t_modified=’2018-11-09’也就是 a=5 这一行。</li>
</ol>
</li>
<li>因此，使用statement格式是有风险的。</li>
</ul>
<h4 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h4><ul>
<li>在Row格式下，binlog中记录的是执行SQL语句的event，例如下图：前后的 BEGIN 和 COMMIT 是一样的。但是，row 格式的 binlog 里没有了 SQL 语句的原文，而是替换成了两个 event：Table_map 和 Delete_rows。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/d6/26/d67a38db154afff610ae3bb64e266826.png" alt="img"></p>
<ol>
<li>Table_map event，用于说明接下来要操作的表是 test 库的表 t;</li>
<li>Delete_rows event，用于定义删除的行为。</li>
</ol>
<ul>
<li>可以使用mysqlbinlog 工具，用下面这个命令解析和查看 binlog 中的内容。从上图可以知道，这个事务的 binlog 是从 8900 这个位置开始的，所以可以用 start-position 参数来指定从这个位置的日志开始解析。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog  -vv [binlog文件位置] <span class="comment">--start-position=8900;</span></span><br></pre></td></tr></table></figure></div>

<p><img src="https://static001.geekbang.org/resource/image/c3/c2/c342cf480d23b05d30a294b114cebfc2.png" alt="img"></p>
<ul>
<li>从这个图，我们可以知道：<ol>
<li>server id 1，表示这个事务是在 server_id=1 的这个库上执行的。</li>
<li>每个 event 都有 CRC32 的值，这是因为我把参数 binlog_checksum 设置成了 CRC32。</li>
<li>我们在 mysqlbinlog 的命令中，使用了 -vv 参数是为了把内容都解析出来，所以从结果里面可以看到各个字段的值（比如，@1=4、 @2=4 这些值）。</li>
<li>最后的 Xid event，用于表示事务被正确地提交了。</li>
</ol>
</li>
<li>从这里可以看到，使用Row格式时，binlog记录的是需要进行操作的rowid=xxx的行，这样binlog传到备库中去的时候，就肯定会删除id=xxx的行，因为主键是唯一的，就不会出现主备删除不同行的问题。</li>
</ul>
<h4 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h4><ul>
<li>由上面可知，statement 格式的 binlog 可能会导致主备不一致，所以要使用 row 格式。</li>
<li>但 row 格式的缺点是，很占空间。比如你用一个 delete 语句删掉 10 万行数据，用 statement 的话就是一个 SQL 语句被记录到 binlog 中，占用几十个字节的空间。但如果用 row 格式的 binlog，就要把这 10 万条记录都写到 binlog 中。这样做，不仅会占用更大的空间，同时写 binlog 也要耗费 IO 资源，影响执行速度。</li>
<li>所以，MySql就取了个折中方案，也就是有了 mixed 格式的 binlog。mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式。</li>
</ul>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul>
<li>如果你的线上 MySQL 设置的 binlog 格式是 statement 的话，那基本上就可以认为这是一个不合理的设置。你至少应该把 binlog 的格式设置为 mixed。</li>
<li>但是，越来越多的场景会要求把binlog_format设置成row格式，这么做有一个好处，那就是可以用binlog来恢复数据，因为row格式的binlog会把增删改的操作的所有数据记录起来，当你要恢复数据时，你只需要执行相应的反向操作。</li>
<li>最后，用 binlog 来恢复数据的标准做法是，用 mysqlbinlog 工具解析出来，然后把解析结果整个发给 MySQL 执行。类似下面的命令：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [binlog文件位置]  <span class="comment">--start-position=2738 --stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="双M结构——循环复制"><a href="#双M结构——循环复制" class="headerlink" title="双M结构——循环复制"></a>双M结构——循环复制</h3><ul>
<li>在第一张图我们所用到的是M-S的主备结构，但实际生产上使用得较多的是双M结构，也就是下图：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/20/56/20ad4e163115198dc6cf372d5116c956.png" alt="img"></p>
<ul>
<li>其实这和图一相比，只是多了一条线，这代表了A和B之间是互为主备的关系，在切换客户端连接的时候就不用再修改主备关系了</li>
<li>业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（建议把参数 log_slave_updates 设置为 on，表示备库执行· relay log 后生成 binlog）。那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？</li>
<li>从上面的知识可以知道，binlog会记录下 server id 的值，这就可以使用这个id来解决循环复制问题：<ol>
<li>规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；</li>
<li>一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；</li>
<li>每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。</li>
</ol>
</li>
<li>则双M结构下，日志的执行流就会变成这样：<ol>
<li>从节点 A 更新的事务，binlog 里面记的都是 A 的 server id；</li>
<li>传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id；</li>
<li>再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。</li>
</ol>
</li>
</ul>
<hr>
<p>学习资料：<a href="https://time.geekbang.org/column/intro/100020801" target="_blank" rel="noopener">MySql实战45讲</a></p>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——全局锁、表级锁、行锁</title>
    <url>/2020/11/07/MySql%E2%80%94%E2%80%94%E5%85%A8%E5%B1%80%E9%94%81%E3%80%81%E8%A1%A8%E7%BA%A7%E9%94%81%E3%80%81%E8%A1%8C%E9%94%81/</url>
    <content><![CDATA[<ul>
<li>全局锁就是对整个数据库实例加锁，命令是<code>Flush tables with read lock</code>。（FTWRL）执行这个命令后，其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</li>
<li>执行<code>unlock tables</code>就可以解除全局锁。</li>
</ul>
<blockquote>
<p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。</p>
</blockquote>
<ul>
<li>你也许会问，既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，但我还是会建议你用 FTWRL 方式。</li>
<li>主要有两个原因：<ol>
<li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。</li>
<li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ol>
</li>
<li>业务的更新不只是增删改数据（DML)，还有可能是加字段等修改表结构的操作（DDL）。不论是哪种方法，一个库被全局锁上以后，你要对里面任何一个表做加字段操作，都是会被锁住的。</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul>
<li>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</li>
</ul>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li>添加表锁的命令是<code>lock tables [表名] read/write</code>，可以用<code>unlock tables [表名]</code>命令主动释放锁，也可以在客户端断开的时候自动释放。</li>
<li>表锁分为读锁和写锁：<ol>
<li>读锁：当一个线程对表添加读锁后，所有的线程只能对该表进行Select语句查询。</li>
<li>写锁：当一个线程对表添加写锁后，其他线程不能对这个表进行读写，而本线程可以对表进行增删改查。</li>
</ol>
</li>
</ul>
<blockquote>
<p>如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。</p>
</blockquote>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><ul>
<li><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>
</li>
<li><p>当对一个表做增删改查时，会自动加上MDL读锁；当要对表做结构变更时，会自动加上MDL写锁。读锁之间不互斥，因此可以有多个线程同时对一张表进行增删改查。读-写锁之间和写-写锁之间是互斥的，用来保证变更表结构操作的安全性。如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
</li>
<li><p>其实给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表 t 是一个小表。</p>
</li>
<li><p>那如何安全地给小表加字段？</p>
<ol>
<li>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</li>
<li>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？这时候 kill 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</li>
</ol>
</li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul>
<li>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</li>
<li>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</li>
<li>在 InnoDB 事务中，行锁是在需要的时候才加上的，即在对某一行进行修改时加上，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。知道了这个设定，对我们使用事务有什么帮助呢？</li>
<li>那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</li>
<li>因为锁等待时间是正在执行的事物引起锁的语句到提交的时间间隔，如果放在事务最后，那这个时间间隔会变为最少。</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>全局锁主要用在逻辑备份过程中。对于全部是 InnoDB 引擎的库，我建议你选择使用–single-transaction 参数，对应用会更友好。</li>
<li>表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现你的应用程序里有 lock tables 这样的语句，你需要追查一下，比较可能的情况是：<ol>
<li>要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；</li>
<li>要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把 lock tables 和 unlock tables 改成 begin 和 commit，问题就解决了。MDL 会直到事务提交才释放，在做表结构变更的时候，你一定要小心不要导致锁住线上查询和更新。</li>
</ol>
</li>
<li>我以两阶段协议为起点，和你一起讨论了在开发的时候如何安排正确的事务语句。这里的原则 / 我给你的建议是：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁的申请时机尽量往后放。</li>
</ul>
<hr>
<p>学习资料：<a href="https://time.geekbang.org/column/article/70215" target="_blank" rel="noopener">MySql实战45讲</a></p>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——如何保证高可用</title>
    <url>/2020/11/09/MySql%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><p><img src="https://static001.geekbang.org/resource/image/89/cc/89290bbcf454ff9a3dc5de42a85a69cc.png" alt="img"></p>
<ul>
<li><p>主备切换可能是一个主动运维动作，比如软件升级、主库所在机器按计划下线等，也可能是被动操作，比如主库所在机器掉电。</p>
</li>
<li><p>在介绍主动切换流程的详细步骤之前，我要先跟你说明一个概念，即“同步延迟”。与数据同步有关的时间点主要包括以下三个：</p>
<ol>
<li>主库 A 执行完成一个事务，写入 binlog，我们把这个时刻记为 T1;</li>
<li>之后传给备库 B，我们把备库 B 接收完这个 binlog 的时刻记为 T2;</li>
<li>备库 B 执行完成这个事务，我们把这个时刻记为 T3。</li>
</ol>
</li>
<li><p>所谓主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是 T3-T1。</p>
</li>
<li><p>你可以在备库上执行 show slave status 命令，它的返回结果里面会显示 seconds_behind_master，用于表示当前备库延迟了多少秒。</p>
</li>
<li><p>seconds_behind_master 的计算方法是这样的：</p>
<ol>
<li>每个事务的 binlog 里面都有一个时间字段，用于记录主库上写入的时间；</li>
<li>备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到 seconds_behind_master。</li>
</ol>
</li>
<li><p>所以说，主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。</p>
</li>
</ul>
<h3 id="主备延迟的来源"><a href="#主备延迟的来源" class="headerlink" title="主备延迟的来源"></a>主备延迟的来源</h3><blockquote>
<p>有些部署条件下，<strong>备库所在机器的性能要比主库所在的机器性能差。</strong>但实际上，更新过程中也会触发大量的读操作。所以，当备库主机上的多个备库都在争抢资源的时候，就可能会导致主备延迟了。</p>
<p>解决方法是：采用对称部署，也就是说让备库和主库所在的机器性能一致，这样做也方便了主备切换</p>
</blockquote>
<blockquote>
<p><strong>备库的压力大</strong>。一般的想法是，主库既然提供了写能力，那么备库可以提供一些读能力。或者一些运营后台需要的分析语句，不能影响正常业务，所以只能在备库上跑。结果就是，备库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。</p>
<p>解决办法是：</p>
<ol>
<li>一主多从。除了备库外，可以多接几个从库，让这些从库来分担读的压力。</li>
<li>通过 binlog 输出到外部系统，比如 Hadoop 这类系统，让外部系统提供统计类查询的能力。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>大事务</strong>，因为主库上必须等事务执行完成才会写入 binlog，再传给备库。所以，如果一个主库上的语句执行 10 分钟，那这个事务很可能就会导致从库延迟 10 分钟。</p>
</blockquote>
<ul>
<li>另外，导致主备延迟的还有大表DDL和备库的并行能力等等。</li>
</ul>
<h3 id="可靠性优先策略"><a href="#可靠性优先策略" class="headerlink" title="可靠性优先策略"></a>可靠性优先策略</h3><ul>
<li>在上图双M的转换，详细过程如下：<ol>
<li>判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；</li>
<li>把主库 A 改成只读状态，即把 readonly 设置为 true；</li>
<li>判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；</li>
<li>把备库 B 改成可读写状态，也就是把 readonly 设置为 false；</li>
<li>把业务请求切到备库 B。</li>
</ol>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/54/4a/54f4c7c31e6f0f807c2ab77f78c8844a.png" alt="img"></p>
<ul>
<li>这个策略的优点是可靠性高，不会导致数据的不一致问题，但缺点也很明显，就是第三步需要等待second_behind_master的值变为0，这会导致整个系统处于一种不可用状态。</li>
</ul>
<h3 id="可用性优先策略"><a href="#可用性优先策略" class="headerlink" title="可用性优先策略"></a>可用性优先策略</h3><ul>
<li>可用性优先策略就是把可靠性优先策略的第四五步调到最前面，保证系统没有不可用的时间。但是这么做就会导致主备库数据不一致的问题。</li>
<li>举个例子：有一张表，并插入两行数据</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">1</span>),(<span class="number">2</span>),(<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*========================*/</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c) <span class="keyword">values</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>假设，现在主库上其他的数据表有大量的更新，导致主备延迟达到了5秒，当插入一条c=4的语句后，发生了主备切换。</li>
<li>如果此时binlog_format=mixed，用可用性优先策略进行切换，将会是如下情况：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/37/3a/3786bd6ad37faa34aca25bf1a1d8af3a.png" alt="img"></p>
<ul>
<li><p>具体流程：</p>
<ol>
<li>步骤 2 中，主库 A 执行完 insert 语句，插入了一行数据（4,4），之后开始进行主备切换。</li>
<li>步骤 3 中，由于主备之间有 5 秒的延迟，所以备库 B 还没来得及应用“插入 c=4”这个中转日志，就开始接收客户端“插入 c=5”的命令。</li>
<li>步骤 4 中，备库 B 插入了一行数据（4,5），并且把这个 binlog 发给主库 A。</li>
<li>步骤 5 中，备库 B 执行“插入 c=4”这个中转日志，插入了一行数据（5,4）。而直接在备库 B 执行的“插入 c=5”这个语句，传到主库 A，就插入了一行新数据（5,5）。</li>
</ol>
</li>
<li><p>最后的结果就是，主库 A 和备库 B 上出现了两行不一致的数据。可以看到，这个数据不一致，是由可用性优先流程导致的。</p>
</li>
<li><p>如果把binlog_format设置成row格式，这时由于row格式下的binlog会记录数据行的所有字段，并是使用rowid进行应用的，所以回报重复主键异常，具体流程如下：</p>
<p><img src="https://static001.geekbang.org/resource/image/b8/43/b8d2229b2b40dd087fd3b111d1bdda43.png" alt="img"></p>
</li>
<li><p>所以，主备切换一般采用可靠性优先策略，毕竟数据的可靠性是要优于可用性的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis基础2</title>
    <url>/2020/07/24/MyBatis%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h2 id="MyBatis基础2"><a href="#MyBatis基础2" class="headerlink" title="MyBatis基础2"></a>MyBatis基础2</h2><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><ul>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties" target="_blank" rel="noopener">properties（属性）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">settings（设置）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases" target="_blank" rel="noopener">typeAliases（类型别名）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">typeHandlers（类型处理器）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory" target="_blank" rel="noopener">objectFactory（对象工厂）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins" target="_blank" rel="noopener">plugins（插件）</a></li>
<li>environments（环境配置）<ul>
<li>environment（环境变量）<ul>
<li>transactionManager（事务管理器）</li>
<li>dataSource（数据源）</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider" target="_blank" rel="noopener">databaseIdProvider（数据库厂商标识）</a></li>
<li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers" target="_blank" rel="noopener">mappers（映射器）</a></li>
</ul>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><p>MyBatis在environments来配置适应多种环境，不过每个SqlSessionFactory只能选择一种环境</p>
</li>
<li><p>MyBatis的事务管理器有<code>JDBC|MANAGED</code>两种，默认是JDBC</p>
</li>
<li><p>MyBatis的数据源类型有<code>UNPOOLED|POOLED|JNDI</code>三种，一般采用POOLED</p>
<ol>
<li><strong>UNPOOLED</strong>– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。</li>
<li><strong>POOLED</strong>– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。</li>
<li><strong>JNDI</strong> – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</li>
</ol>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>我们可以使用properties来引用配置文件，编写一个配置文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"db.properties"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以添加一些属性--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            事务管理--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>可以给一个实体类起别名，也可以扫描包下的类，以类名来作为别名</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    给实体类起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;typeAlias type="com.muchlab.mybatis02.entity.User" alias="User"/&gt;--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.muchlab.mybatis02.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p>
<table>
<thead>
<tr>
<th align="left">别名</th>
<th align="left">映射的类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">_byte</td>
<td align="left">byte</td>
</tr>
<tr>
<td align="left">_long</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">_short</td>
<td align="left">short</td>
</tr>
<tr>
<td align="left">_int</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">_integer</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">_double</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">_float</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">_boolean</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">string</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">integer</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">date</td>
<td align="left">Date</td>
</tr>
<tr>
<td align="left">decimal</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">bigdecimal</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">object</td>
<td align="left">Object</td>
</tr>
<tr>
<td align="left">map</td>
<td align="left">Map</td>
</tr>
<tr>
<td align="left">hashmap</td>
<td align="left">HashMap</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">List</td>
</tr>
<tr>
<td align="left">arraylist</td>
<td align="left">ArrayList</td>
</tr>
<tr>
<td align="left">collection</td>
<td align="left">Collection</td>
</tr>
<tr>
<td align="left">iterator</td>
<td align="left">Iterator</td>
</tr>
</tbody></table>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>主要有如下几个设置：其他可以通过官方文档查阅</p>
<table>
<thead>
<tr>
<th align="left">设置名</th>
<th align="left">描述</th>
<th align="left">有效值</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cacheEnabled</td>
<td align="left">全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td>
<td align="left">true | false</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">lazyLoadingEnabled</td>
<td align="left">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td>
<td align="left">true | false</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">useGeneratedKeys</td>
<td align="left">允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。</td>
<td align="left">true | false</td>
<td align="left">False</td>
</tr>
<tr>
<td align="left">logImpl</td>
<td align="left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td>
<td align="left">未设置</td>
</tr>
<tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td>
<td align="left">true | false</td>
<td align="left">False</td>
</tr>
</tbody></table>
<h3 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h3><ul>
<li>使用resource方式注册，只需指出Mapper配置文件的位置，没有任何限制，推荐。</li>
<li>使用class方式注册，接口和对应的Mapper配置文件必须同名且在同一个包下。</li>
<li>使用package方式注册，接口和对应的Mapper配置文件必须同名且在同一个包下。</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>Mybatis-Generator</p>
<p>Mybatis-Plus</p>
<h3 id="使用limit进行分页"><a href="#使用limit进行分页" class="headerlink" title="使用limit进行分页"></a>使用limit进行分页</h3><p>startIndex为每页的第一项下标，pageSize为每页的项数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudentByLimit"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from t_student limit #&#123;startIndex&#125;, #&#123;pageSize&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p>创建学生表和教师表，多个学生对应一个老师</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="string">`t_student`</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">exists</span> <span class="string">`t_teacher`</span> ;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_teacher(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">    tid <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span>(tid) <span class="keyword">references</span> t_teacher(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>在Mapper.xml文件中的多对一有两种写法：1、按结果集进行映射，2、按子查询进行映射</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--按联表进行映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"studentTeacher1"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultMap</span>=<span class="string">"studentTeacher1"</span>&gt;</span></span><br><span class="line">    select s.id as sid, s.name as sname, t.name as tname, t.id as tid</span><br><span class="line">    from t_student as s, t_teacher as t</span><br><span class="line">    where s.tid = t.id</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--按子查询进行映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"studentTeacher2"</span> <span class="attr">type</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"teacher"</span> <span class="attr">javaType</span>=<span class="string">"Teacher"</span> <span class="attr">select</span>=<span class="string">"getTeacher"</span> <span class="attr">column</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllBySubquery"</span> <span class="attr">resultMap</span>=<span class="string">"studentTeacher2"</span>&gt;</span></span><br><span class="line">    select * from t_student</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getTeacher"</span> <span class="attr">resultType</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    select * from t_teacher t where t.id=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>一个老师对应多个学生，跟多对一一样，也有两种写法</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--按联表进行映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"TeacherStudent1"</span> <span class="attr">type</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"tname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">ofType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"sid"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"sname"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultMap</span>=<span class="string">"TeacherStudent1"</span>&gt;</span></span><br><span class="line">    select s.id as sid, t.id as tid, s.name as sname, t.name as tname</span><br><span class="line">    from t_teacher as t, t_student as s</span><br><span class="line">    where t.id=s.tid</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--按子查询进行映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"TeacherStudent2"</span> <span class="attr">type</span>=<span class="string">"Teacher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"tname"</span> <span class="attr">property</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"students"</span> <span class="attr">ofType</span>=<span class="string">"Student"</span> <span class="attr">select</span>=<span class="string">"getStudent"</span> <span class="attr">column</span>=<span class="string">"tid"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllSubquery"</span> <span class="attr">resultMap</span>=<span class="string">"TeacherStudent2"</span>&gt;</span></span><br><span class="line">    select id as tid, name as tname</span><br><span class="line">    from t_teacher</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getStudent"</span> <span class="attr">resultType</span>=<span class="string">"Student"</span>&gt;</span></span><br><span class="line">    select * from t_student where tid=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="动态Sql"><a href="#动态Sql" class="headerlink" title="动态Sql"></a>动态Sql</h3><ul>
<li>所谓的动态Sql就是指根据不同的条件生成不同的Sql语句</li>
<li>分别有四种拼接条件：<ol>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>foreach</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCourseIf"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Course"</span>&gt;</span></span><br><span class="line">    select * from t_course where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"if-id-name"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCourseChoose"</span> <span class="attr">resultType</span>=<span class="string">"Course"</span>&gt;</span></span><br><span class="line">    select * from t_course where  1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果满足when条件，则拼接when中的sql语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"name !=null"</span>&gt;</span></span><br><span class="line">            and name like #&#123;name&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果没有when条件满足，则拼接otherwise中的sql语句--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and id = 1</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    where标签的含义是，如果有条件，则会sql自动地添加上where，如果没有条件，则不会添加where</span></span><br><span class="line"><span class="comment">        ,如果where前面是连接关键字的话，会把关键字给去掉--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCourseWhere"</span> <span class="attr">resultType</span>=<span class="string">"Course"</span>&gt;</span></span><br><span class="line">    select * from t_course</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"if-id-name"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    select * from t_course where (id = ? or id = ?...)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCourseForeach"</span> <span class="attr">resultType</span>=<span class="string">"Course"</span>&gt;</span></span><br><span class="line">    select * from t_course</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的集合是从map中传递过来的,这里的值必须与map的key一致，而item的值必须与后面的条件#&#123;&#125;中的值一致，否则值将无法传入--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里open的and是为了如果前面有条件而添加的，如果没有where会将其去掉--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">item</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">open</span>=<span class="string">"and ("</span> <span class="attr">close</span>=<span class="string">")"</span> <span class="attr">separator</span>=<span class="string">"or"</span>&gt;</span></span><br><span class="line">            id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Sql片段"><a href="#Sql片段" class="headerlink" title="Sql片段"></a>Sql片段</h3><ul>
<li>讲公共部分的sql抽取出来，如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"if-id-name"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id != null"</span>&gt;</span></span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--从第二个标签开始需要加连接关键字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name != null"</span>&gt;</span></span><br><span class="line">        and name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在要插入的地方使用include，如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCourseIf"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultType</span>=<span class="string">"Course"</span>&gt;</span></span><br><span class="line">    select * from t_course where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"if-id-name"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCourseWhere"</span> <span class="attr">resultType</span>=<span class="string">"Course"</span>&gt;</span></span><br><span class="line">    select * from t_course</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"if-id-name"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意事项：<ol>
<li>最好只基于单表来定义Sql片段</li>
<li>不要在Sql片段中使用where</li>
</ol>
</li>
</ul>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>缓存就是储存在内存中的临时数据，将用户经常查询的数据放在缓存中，用户查询数据就不用从磁盘上去读取，而从缓存中读取，从而提高查询的效率，解决了高并发系统的性能问题。</li>
<li>优点：减少和数据库的交互（连接）次数，减少系统开销，提高系统效率，经常查询且不经常改变的数据就可以使用缓存。</li>
<li>MyBatis有两种缓存，分别是：<ol>
<li>一级缓存：默认是开启的，它是SqlSession对象下的作用域有效，如果关闭了SqlSession缓存将会失效，一级缓存有几个会刷新缓存的操作：1、执行增删改操作；2、使用不同的Mapper文件；3、使用clearCache方法<code>sqlSession.clearCache()</code></li>
<li>二级缓存：二级缓存也叫全局缓存，一级缓二级缓存是基于namespace级别的缓存，一个namespace对应一个二级缓存</li>
</ol>
</li>
</ul>
<h4 id="二级缓存的使用"><a href="#二级缓存的使用" class="headerlink" title="二级缓存的使用"></a>二级缓存的使用</h4><ul>
<li>如果想让某个Mapper文件开启缓存，可以在Mapper文件中添加cache标签</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--属性含义分别是：缓存使用的策略；缓存刷新的间隔时间；缓存的最大数目；是否开启只读属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">size</span>=<span class="string">"512"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果想全局地开启缓存，则可以在MBatis的配置文件下进行配置</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意：Mybatis默认是开启了二级缓存的，所以不用配置也能生效</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">    <span class="keyword">final</span> CourseMapper mapper = sqlSession.getMapper(CourseMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">"ids"</span>, list);</span><br><span class="line">    <span class="keyword">final</span> List&lt;Course&gt; courses = mapper.getCourseForeach(map);</span><br><span class="line">    <span class="keyword">for</span> (Course cours : courses) &#123;</span><br><span class="line">        System.out.println(cours);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二级缓存会读取一级缓存进行保存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二次查询数据的时候会从二级缓存中读取数据</span></span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">final</span> SqlSession sqlSession = MybatisUtils.getSqlSession())&#123;</span><br><span class="line">    <span class="keyword">final</span> CourseMapper mapper = sqlSession.getMapper(CourseMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; list = Arrays.asList(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    map.put(<span class="string">"ids"</span>, list);</span><br><span class="line">    <span class="keyword">final</span> List&lt;Course&gt; courses = mapper.getCourseForeach(map);</span><br><span class="line">    <span class="keyword">for</span> (Course cours : courses) &#123;</span><br><span class="line">        System.out.println(cours);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Mybatis和SpringBoot的整合"><a href="#Mybatis和SpringBoot的整合" class="headerlink" title="Mybatis和SpringBoot的整合"></a>Mybatis和SpringBoot的整合</h3><ul>
<li>添加依赖</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在application.yml中进行配置（即mybatis-config的配置）</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">mapper/*Mapper.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.chapter24mybatis.chaper42.domain</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用：SpringBoot中有两种方式进行Mapper的注册：<ol>
<li>使用<code>@MapperScan(&quot;com.xxx.mapper&quot;)</code></li>
<li>在Mapper接口中添加<code>@Mapper</code></li>
</ol>
</li>
</ul>
<h3 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h3><ul>
<li>当数据库数据类型和Java中的类型存在不一致的时候，或者说无法自动转换的时候，我们需要编写类型转换器来处理这类的转换。</li>
<li>一般类型转换器需要实现<code>TypeHandler</code>或<code>BaseTypeHandler</code>，这两个接口都可以加具体的泛型，泛型的类型即是转换的Java类型，下面的例子是关于Money和Long之间的转换</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.BaseTypeHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.type.JdbcType;</span><br><span class="line"><span class="keyword">import</span> org.joda.money.CurrencyUnit;</span><br><span class="line"><span class="keyword">import</span> org.joda.money.Money;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 再Money与Long之间转换的TypeHandler，处理CNY人民币</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">Money</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i, Money money, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//插入数据时，把Money类型转换成Long，精确到分</span></span><br><span class="line">        preparedStatement.setLong(i, money.getAmountMinorLong());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseMoney(resultSet.getLong(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Money <span class="title">parseMoney</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Money.of(CurrencyUnit.of(<span class="string">"CNY"</span>), value/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//获取数据时，把Long转换成Money</span></span><br><span class="line">        <span class="keyword">return</span> parseMoney(resultSet.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseMoney(callableStatement.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注册转换器：在application.yml中进行注册</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">type-handlers-package:com.xxx.handler</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p>参考资料:<a href="https://www.bilibili.com/video/BV1NE411Q7Nx?p=3" target="_blank" rel="noopener">B站狂神</a></p>
]]></content>
      <categories>
        <category>-MyBatis</category>
      </categories>
      <tags>
        <tag>-Java -MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——排序</title>
    <url>/2020/11/07/MySql%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><ul>
<li>创建一个表</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`city`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`addr`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`city`</span> (<span class="string">`city`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查询语句, 使用explain查看语句的执行情况</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可以看到Extra字段，它表示这个语句使用了哪些额外的辅助：<ol>
<li>【Using filesort】 本次查询语句中有order by，且排序依照的字段不在本次使用的索引中，不能自然有序。需要进行额外的排序工作。 </li>
<li>【Using index】 使用了索引</li>
<li>【Using index condition】 使用了索引下推技术ICP。</li>
<li>【Using where】 表示本次查询要进行筛选过滤。</li>
</ol>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/82/03/826579b63225def812330ef6c344a303.png" alt="img"></p>
<ul>
<li>MySql会为每个线程分配一块内存用于排序，称为sort_buffer，一般情况下，这个排序语句的执行流程如下：<ol>
<li>初始化sort_buffer，确认放入name、city、age这三个字段</li>
<li>从索引city找到第一个满足city=“杭州”条件的主键id。</li>
<li>到主键索引中取出整行，取name、city、age这三个字段，存入到sort_buffer中</li>
<li>从索引city取下一个记录的主键id</li>
<li>重复3、4步骤指定city的值不满足查询条件为止。</li>
<li>对sort_buffer中的数据按照name做快速排序</li>
<li>按照排序结构取前1000行返回给客户端</li>
</ol>
</li>
<li>sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</li>
<li>可以查看number_of_tmp_files参数来查看排序过程中使用的外部临时文件数（由于在外部排序使用的是归并排序，归并排序会把一个大文件分成多个小文件再有序合并，所以需要多个文件）。</li>
<li>排序就分成了两种情况：<ol>
<li>如果 sort_buffer_size 超过了需要排序的数据量的大小，number_of_tmp_files 就是 0，表示排序可以直接在内存中完成。</li>
<li>否则就需要放在临时文件中排序。sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files 的值就越大。</li>
</ol>
</li>
</ul>
<h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><ul>
<li>如果排序的单行长度太大，sorted_buffer中存储的行数就会很少，这就会导致外部排序需要的临时文件变多，这将会降低排序性能。这时就应该换另一个算法进行排序。</li>
<li>可以设置max_length_for_sort_data的值，它表示用于排序的行数据的长度，如果超出这个值，MySql就会换一个算法进行排序，这时它的执行流程是这样的：<ol>
<li>初始化 sort_buffer，确定放入两个字段，即 name 和 id；</li>
<li>从索引 city 找到第一个满足 city=’杭州’条件的主键 id</li>
<li>到主键 id 索引取出整行，取 name、id 这两个字段，存入 sort_buffer 中；</li>
<li>从索引 city 取下一个记录的主键 id；</li>
<li>重复步骤 3、4 直到不满足 city=’杭州’条件为止</li>
<li>对 sort_buffer 中的数据按照字段 name 进行排序；</li>
<li>遍历排序结果，取前 1000 行，并按照 id 的值回到原表中取出 city、name 和 age 三个字段返回给客户端。</li>
</ol>
</li>
</ul>
<h3 id="全字段排序-VS-rowid-排序"><a href="#全字段排序-VS-rowid-排序" class="headerlink" title="全字段排序 VS rowid 排序"></a>全字段排序 VS rowid 排序</h3><ul>
<li>如果 MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</li>
<li>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</li>
<li>这也就体现了 MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。</li>
</ul>
<h3 id="创建索引来简化排序"><a href="#创建索引来简化排序" class="headerlink" title="创建索引来简化排序"></a>创建索引来简化排序</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user(city, <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>其实可以创建一个(city、name)的联合索引，当我们通过这个索引找到杭州时，name在city=“杭州”这个子集中就是有序的，整个过程如下：<ol>
<li>从索引 (city,name) 找到第一个满足 city=’杭州’条件的主键 id；</li>
<li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，作为结果集的一部分直接返回</li>
<li>；从索引 (city,name) 取下一个记录主键 id；</li>
<li>重复步骤 2、3，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li>
</ol>
</li>
<li>使用索引就不需要进行排序和临时表了，而且只需要扫描前1000行。但是还是需要回表操作</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><ul>
<li>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</li>
<li>所以针对上面的查询语句，我们创建一个city、name和age的联合索引，对应Sql语句</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> <span class="keyword">index</span> city_user_age(city, <span class="keyword">name</span>, age);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这时，整个查询过程：<ol>
<li>从索引 (city,name,age) 找到第一个满足 city=’杭州’条件的记录，取出其中的 city、name 和 age 这三个字段的值，作为结果集的一部分直接返回；</li>
<li>从索引 (city,name,age) 取下一个记录，同样取出这三个字段的值，作为结果集的一部分直接返回；</li>
<li>重复执行步骤 2，直到查到第 1000 条记录，或者是不满足 city=’杭州’条件时循环结束。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——幻读</title>
    <url>/2020/11/08/MySql%E2%80%94%E2%80%94%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><ul>
<li>所谓幻读，就是指一个事务在前后两次查询同一个范围的时候，后一次查询看到的前一次查询没有看到的行。</li>
<li>我们来看这样一个场景：创建一个表</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当执行下面语句时，会命中d=5这一行，并给改行加一个写锁，由于两阶段锁协议，这个锁会在执行commit语句的时候释放。</li>
<li>由于字段d上没有索引，因此这条语句会做全表扫描。其他被扫描到的，但是不满足d=5这个条件的，会不会加上锁呢？</li>
<li>比如执行下面的事务：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/5b/8b/5bc506e5884d21844126d26bbe6fa68b.png" alt="img"></p>
<ul>
<li>在读未提交的隔离级别下，上面sessionA在前后执行查询语句时，返回的结果并不相同，而这种多出几行的现象，被称为幻读</li>
<li>在可重复读隔离级别下，普通的查询都是快照读，是不会看到别的事务插入的数据的，因此，幻读只会在当前都下才会出现。</li>
<li>需要注意的是，在T2中sessionB的修改结果被sessionA之后的查询语句用“当前读”看到，并不能称为幻读，幻读仅专指“新插入的行”。</li>
</ul>
<h3 id="幻读有什么问题"><a href="#幻读有什么问题" class="headerlink" title="幻读有什么问题"></a>幻读有什么问题</h3><ul>
<li><p>从语义上，sessionA在T1时刻就声明了，要把所有的d=5的行锁住，不准别的事务进行读写操作，但事实上，按照上面的逻辑，这个语义被破坏了。</p>
</li>
<li><p>其次，幻读会导致数据不一致问题，锁的设计是为了保证数据的一致性，而这个一致性，不止是数据库内部数据状态在此刻的一致性，还包括了数据和日志在逻辑上的一致性。</p>
</li>
<li><p>举个例子：执行下面的事务：</p>
<p><img src="https://static001.geekbang.org/resource/image/dc/92/dcea7845ff0bdbee2622bf3c67d31d92.png" alt="img"></p>
</li>
<li><p>如果update和select…for update是一致的话，只会在d=5的语句加锁，那三个事务的执行过程如下：</p>
<ol>
<li>经过 T1 时刻，id=5 这一行变成 (5,5,100)，当然这个结果最终是在 T6 时刻正式提交的 ;</li>
<li>经过 T2 时刻，id=0 这一行变成 (0,5,5);</li>
<li>经过 T4 时刻，表里面多了一行 (1,5,5);</li>
<li>其他行跟这个执行序列无关，保持不变</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/dc/92/dcea7845ff0bdbee2622bf3c67d31d92.png" alt="img"></p>
</li>
<li><p>这样看的话，这些数据并没有什么问题，但来看看binlog中记录的内容：</p>
<ol>
<li>T2 时刻，session B 事务提交，写入了两条语句；</li>
<li>T4 时刻，session C 事务提交，写入了两条语句；</li>
<li>T6 时刻，session A 事务提交，写入了 update t set d=100 where d=5 这条语句。</li>
</ol>
</li>
<li><p>也就是下面这样：</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>当我们拿这个binlog去备库时，这三行的结果，都变成了 (0,5,100)、(1,5,100) 和 (5,5,100)。</li>
<li>也就是说，id=0和id=1发生了数据不一致的问题。</li>
</ul>
<h3 id="幻读问题如何解决"><a href="#幻读问题如何解决" class="headerlink" title="幻读问题如何解决"></a>幻读问题如何解决</h3><h4 id="锁住所有行"><a href="#锁住所有行" class="headerlink" title="锁住所有行"></a>锁住所有行</h4><ul>
<li>其实只需要把扫描过程中遇到的行都加上写锁，由于sessionA把所有的行都加上写锁，需要在T6时刻提交事务后，sessionB才能执行，在binlog里的记录就会变成这样：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>); <span class="comment">/*(1,1,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">/*(1,5,5)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">100</span> <span class="keyword">where</span> d=<span class="number">5</span>;<span class="comment">/*所有d=5的行，d改成100*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> d=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,0,5)*/</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">0</span>; <span class="comment">/*(0,5,5)*/</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>由于id=1这一行是新插入的，所以在sessionA加上写锁时，并没有对id=1这一行加上锁，这就导致了写入binlog时，id=1这一行的修改是在<code>update t set d=100 where d=5;</code>之前的，即id=1的数据不一致问题并没有得到解决。</li>
</ul>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><ul>
<li><p>现在我们知道了，产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的间隙。因此，为了解决幻读问题，InnoDB只好引入了间隙锁。</p>
</li>
<li><p>顾名思义，间隙锁，锁的就是两个值之间的空隙。比如文章开头的表 t，初始化插入了 6 个记录，这就产生了 7 个间隙。</p>
<p><img src="https://static001.geekbang.org/resource/image/e7/61/e7f7ca0d3dab2f48c588d714ee3ac861.png" alt="img"></p>
</li>
<li><p>这样，当你执行 select * from t where d=5 for update 的时候，就不止是给数据库中已有的 6 个记录加上了行锁，还同时加了 7 个间隙锁。这样就确保了无法再插入新的记录。</p>
</li>
<li><p>也就是说这时候，在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p>
</li>
<li><p>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。</p>
</li>
<li><p>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。也就是说，我们的表 t 初始化以后，如果用 select * from t for update 要把整个表所有记录锁起来，就形成了 7 个 next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +supremum]。</p>
</li>
<li><p>另外，间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</p>
</li>
<li><p>所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。但同时，你要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row。这，也是现在不少公司使用的配置组合。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——索引（上）</title>
    <url>/2020/11/08/MySql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h3 id="何为索引"><a href="#何为索引" class="headerlink" title="何为索引"></a>何为索引</h3><ul>
<li>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。</li>
<li>但是实现索引的方式却有很多种，有三种常见且简单的数据结构，它们分别是哈希表、有序数组和搜索树</li>
<li>这里只说以下使用场景，哈希表索引适用于只有等值查询的场景，对于范围查询并不适用。</li>
<li>而有序数组在等职查询和范围查询场景中性能都非常优秀，但是有序数组在插入和删除数据时，需要挪动大量的数据，比较耗时，所以有序数组索引只适用于静态存储引擎。</li>
<li>二叉搜索树的特点是：父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/04/68/04fb9d24065635a6a637c25ba9ddde68.png" alt="img"></p>
<ul>
<li>为了维持O(logn)的时间复杂度，需要保持这棵树的平衡性，为了达到这个保证，更新的时间复杂度也是O(logn)。</li>
<li>但是二叉搜索树每一层存储的结点并不多，这就会导致树高较大，而索引不仅是要存在内存中的，还要存储在磁盘中的，这就会导致磁盘中每次需要查找一个结点时，从磁盘随机读取一个数据块的次数较多（树高较大的情况）。</li>
<li>举个例子，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</li>
<li>所以，为了让一个查询尽量少地读磁盘，就不应该使用二叉树，而是要使用N叉树，这里的N取决于数据块的大小。以InnoDB的一个整数字段索引为例，这个N大概为1200，如果一棵树树高为4的话，就可以村1200的3次方，也就是17亿，这时，查找一个数据最多只需要访问3次磁盘（甚至更少），大大提高了访问速度。</li>
<li>数据库技术发展到今天，跳表、LSM 树等数据结构也被用于引擎设计中，这里我就不再一一赘述。</li>
</ul>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><ul>
<li>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。每一个索引在 InnoDB 里面对应一棵 B+ 树。</li>
<li>假设，有一个主键为id的表，表中有字段k，并且在k上有索引。则这个表的建表语句是：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span> (k)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>表中 R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p>
<ul>
<li>根据叶节点的内容，索引类型分为主键索引（聚簇索引）和非主键索引（二级索引）。</li>
</ul>
<blockquote>
<p>这两种索引的区别是：</p>
<ol>
<li>如果语句是<code>select * from t where id=500</code>，就会使用主键索引；</li>
<li>如果语句是<code>select * from t where k=5</code>，就会使用非主键索引，需要先搜索k索引树，得到id的值为500，再到id索引树搜索一次，这个过程称为回表。</li>
</ol>
</blockquote>
<ul>
<li>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</li>
</ul>
<h3 id="索引的维护"><a href="#索引的维护" class="headerlink" title="索引的维护"></a>索引的维护</h3><ul>
<li>为了维护索引树的有序性，需要再插入和删除操作做必要的维护，在InnoDB中，每一个B+树的子节点为一个数据页，而数据页的默认大小是16KB。</li>
<li>以上图为例，如果插入的新行id值为700，则只需要在R5后面插入一个新记录，而如果新插入的值为400，就会比较麻烦，需要逻辑上挪动后面的数据，空出位置。</li>
<li>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</li>
<li>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</li>
<li>这里利用率降低50%的原因是，为了避免每次插入时都会挪动数据，InnoDB并不会去填满每个数据页，它会留有一小部分的空间以防下一次的插入，而这些空间就称为数据页的空洞。</li>
<li>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</li>
<li>所以，为了保证不会在数据的中间插入数据，可以将主键设置为自增模式，在建表语句中一般是这么定义的： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code>。</li>
<li>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</li>
<li>还有一个选择索引原则：主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。所以，一般不会用业务字段去作为索引，这样做也不能保证索引的有序性。</li>
<li>使用业务字段做索引的情况：<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——日志系统</title>
    <url>/2020/11/07/MySql%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p><img src="https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img"></p>
<ul>
<li>连接器：管理链接，权限验证</li>
<li>查询缓存：命中则直接返回结果</li>
<li>分析器：词法分析、语法分析</li>
<li>优化器：语句执行计划生成、索引选择</li>
<li>执行器：操作引擎，返回结果</li>
<li>存储引擎：存储数据，提供读写接口</li>
</ul>
<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><ul>
<li>redo log（重做日志）：当有一条记录需要更新时，InnoDB引擎会先把记录写到redo log，并更新内存，当innodb有空闲的时候会做这个更新</li>
<li>bin log（归档日志）：是用来做数据库备份的，当你需要恢复数据库时，可以使用binlog恢复临时库，再把表数据从临时库取出来，按需要恢复到线上库。</li>
<li>两阶段提交：在写入redo log时会将redo log的状态改为prepare状态，然后再进行写bin log，之后提交事务，会把redo log的状态改为commit状态，这就叫两阶段提交。<ul>
<li>引入两阶段提交的目的是为了让两份日志之间的逻辑一致，即避免系统崩溃，数据丢失的情况。</li>
</ul>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img"></p>
<ul>
<li>而日志有的时候可以一天一备或一周一备，这个各有好处。</li>
<li>把innodb_flush_log_at_trx_commit这个参数设置为1时，表示每次的redo log都会持久化到磁盘，而sync_binlog这个参数设置为1时，可以保证MySql异常重启binlog不会丢失。</li>
</ul>
<h3 id="日志的类型"><a href="#日志的类型" class="headerlink" title="日志的类型"></a>日志的类型</h3><ul>
<li>MySql的日志类型分为物理日志和逻辑日志，物理日志存储了数据被修改的值，而逻辑日志存储了逻辑Sql修改语句，redolog是物理日志，而binlog是逻辑日志</li>
</ul>
<h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><ul>
<li>redolog是物理日志，物理日志存储的是数据被修改的值，所以在使用redolog来恢复数据库时，恢复的速度远超过逻辑日志。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg" alt="img"></p>
<ul>
<li>cp（checkpoint）：表示使用redolog flush的起始位置，checkpoint所做的事就是把脏页给刷新回磁盘。所以，当DB重启恢复时，只需要恢复checkpoint之后的数据。这样就能大大缩短恢复时间。</li>
<li>write pos：数据写入redolog的位置，当redolog的write pos接近cp时，表示redolog要满了，这时InnoDB必须停下手中的工作，进行刷脏页，腾出一些空余空间才能继续写redolog。</li>
<li>redolog其实分为两个部分：<ol>
<li>重做日志缓冲(redo log buffer)，这部分内容存在于内存中。</li>
<li>重做日志文件(redo log file)。这部分内容存在于磁盘中。</li>
</ol>
</li>
<li>这样的设计同样也是为了调和内存与磁盘的速度差异。InnoDB写入磁盘的策略可以通过<code>innodb_flush_log_at_trx_commit</code>这个参数来控制。fsync表示redolog写入磁盘操作</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/11512754-e4090b96f2184e04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp" alt="img"></p>
<ul>
<li>当该值为1时，当然是最安全的，但是数据库性能会受一定影响；为0时性能较好，但是会丢失掉master thread还没刷新进磁盘部分的数据。</li>
<li>master thread：这是InnoDB一个在后台运行的主线程，它做的主要工作包括但不限于：刷新日志缓冲，合并插入缓冲，刷新脏页等。</li>
<li>master thread大致分为每秒运行一次的操作和每10秒运行一次的操作。master thread中刷新数据，属于checkpoint的一种。所以如果在master thread在刷新日志的间隙，DB出现故障那么将丢失掉这部分数据。</li>
</ul>
<h3 id="binlog的模式"><a href="#binlog的模式" class="headerlink" title="binlog的模式"></a>binlog的模式</h3><ul>
<li>mysql复制主要有三种方式：基于SQL语句的复制(statement-based replication, SBR)，基于行的复制(row-based replication, RBR)，混合模式复制(mixed-based replication, MBR)。对应的，binlog的格式也有三种：STATEMENT，ROW，MIXED。</li>
</ul>
<h4 id="STATEMENT模式（SBR）"><a href="#STATEMENT模式（SBR）" class="headerlink" title="STATEMENT模式（SBR）"></a>STATEMENT模式（SBR）</h4><ul>
<li>每一条会修改数据的sql语句会记录到binlog中。优点是并不需要记录每一条sql语句和每一行的数据变化，减少了binlog日志量，节约IO，提高性能。缺点是在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)</li>
</ul>
<h4 id="ROW模式（RBR）"><a href="#ROW模式（RBR）" class="headerlink" title="ROW模式（RBR）"></a>ROW模式（RBR）</h4><ul>
<li>不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了，修改成什么样了。而且不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题。缺点是会产生大量的日志，尤其是alter table的时候会让日志暴涨。</li>
</ul>
<h4 id="MIXED模式（MBR）"><a href="#MIXED模式（MBR）" class="headerlink" title="MIXED模式（MBR）"></a>MIXED模式（MBR）</h4><ul>
<li>以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式。</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——索引（下）</title>
    <url>/2020/11/08/MySql%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul>
<li>上一节我们说了，使用二级索引需要回表，回表需要访问多一次磁盘，那有什么办法减少回表的次数呢？</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p>
<ul>
<li>覆盖索引是指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取（回表）。</li>
<li>如果执行语句不是以<code>select * ...</code>开头的，而是<code>select id from t where k=5</code>，则这个查询可以直接在k索引树上直接返回id，并不需要回表，这样可以显著地提高查询性能，所以使用覆盖索引是一个常见地性能优化手段。</li>
</ul>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><ul>
<li>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</li>
<li>假设这个市民表的定义如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tuser`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`id_card`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ismale`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_age`</span> (<span class="string">`id_card`</span>, <span class="string">`name`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name`</span> (<span class="string">`name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果现在有一个高频的请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</li>
</ul>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><ul>
<li>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费，但总不能让它走全表扫描吧</li>
<li>这时，就可以使用索引的最左前缀，来减少索引的存储空间。</li>
<li>最左前缀的含义是：索引的匹配原则会按照前几个字符进行模糊匹配，这里多少个字符要依据业务需求来确定。</li>
<li>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</li>
<li>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</li>
</ul>
<h3 id="评估标准"><a href="#评估标准" class="headerlink" title="评估标准"></a>评估标准</h3><ul>
<li>评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</li>
<li>如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</li>
<li>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><ul>
<li><p>当要执行这句语句<code>select * from tuser where name like &#39;张%&#39; and age=10 and ismale=1;</code></p>
</li>
<li><p>所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。然后呢？当然是判断其他条件是否满足。</p>
</li>
<li><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p><img src="https://static001.geekbang.org/resource/image/76/1b/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img"></p>
</li>
<li><p>这时，回表的次数就会从4次降到了2次。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——脏页刷新</title>
    <url>/2020/11/07/MySql%E2%80%94%E2%80%94%E8%84%8F%E9%A1%B5%E5%88%B7%E6%96%B0/</url>
    <content><![CDATA[<h3 id="为什么你的Sql语句变慢了？"><a href="#为什么你的Sql语句变慢了？" class="headerlink" title="为什么你的Sql语句变慢了？"></a>为什么你的Sql语句变慢了？</h3><ul>
<li><p>当内存数据页和磁盘数据页内容不一致的时候，称这个内存页为脏页。</p>
</li>
<li><p>内存数据写入到磁盘后，内存和磁盘上的数据页内容就一致了，称为干净页。</p>
</li>
<li><p>而将脏页的数据写入到磁盘的过程叫做flush。平时执行很快的更新操作，其实就是在写内存和日志，而MySql偶尔执行语句时变慢，是有可能在刷脏页。</p>
</li>
<li><p>以下有四种情况InnoDB会进行刷脏页：</p>
<ol>
<li><p>redolog写满了，记不下了。这时候系统会停止所有更新操作，把checkpoint往前推进，让redolog可以留出空间继续写，而往前推进的过程中就需要把对应的没有写入磁盘的脏页写到磁盘中去。</p>
<p><img src="https://static001.geekbang.org/resource/image/a2/e5/a25bdbbfc2cfc5d5e20690547fe7f2e5.jpg" alt="img"></p>
</li>
<li><p>当需要新的内存页，而内存不够用时，就需要淘汰掉一些数据页，空出内存给别的数据页使用，如果淘汰点的是脏页，就要先将脏页写到磁盘。</p>
</li>
<li><p>当MySql认为系统空闲时，就会去刷脏页，当然当系统不空闲时，也会在零碎的空闲片段去刷脏页。</p>
</li>
<li><p>当MySql正常关闭时，MySql就会把内存中的脏页flush到磁盘上。</p>
</li>
</ol>
</li>
</ul>
<h3 id="InnoDB刷脏页的控制策略"><a href="#InnoDB刷脏页的控制策略" class="headerlink" title="InnoDB刷脏页的控制策略"></a>InnoDB刷脏页的控制策略</h3><ul>
<li><p>需要告诉InnoDB所在主机的IO能力，可以设置innodb_io_capacity这个参数，一般都是IOPS的值</p>
</li>
<li><p>可以设置innodb_max_dirty_pages_pct的值M，它表示了脏页占内存的最大比例，默认是75%。</p>
</li>
<li><p>而对于redolog，InnoDB每次写入日志都有一个序号，当前写入的序号和cp对应序号之间的差值为N，利用N算出一个比例，它表示了redolog所能写入内容的最大比例。</p>
</li>
<li><p>然后在M和N中去较大值R，以innodb_io_capacity的值乘以R%来控制刷脏页的速度。</p>
<p><img src="https://static001.geekbang.org/resource/image/cc/74/cc44c1d080141aa50df6a91067475374.png" alt="img"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——隔离级别</title>
    <url>/2020/11/07/MySql%E2%80%94%E2%80%94%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li><p>当有多个事务同时执行时，就可能出现下面几种情况：</p>
<ol>
<li>脏读：对于两个事务T1与T2，T1读取了已经被T2更新但是还没有提交的字段之后，若此时T2回滚，T1读取的内容就是临时并且无效的</li>
<li>不可重复读：对于两个事务T1和T2，T1读取了一个字段，然后T2更新了该字段并提交之后，T1再次提取同一个字段，值便不相等了。</li>
<li>幻读：对于两个事务T1、T2，T1从表中读取数据，然后T2进行了INSERT操作并提交，当T1’再次读取的时候，结果不一致的情况发生。</li>
</ol>
</li>
<li><p>解决这些问题的方法：</p>
<ol>
<li>读未提交：表示一个事务还没有提交时，它做的变更是可以被其他事务看到。</li>
<li>读提交：表示一个事务只有在提交后，它做的表更才可以被其他事务看到。</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务启动时看到的数据是一致的。</li>
<li>串行化：写数据会加写锁，读会加读锁。当出现读写锁冲突时，后访问的事务必须等前一个事务执行完成后才可以执行。</li>
</ol>
</li>
<li><p>读提交和可重复读的实现就需要借助视图（read view），视图中存储着事务需要使用数据版本，视图和数据版本的关系如下：对于一个事务视图来说，除了自己的更新总是对自己可见外，对其他的事务：</p>
<ol>
<li>数据版本未提交，不可见</li>
<li>数据版本已提交，但是是在视图创建后提交的，不可见</li>
<li>数据版本已提交，而且是在视图创建前提交的，可见</li>
</ol>
</li>
<li><p>可重复读会在事务开启时创建一个视图，之后读数据时会在这个视图中取数据，而在整个事务的过程中视图里面的数据版本是不会改变的，所以可重复读就可以保证在一个事务里读到的数据是一致的，这个叫做一致性读。</p>
</li>
<li><p>而读提交会在每一行Sql语句开始执行的时候创建视图，当其他事务在Sql语句执行前提交了事务版本，那该事务提交的版本对原本事务来说是可见的。</p>
</li>
<li><p>其实<code>begin/start transaction</code>命令并不是一个事务的起点，只有当执行它们后的第一个操作语句的时候，事务才会真正地启动。想要马上启动事务的语句<code>start transaction with consistent snapshot</code></p>
</li>
<li><p>设置事务的隔离级别语句是：<code>set session transaction isolation level [隔离级别](read uncommitted|read committed|repeatable read|serializable)</code></p>
</li>
<li><p>默认提交语句<code>autocommit=1</code></p>
</li>
<li><p>其实在MySql里有两种视图地概念：</p>
<ol>
<li>一个是“view”，普通的视图，创建视图的语法<code>create view...</code>。</li>
<li>一个是“read view”，是InnoDB在实现MVCC（多版本并发控制）时用到地一致性读视图，用于支持RC和RR的实现。</li>
</ol>
</li>
</ul>
<h3 id="快照或数据版本在MVCC中是怎么工作的？"><a href="#快照或数据版本在MVCC中是怎么工作的？" class="headerlink" title="快照或数据版本在MVCC中是怎么工作的？"></a>快照或数据版本在MVCC中是怎么工作的？</h3><ul>
<li>InnoDB里每一个事务都有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，并按照申请的顺序严格递增。</li>
<li>每行数据都是有多个版本的。每次事务更新数据时，都会生成一个新的数据版本，并把transaction id赋给这个数据版本的事务ID，叫做row trx_id。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/68/ed/68d08d277a6f7926a41cc5541d3dfced.png" alt="img"></p>
<ul>
<li>其实V1、V2、V3这三个数据版本并不是物理上真实存在的，二十每次需要的时候根据当前版本和undo log计算出来的。图中的虚线代表了undo log（回滚日志）。</li>
<li>而在实现数据的可见性的时候，InnoDB会为每个事务构造一个数组，用来保存这个事务启动的瞬间，当前启动了但还没有提交的事务ID，数组里事务ID的最小值记为低水位，而ID的最大值记为高水位。而视图数组和高水位就组成了当前事务的一致性视图。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" alt="img"></p>
<ul>
<li><p>这样对于当前事务的启动瞬间来说，一个数据版本的 trx_id，就有以下几种可能：</p>
<ol>
<li><p>如果落在绿色部分，表示这个版本是已经提交的事务或当前事务自己生成的，这个数据是可见的</p>
</li>
<li><p>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的</p>
</li>
<li><p>如果落在黄色部分，有两种情况：</p>
<p>a. 若这个trx_id在这个黄色区域，表示这个版本由还没有提交地事务生成，不可见。</p>
<p>b. 若这个trx_id不在这个黄色区域，表示这个版本是已经提交了的事务生成的，可见。</p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql——表的空间回收</title>
    <url>/2020/11/07/MySql%E2%80%94%E2%80%94%E8%A1%A8%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h3 id="表的存放"><a href="#表的存放" class="headerlink" title="表的存放"></a>表的存放</h3><ul>
<li>一个InnoDB表包含两个部分，即表结构定义和数据，表结构是存在以.frm为后缀的文件中的，在MySql8.0版本，则已经允许把表结构定义放在系统数据表中。</li>
<li>参数innodb_file_per_table：<ol>
<li>设置为off表示表的数据放在系统共享表空间，即跟数据字典放在一起</li>
<li>设置为on表示每个innodb表数据存储在一个以.ibd为后缀的文件中，从5.6.6版本开始，就默认为on了。</li>
</ol>
</li>
<li>设置为on的好处是，一个表单独存储为一个文件更容易管理，而如果放在共享表空间，即使表删掉了，空间也是不会回收的。</li>
</ul>
<h3 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h3><p><img src="https://static001.geekbang.org/resource/image/f0/c8/f0b1e4ac610bcb5c5922d0b18563f3c8.png" alt="img"></p>
<ul>
<li>假设，我们删除掉R4这个记录，InnoDB会把R4这个记录标记为删除，如果后面要再插入一个ID在300和600之间的记录时，可能就会服用这个位置，但磁盘文件的大小并不会缩小。</li>
<li>如果删除了一个数据页或者把整个表的数据都删除呢？答案是数据页或者所有的数据页会被标记为删除，比如把pageA删除，pageA会被标记为复用，当要插入一条ID=50的记录需要用到新页时，pageA可以被复用。</li>
<li>如果相邻两个数据页的利用率很小，系统就会把这两个页上的数据和到其中一个页上，另一个数据页就会被标记为可复用。</li>
<li>而这种标记为可复用的方式并不会使数据文件变小，所以delete命令是不能回收表空间的。实际上，不止是删除数据会造成这种情况，插入数据也会。</li>
</ul>
<h3 id="数据插入流程"><a href="#数据插入流程" class="headerlink" title="数据插入流程"></a>数据插入流程</h3><ul>
<li><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的，但如果数据是随机插入的可能就会造成索引的数据页分裂（由于MySql的数据页的固定大小是16KB）。</p>
</li>
<li><p>如果pageA已经满了，在插入一条数据就会出现如下情况：</p>
<p><img src="https://static001.geekbang.org/resource/image/80/ea/8083f05a4a4c0372833a6e01d5a8e6ea.png" alt="img"></p>
</li>
<li><p>这时就会申请一个新的页面pageB，但发生了数据页的分裂，导致pageA留下了数据空洞。</p>
</li>
<li><p>总之，经过大量的增删改的表，都是可能存在数据空洞的，如果能把这些空洞去掉，就能达到收缩表空间的目的。而重建表就可以达到这种目的。</p>
</li>
</ul>
<h3 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h3><ul>
<li><p>假如，你现在有一个表A，为了把表中存在的空洞去掉，你可以新建一个与表A结构相同的表B，然后按照主键ID递增的顺序，把数据一行行地从表A里读出来再插入到表B中。这样表B地主键索引会更紧凑，数据页利用率也比较高。可以使用<code>alter table A engine=InnoDB</code>命令来重建表。</p>
<p><img src="https://static001.geekbang.org/resource/image/02/cd/02e083adaec6e1191f54992f7bc13dcd.png" alt="img"></p>
</li>
<li><p>但是，在整个DDL地过程中，表A中不能有更新，不然就会导致数据的丢失，也就是说，这个DDL不是online的。</p>
</li>
<li><p>而在MySql5.6版本开始引入了OnlineDDL，对重建表这个过程做了优化，过程如下：</p>
<ol>
<li>建立一个临时文件，扫描表 A 主键的所有数据页；</li>
<li>用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；</li>
<li>生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中</li>
<li>临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件</li>
<li>用临时文件替换表 A 的数据文件。</li>
</ol>
<p><img src="https://static001.geekbang.org/resource/image/2d/f0/2d1cfbbeb013b851a56390d38b5321f0.png" alt="img"></p>
</li>
<li><p>这时就有一个疑惑，DDL 之前是要拿 MDL 写锁的，这样还能叫 Online DDL 吗？</p>
</li>
<li><p>确实，上图的流程中，alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。</p>
</li>
<li><p>为什么要退化呢？为了实现 Online，MDL 读锁不会阻塞增删改操作。那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做 DDL。</p>
</li>
<li><p>而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。</p>
</li>
<li><p>需要补充说明的是，上述的这些重建方法都会扫描原表数据和构建临时文件。对于很大的表来说，这个操作是很消耗 IO 和 CPU 资源的。因此，如果是线上服务，你要很小心地控制操作时间。如果想要比较安全的操作的话，我推荐你使用 GitHub 开源的 gh-ost 来做。</p>
</li>
</ul>
<h3 id="Online和Inplace"><a href="#Online和Inplace" class="headerlink" title="Online和Inplace"></a>Online和Inplace</h3><ul>
<li>说到 Online，我还要再和你澄清一下它和另一个跟 DDL 有关的、容易混淆的概念 inplace 的区别。</li>
<li>在重建表的第一张图中，我们把表 A 中的数据导出来的存放位置叫作 tmp_table。这是一个临时表，是在 server 层创建的。</li>
<li>在重建表的第二张图中，根据表 A 重建出来的数据是放在“tmp_file”里的，这个临时文件是 InnoDB 在内部创建出来的。整个 DDL 过程都在 InnoDB 内部完成。对于 server 层来说，没有把数据挪动到临时表，是一个“原地”操作，这就是“inplace”名称的来源。</li>
<li>所以，我现在问你，如果你有一个 1TB 的表，现在磁盘间是 1.2TB，能不能做一个 inplace 的 DDL 呢？答案是不能。因为，tmp_file 也是要占用临时空间的。</li>
<li>我们重建表的这个语句 alter table t engine=InnoDB，其实隐含的意思是：<code>alter table t engine=innodb,ALGORITHM=inplace;</code></li>
<li>跟 inplace 对应的就是拷贝表的方式了，用法是：<code>alter table t engine=innodb,ALGORITHM=copy;</code>当你使用 ALGORITHM=copy 的时候，表示的是强制拷贝表，对应的流程就是重建表的第二张图的操作过程。</li>
</ul>
]]></content>
      <categories>
        <category>-MySql</category>
      </categories>
      <tags>
        <tag>-MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt连接SQL Server数据库</title>
    <url>/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="创建SQL-Server身份验证的登录用户"><a href="#创建SQL-Server身份验证的登录用户" class="headerlink" title="创建SQL Server身份验证的登录用户"></a>创建SQL Server身份验证的登录用户</h3><ol>
<li><p>用Windows身份登录，点击安全性中的登录名,新建登录名。</p>
</li>
<li><p>输入登录名后选择SQL Server身份验证设置密码（注意：取消强制实施密码策略）。<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/1.PNG" alt="创建登录名"></p>
</li>
<li><p>然后点击左边的用户映射选择你要连接的数据库，然后选择下面的成员身份db_datareader、db_datawriter、db_ddladmin和db_owner,点击确定。<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/2.PNG" alt="选择数据库"></p>
</li>
<li><p>设置服务器属性的安全性，服务器身份验证为SQL Server和Windows身份验证模式。<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/3.PNG" alt="设置验证模式"></p>
</li>
<li><p>重新启动数据库。</p>
</li>
</ol>
<ul>
<li>数据库方面已经设置好了，接下来设置ODBC。</li>
</ul>
<h3 id="配置ODBC"><a href="#配置ODBC" class="headerlink" title="配置ODBC"></a>配置ODBC</h3><ol>
<li>打开ODBC，在用户DSN中点击添加数据源，选择SQL Server，点击完成<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/4.PNG" alt="添加数据源"></li>
<li>填写数据源的名称、描述和服务器，服务器就是你登录SQL Server的服务器名称，点击下一步<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/5.PNG" alt="填写数据源信息"></li>
<li>选择SQL Server验证，输入数据库用户名和密码，点击下一步<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/6.PNG" alt="填写数据源信息"></li>
<li>选择连接的数据库，点下一步测试数据源，测试成功后完成ODBC的配置<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/7.PNG" alt="填写数据源信息"></li>
</ol>
<h3 id="Qt部分"><a href="#Qt部分" class="headerlink" title="Qt部分"></a>Qt部分</h3><ol>
<li><p>创建一个项目，选择widget application即可，类选择QWidget</p>
</li>
<li><p>项目创建成功后，先在.Pro文件中加入sql模块<br><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/8.PNG" alt="填写数据源信息"></p>
<p> 在qt中提供了多种数据驱动，可以使用qDebug() &lt;&lt; QSqlDatabase::drivers()来打印qt支持的数据驱动，然后在类的.cpp文件中加入下列代码:</p>
 <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">#include &quot;widget.h&quot;</span><br><span class="line">#include &quot;ui_widget.h&quot;</span><br><span class="line">#include &lt;QSqlDatabase&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line">#include &lt;QMessageBox&gt;</span><br><span class="line">#include &lt;QSqlError&gt;</span><br><span class="line">#include &lt;QSqlQuery&gt;</span><br><span class="line">   </span><br><span class="line">Widget::Widget(QWidget *parent) :</span><br><span class="line">    QWidget(parent),</span><br><span class="line">    ui(new Ui::Widget)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;打印支持的数据驱动</span><br><span class="line">    qDebug() &lt;&lt; QSqlDatabase::drivers();</span><br><span class="line">    &#x2F;&#x2F;创建数据库对象,参数为数据驱动，在这里我们是ODBC</span><br><span class="line">    QSqlDatabase db &#x3D; QSqlDatabase::addDatabase(&quot;QODBC&quot;);</span><br><span class="line">    &#x2F;&#x2F;获取dsn名称</span><br><span class="line">    QString dsn &#x3D; QString::fromLocal8Bit(&quot;Sqlodbc2&quot;);</span><br><span class="line">    &#x2F;&#x2F;设置主机名，即电脑名</span><br><span class="line">    db.setHostName(&quot;DESKTOP-J7VJSE6&quot;);</span><br><span class="line">    &#x2F;&#x2F;设置数据库名，在这里我们用odbc间接连接数据库，所以用dsn</span><br><span class="line">    db.setDatabaseName(dsn);</span><br><span class="line">    &#x2F;&#x2F;设置数据库用户名</span><br><span class="line">    db.setUserName(&quot;user_c&quot;);</span><br><span class="line">    &#x2F;&#x2F;设置用户密码</span><br><span class="line">    db.setPassword(&quot;532133921&quot;);</span><br><span class="line">    &#x2F;&#x2F;打开数据库</span><br><span class="line">    if(!db.open())</span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::warning(this, &quot;错误&quot;, db.lastError().text());</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        qDebug()&lt;&lt;&quot;database open success!&quot;;</span><br><span class="line">        &#x2F;&#x2F;query可以实现对数据库的操作</span><br><span class="line">        QSqlQuery query(db); &#x2F;&#x2F;查询Card表并输出，测试能否正常操作数据库</span><br><span class="line">        &#x2F;&#x2F;exec执行制定的sql语句</span><br><span class="line">        query.exec(&quot;select * from J&quot;);</span><br><span class="line">        while(query.next())&#x2F;&#x2F;query.next()获取某表中下一行的内容</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;取出当前行的内容，value(n)n表示第n个属性,也可以用属性名进行指定</span><br><span class="line">            qDebug() &lt;&lt; query.value(0).toString()</span><br><span class="line">                    &lt;&lt; query.value(1).toString()</span><br><span class="line">                    &lt;&lt; query.value(2).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>点击运行，就可以看到输出框输出了数据库ShiYan的内容</p>
</li>
</ol>
<p><img src="/2019/09/09/Qt%E8%BF%9E%E6%8E%A5SQLServer%E6%95%B0%E6%8D%AE%E5%BA%93/9.PNG" alt="运行"></p>
<hr>
<p>参考资料：<a href="https://blog.csdn.net/YJin_Woo/article/details/78821924" target="_blank" rel="noopener">CSDN</a></p>
]]></content>
      <categories>
        <category>-Qt</category>
      </categories>
      <tags>
        <tag>-SqlServer -Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>React——Ant整合</title>
    <url>/2020/07/10/React%E2%80%94%E2%80%94Ant%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h2 id="React-Ant整合"><a href="#React-Ant整合" class="headerlink" title="React-Ant整合"></a>React-Ant整合</h2><h3 id="UI组件库的引入"><a href="#UI组件库的引入" class="headerlink" title="UI组件库的引入"></a>UI组件库的引入</h3><ul>
<li>创建一个react项目，使用npm install antd –save安装Ant组件库</li>
<li>在index.js中引入css样式，在文件中就可以引入Ant的任意组件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> antd <span class="comment">--save</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'antd/dist/antd.css'</span>; <span class="comment">// or 'antd/dist/antd.less'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; DatePicker &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">DatePicker</span> /&gt;</span></span>, mountNode);</span><br></pre></td></tr></table></figure></div>

<h3 id="UI组件按需加载（使用babel-plugin）"><a href="#UI组件按需加载（使用babel-plugin）" class="headerlink" title="UI组件按需加载（使用babel-plugin）"></a>UI组件按需加载（使用babel-plugin）</h3><ul>
<li><p>有两种方法：第一种是手动按需加载、第二种是自动按需加载，在这只讲第二种。</p>
</li>
<li><p>执行npm run eject，如果执行后提示项目缺少文件，则可把项目文件中的隐藏git文件给删除，再执行命令</p>
</li>
<li><p>安装插件</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">npm run eject</span><br><span class="line">npm <span class="keyword">install</span> babel-<span class="keyword">plugin</span>-<span class="keyword">import</span> <span class="comment">--save-dev</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后再package.json中引入插件，并对插件进行配置</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"babel": &#123;</span><br><span class="line">    "presets": [</span><br><span class="line">      <span class="string">"react-app"</span></span><br><span class="line">    ],</span><br><span class="line">    "plugins": [</span><br><span class="line">      [<span class="string">"import"</span>, &#123;</span><br><span class="line">        <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>,</span><br><span class="line">        <span class="attr">"libraryDirectory"</span>: <span class="string">"es"</span>,</span><br><span class="line">        <span class="attr">"style"</span>: <span class="string">"css"</span></span><br><span class="line">      &#125;]</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置完之后，组件是以”antd/es/button”这个文件路径导入的，这个组件会更小、部分css样式文件也会自动导入，而不是导入全部css样式，这可以使项目避免加载一些没用的的样式，加载会更快。</li>
</ul>
]]></content>
      <categories>
        <category>-React</category>
      </categories>
      <tags>
        <tag>-React -JavaScript -AntDesign</tag>
      </tags>
  </entry>
  <entry>
    <title>React——Redux</title>
    <url>/2020/07/10/React%E2%80%94%E2%80%94Redux/</url>
    <content><![CDATA[<h2 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h2><h3 id="使用Redux"><a href="#使用Redux" class="headerlink" title="使用Redux"></a>使用Redux</h3><ul>
<li>安装</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="Q"><figure class="iseeu highlight /q"><table><tr><td class="code"><pre><span class="line">cnpm i --<span class="built_in">save</span>-<span class="built_in">dev</span> redux</span><br><span class="line">cnpm i --<span class="built_in">save</span>-<span class="built_in">dev</span> react-redux</span><br></pre></td></tr></table></figure></div>

<ul>
<li>redux和react-redux的区别<ol>
<li>redux：js的状态管理，createStore</li>
<li>react-redux：为了在react中更加容易地使用redux：connect、provider</li>
</ol>
</li>
</ul>
<h3 id="Redux的一些对象"><a href="#Redux的一些对象" class="headerlink" title="Redux的一些对象"></a>Redux的一些对象</h3><ol>
<li>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供<code>createStore</code>这个函数，用来生成 Store。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"><span class="comment">//上面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>State。<code>Store</code>对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前时刻的 State，可以通过store.getState()拿到。</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br><span class="line"><span class="comment">//Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>Action。State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置。</span></span><br><span class="line"><span class="comment">//action就类似于一个事件的参数，它告诉reducer数据应该如何改变，改变的大小是多少</span></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  num:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//也可以定义一个Action生成器</span></span><br><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'添加 TODO'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">'Learn Redux'</span>);</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>store.dispatch()。<code>store.dispatch()</code>是 View 发出 Action 的唯一方法。类似触发事件，Action为事件携带的事件参数。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'ADD_TODO'</span>,</span><br><span class="line">  payload: <span class="string">'Learn Redux'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li>Reducer。在执行完dispatch后，Action会被store截取并传入到reducer中，reducer定义了一系列的对state的逻辑处理，相当于事件处理器（Handler）state改变后，相对的View也会发生变化。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> new_state;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Reducer即可手动调用也可使用store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。</span></span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li><p>Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<ul>
<li>不得改写参数</li>
<li>不能调用系统 I/O 的API</li>
<li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>-React</category>
      </categories>
      <tags>
        <tag>-React -Redux -JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(1)——安装和主要功能</title>
    <url>/2020/07/19/Redis-1-%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>Redis（<a href="https://redis.io/）" target="_blank" rel="noopener">https://redis.io/）</a>, 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p>
<h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><p>我很少在开发机中直接装各种数据库，我一般使用Docker，针对Redis也不例外，我还是使用Docker。</p>
<p>这是Redis在DockerHub里的地址：<a href="https://hub.docker.com/_/redis，里面有文档。" target="_blank" rel="noopener">https://hub.docker.com/_/redis，里面有文档。</a></p>
<p>启动docker，下载redis镜像：<strong>docker pull redis</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119152205821-1628304056.png" alt="img"></p>
<p>然后运行镜像并发布端口6379：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119152833436-766058193.png" alt="img"></p>
<p>然后运行redis-cli（这是Redis的一个命令行管理工具）：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119153252949-1117117284.png" alt="img"></p>
<p>进入redis-cli之后，我们可以设置一个key-value来试试：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119153415161-1266286766.png" alt="img"></p>
<p>当你输入的时候，它是有提示的。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119153537379-1271834291.png" alt="img"></p>
<p>通过get key（key为name），可以获得其对应的值。</p>
<h1 id="Redis-的数据类型"><a href="#Redis-的数据类型" class="headerlink" title="Redis 的数据类型"></a>Redis 的数据类型</h1><p>Redis的主要数据类型有这些：</p>
<ul>
<li><strong>Key</strong>：就是key的意思。。。。</li>
<li><strong>String</strong>：字符串</li>
<li><strong>List</strong>：有序字符串的集合</li>
<li><strong>Hashes</strong>：有点像对象，里面可以有若干个字段，字段都有自己的值，字段和值都是字符串类型的。</li>
<li><strong>Set</strong>：无序唯一字符串的集合</li>
<li><strong>Sorted-Set</strong>：跟Set很像，但是每一个字符串元素都对应一个浮点数值，该数值叫做分数。它里面的元素通常是按照分数来排序的。</li>
</ul>
<h1 id="Redis-如何持久化"><a href="#Redis-如何持久化" class="headerlink" title="Redis 如何持久化"></a>Redis 如何持久化</h1><p>一共有两种方式：</p>
<ul>
<li><strong>AOF</strong>（Append-only file）</li>
<li><strong>RDB</strong>（Redis database file）</li>
</ul>
<p>首先需要知道Redis的操作都是在内存中完成的，因为这样速度快。</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>然后你可以启用AOF，它会把每个操作都记录到系统文件里。所以如果Redis服务器重启了，它会根据AOF这个文件来重建整个数据集。</p>
<p>这个文件会很快就变得很大，但是Redis很聪明，它会使用里面最新版本的数据，并压缩文件到可控大小。</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p><strong>RDB是Redis的默认模式</strong>，它有点像数据库的快照，创建一些时间点的数据，如果发生灾难，你可以从这些数据里进行恢复。</p>
<p>当达到一些条件的时候，例如数据集里面在某段时间内新添加了一定条目的数据，Redis就会把数据做个快照，并写入一个RDB文件。</p>
<p>最佳实践是两者都用，使用AOF因为其速度和可用性，使用RDB做灾难恢复。</p>
<h1 id="Redis的配置文件"><a href="#Redis的配置文件" class="headerlink" title="Redis的配置文件"></a>Redis的配置文件</h1><p><a href="https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf" target="_blank" rel="noopener">https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf</a> 这是Redis 4.0 的一个标准配置文件。</p>
<h2 id="RDB-快照相关"><a href="#RDB-快照相关" class="headerlink" title="RDB 快照相关"></a>RDB 快照相关</h2><p>先看快照部分，也就是和RDB有关的部分：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162047908-1083671578.png" alt="img"></p>
<p>里面的save 900 1.。。。这部分是指，900秒过后，如果至少1个key改变了，那么就做一个快照。</p>
<p>下面的就是300秒过后，如果10个key改变了，那就做一个快照。。。</p>
<p>这些就是进行快照动作的触发条件。</p>
<h2 id="AOF相关"><a href="#AOF相关" class="headerlink" title="AOF相关"></a>AOF相关</h2><p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162355691-1329808372.png" alt="img"></p>
<p>AOF模式默认是不开启的，也就是no。如果想开启，那就改成yes即可。</p>
<h1 id="使用自定义配置运行Redis容器"><a href="#使用自定义配置运行Redis容器" class="headerlink" title="使用自定义配置运行Redis容器"></a>使用自定义配置运行Redis容器</h1><h2 id="RDB-amp-AOF"><a href="#RDB-amp-AOF" class="headerlink" title="RDB &amp; AOF"></a>RDB &amp; AOF</h2><p>把上述文件下载到本地，进行修改：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162657924-2011410592.png" alt="img"></p>
<p>我添加了一个RDB的条件，5秒内1个Key被修改就会触发快照动作。</p>
<p>然后我启用了AOF：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162749434-1415511984.png" alt="img"></p>
<p>首先把之前的容器删除吧，然后再建立一个。</p>
<p>这次建立docker容器的时候需要使用volume：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119163226029-1228707194.png" alt="img"></p>
<p>说明一下：</p>
<p>-v这部分是指volume，redis.conf在我电脑里的位置是：D:\Projects\Redis\redis.conf，所以我把该位文件的位置挂载到了容器里的/usr/local/etc/redis/redis.conf这个地方。</p>
<p>然后运行redis这个镜像，同时运行里面的redis-server，而redis-server的配置文件就是/usr/local/etc/redis/redis.conf。</p>
<p>现在这个redis-server运行起来了。再打开一个redis-cli，还是使用容器：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119163624547-966861346.png" alt="img"></p>
<p>然后我设置一个key的值：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119163726639-173613670.png" alt="img"></p>
<p>这时就达到了RDB的最后一个条件，所以触发了快照动作。</p>
<p>我就不再实验了。。。</p>
<p>我再打开一下redis容器的bash，然后看一下aof文件是否生成：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190119164154849-88187453.png" alt="img"></p>
<p>可以看到每次操作后aof文件都会更新（里面可以认为就是事务的log）。</p>
<h2 id="Master-Slave-Replication-主从复制"><a href="#Master-Slave-Replication-主从复制" class="headerlink" title="Master-Slave Replication 主从复制"></a>Master-Slave Replication 主从复制</h2><p>简单讲一下Redis的主从复制，首先把之前的容器都删掉。。。</p>
<p>然后我们先建立docker 网络：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082332735-1613038954.png" alt="img"></p>
<p>然后创建redis master的容器，不过首先修改一下redis.conf里的bind地址，原来是127.0.0.1，改为 bind 0.0.0.0：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082604042-55273681.png" alt="img"></p>
<p>这样的话其它的ip地址也可以连接过来了。</p>
<p>然后创建master容器：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082427528-1597361401.png" alt="img"></p>
<p>注意里面使用了之前创建的桥接网络。</p>
<p>检查一下redis-net这个网络：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082720522-1007807008.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082742532-890791273.png" alt="img"></p>
<p>可以看到该网络里有一个容器master-redis，其ip为172.20.0.2。然后把redis.conf再复制一份，名字为redis2.conf。</p>
<p>在redis2.conf的Replication部分里，把下面这部分取消注释，并修改为：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082843903-2040589542.png" alt="img"></p>
<p>注意这个ip地址和master-redis的ip要一样。</p>
<p>现在我们可以运行这个redis的slave容器了：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083010654-1167831984.png" alt="img"></p>
<p>然后我们可以看到主从复制成功了：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083121050-140626447.png" alt="img"></p>
<p>打开master的redis-cli：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083225273-438999730.png" alt="img"></p>
<p>操作一些操作，可以看到master和slave都几乎同步的做了一些动作，也就是主从复制：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083412386-1633996245.png" alt="img"></p>
<h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>把之前的容器都清理掉。。。</p>
<p>主从复制的master通常需要设置密码，修改redis.conf文件，找到requirepass这部分，取消注释并设置密码：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120084828087-395741824.png" alt="img"></p>
<p>在slave的redis2.conf里，找到masterauth这部分，填写master的密码：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085123769-441763370.png" alt="img"></p>
<p>首先我填写一个错误的密码。然后运行两个容器，看看什么效果：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085214546-840757680.png" alt="img"></p>
<p>可以看到提示密码不正确，无法进行复制。然后删掉slave容器，再把redis2.conf的密码修正一下： </p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085026138-1967060461.png" alt="img"></p>
<p>然后再运行slave容器：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085408595-325516672.png" alt="img"></p>
<p>这次可以看到连接成功了。</p>
<h1 id="其它的配置方式"><a href="#其它的配置方式" class="headerlink" title="其它的配置方式"></a>其它的配置方式</h1><h2 id="redis-server的命令行参数"><a href="#redis-server的命令行参数" class="headerlink" title="redis-server的命令行参数"></a>redis-server的命令行参数</h2><p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120084145581-489989207.png" alt="img"></p>
<p>如上图，这就对port和replicaof进行配置，而没有使用redis2.conf（所以该命令前面的-v部分也是没有什么作用的）。</p>
<h2 id="CONFIG-SET"><a href="#CONFIG-SET" class="headerlink" title="CONFIG SET"></a>CONFIG SET</h2><p>前面我们使用了自定义的配置文件来运行Redis，但是这样的话需要重启Redis Server。</p>
<p>而如果使用CONFIG SET（<a href="https://redis.io/commands/config-set）的话，那就不需要重启redis" target="_blank" rel="noopener">https://redis.io/commands/config-set）的话，那就不需要重启redis</a> server直接就可以修改配置，但是这样做不会修改redis.conf等配置文件的。</p>
<p>首先需要使用redis-cli，然后进行配置即可，例如：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190120084456411-379058743.png" alt="img"></p>
<hr>
<p>本文转载于埼玉杨的博客：<a href="https://www.cnblogs.com/cgzl/p/10294175.html" target="_blank" rel="noopener">https://www.cnblogs.com/cgzl/p/10294175.html</a></p>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(2)——String</title>
    <url>/2020/07/20/Redis-2-%E2%80%94%E2%80%94String/</url>
    <content><![CDATA[<h1 id="再次准备Redis容器😂"><a href="#再次准备Redis容器😂" class="headerlink" title="再次准备Redis容器😂"></a>再次准备Redis容器😂</h1><p>我用docker，所以下载一个Redis 5的配置文件：<a href="https://raw.githubusercontent.com/antirez/redis/5.0/redis.conf" target="_blank" rel="noopener">https://raw.githubusercontent.com/antirez/redis/5.0/redis.conf</a></p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121124341877-964046839.png" alt="img"></p>
<p>bind的地址从127.0.0.1改为0.0.0.0，以便让其它地址可以连接。</p>
<p>顺便再设置一下启用密码：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121104107259-1077075656.png" alt="img"></p>
<p>然后运行容器：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121104140693-1534927852.png" alt="img"></p>
<p>运行redis-cli，并输入密码：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121105431576-1051842585.png" alt="img"></p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121112631915-1686309279.png" alt="img"></p>
<p>输入的时候都有一些智能提示。。。</p>
<h2 id="Set和Get"><a href="#Set和Get" class="headerlink" title="Set和Get"></a>Set和Get</h2><p>set的格式就是set key value。</p>
<p>get就是get key就会返回value。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121112746085-2146581970.png" alt="img"></p>
<p>这个也很简单不多说了。</p>
<p><strong>Set带空格的字符串值，</strong>这时候就需要使用双引号了，否则会出错： </p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121113558994-414812980.png" alt="img"></p>
<h2 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h2><p><strong>getset</strong>设置某个key-value，然后把设置<strong>之前</strong>的值返回来：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121113849538-619090111.png" alt="img"></p>
<p>注意取回来的是本次设置之前的值。。。毕竟get在前set在后。</p>
<h2 id="incr，incrby-和-decr，decrby"><a href="#incr，incrby-和-decr，decrby" class="headerlink" title="incr，incrby 和 decr，decrby"></a>incr，incrby 和 decr，decrby</h2><p>如果值是数值的话，那么可以使用<strong>incr</strong>，表示自增。</p>
<p>incr key就会对该key对应的value进行自增：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121112956780-627373475.png" alt="img"></p>
<p>默认的增量是1。</p>
<p>也可以指定增量，使用<strong>incrby</strong>这个命令。</p>
<p>格式是incrby key 增量值：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121113217908-645175329.png" alt="img"></p>
<p>相应的自减就是<strong>decr</strong>和<strong>decrby</strong>：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121113349909-359259324.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121113414679-219141944.png" alt="img"></p>
<h2 id="mset-和-mget"><a href="#mset-和-mget" class="headerlink" title="mset 和 mget"></a>mset 和 mget</h2><p><strong>mset</strong>一次设置多个key-value：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121114046614-723553476.png" alt="img"></p>
<p>按顺序，一对一对写即可。。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121114137685-1634041079.png" alt="img"></p>
<p>对应的<strong>mget</strong>就是一次获取多个key的value：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121114239093-1901518348.png" alt="img"></p>
<h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p><strong>exists</strong>判断key对应的值是否存在，格式为exists key：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121114421479-1272800730.png" alt="img"></p>
<p>返回1表示true，0表示false。</p>
<h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><p><strong>del</strong>可以删除Key：</p>
<p><strong><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121114636041-1297955797.png" alt="img"></strong></p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p><strong>type</strong>可以检查类型：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121115249706-1759816714.png" alt="img"></p>
<h2 id="expire，ex，ttl"><a href="#expire，ex，ttl" class="headerlink" title="expire，ex，ttl"></a>expire，ex，ttl</h2><p><strong>expire</strong>设置key的有效期，格式为expire key 时长(秒)：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121120124430-1295641729.png" alt="img"></p>
<p>使用<strong>ex</strong>的话，可以在设置key的时候直接设置有效期，格式为set key value ex 时长(秒)：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121120330101-1831117802.png" alt="img"></p>
<p>而<strong>ttl</strong>命令可以查看key还能存活多久：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190121120456822-894289842.png" alt="img"></p>
<p>ttl返回-2表示该key不存在。</p>
<p>ttl返回-1表示key存在，但是没有设置expire。</p>
<p>ttl返回非负数表示剩余的存活时长（秒）。</p>
<hr>
<p>本文转载于埼玉杨的博客：<a href="https://www.cnblogs.com/cgzl/p/10297565.html" target="_blank" rel="noopener">https://www.cnblogs.com/cgzl/p/10297565.html</a></p>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(3)——Hash</title>
    <url>/2020/07/20/Redis-3-%E2%80%94%E2%80%94Hash/</url>
    <content><![CDATA[<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Redis的<strong>Hash</strong>有点像一个对象（object），一个Hash里面可以存多个Key-Value对作为它的field，所以它通常可以用来表示对象。</p>
<p>Hash里面能存放的值也能作为String类型来存储，如果Hash里面值的类型可以解析为数字，那么也可以进行自增自减等操作。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122091441375-1429749456.png" alt="img"></p>
<h1 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h1><p><strong>Hash相关的命令都是以H开头</strong>。</p>
<h2 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h2><p><strong>HSET</strong> 设置Hash里面的值：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122092109819-1292833865.png" alt="img"></p>
<p>格式为：hset hash-key field1 field1value field2 field2value … </p>
<p>注：<strong>HMSET</strong>的功能和HSET貌似是一样的。</p>
<p>关于Hash的key的更实际用法是这样：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122092333607-209344986.png" alt="img"></p>
<p>通常在Hash的Key中使用冒号：，这样可以做出来类似命名空间的效果。</p>
<p>user:1000可以表示ID为1000的用户。</p>
<h2 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h2><p><strong>HGET</strong>通过Hash里面的key获取其对应的值：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122092703110-1220048586.png" alt="img"></p>
<h2 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h2><p>如果想获得Hash所有的Key-Value对，那就使用<strong>HGETALL</strong>：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122092910965-1892248560.png" alt="img"></p>
<p>注意其结果是如何显示的。</p>
<h2 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h2><p>HMSET可以设置Hash里多个Key的值，而<strong>HMGET</strong>可以通过Hash的多个Key获取其对应的值：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122093150263-676067965.png" alt="img"></p>
<p>但是它不会返回Key。</p>
<h2 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h2><p>如果Hash里某个Field值的类型可以解析成数值，那么还可以用<strong>HINCRBY</strong>来做自增：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190122093521412-1275399003.png" alt="img"></p>
<hr>
<p>本文转载于埼玉杨的博客：<a href="https://www.cnblogs.com/cgzl/p/10294175.html" target="_blank" rel="noopener">https://www.cnblogs.com/cgzl/p/10294175.html</a></p>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>React——路由</title>
    <url>/2020/07/10/React%E2%80%94%E2%80%94%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><ul>
<li>先在项目中下载react-router-dom</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ADA"><figure class="iseeu highlight /ada"><table><tr><td class="code"><pre><span class="line">cnpm i react-router-dom <span class="comment">--save</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在App下引入BrowserRouter跟Route，然后在渲染函数中使用这两个类</li>
<li>Route中的两个参数<ol>
<li>path：表示url路径</li>
<li>component：表示这个Route是哪个组件的路由</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/home'</span>;</span><br><span class="line"><span class="keyword">import</span> Mine <span class="keyword">from</span> <span class="string">'./pages/mine'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Link, Switch, NavLink &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> MyNav <span class="keyword">from</span> <span class="string">'./components/mynav'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HashRouter：锚点路由</span></span><br><span class="line"><span class="comment"> * BrowserRouter：h5新特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;p&gt;App&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* Route需要被BrowserRouter包含 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">          &lt;MyNav/</span>&gt;</span><br><span class="line">          &#123;<span class="comment">/* &lt;MyNavLink/&gt; */</span>&#125;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/mine"</span> component=&#123;Mine&#125;/&gt;</span><br><span class="line">       &lt;<span class="regexp">/BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当一个组件被声明为Route的属性值时，Route会把<code>history、location、match</code>三个对象放到props中并传递到组件中，这三个三对象的含义分别是：<ol>
<li>history：包含了组件可以使用的各种路由系统的方法，常用的有 push 和 replace，两者都是跳转页面，但是 replace 不会引起页面的刷新，仅仅是改变 url。</li>
<li>location：相当于URL 的对象形式表示，通过 search 字段可以获取到 url 中的 查询字符串参数值的信息。</li>
<li>match：包含了具体的 url 信息，在 params 字段中可以获取到各个路由节点参数的值。</li>
</ol>
</li>
</ul>
<h3 id="BrowserRouter与HashRouter"><a href="#BrowserRouter与HashRouter" class="headerlink" title="BrowserRouter与HashRouter"></a>BrowserRouter与HashRouter</h3><ul>
<li>BrowserRoute是H5的新特性，它在路由导航时，不需要加#</li>
<li>HashRouter时锚点路由，需要加#</li>
</ul>
<h3 id="Link跳转"><a href="#Link跳转" class="headerlink" title="Link跳转"></a>Link跳转</h3><ul>
<li>Link一般用来做导航，创建一个组件，用来封装导航栏</li>
<li>Link的to属性表示跳转至哪个路由</li>
<li>最后在App中引入这个组件即可</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNav</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>Home页面<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                &lt;li&gt;&lt;Link to="/mi</span>ne<span class="string">"&gt;Mine页面&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="exact和strict精致匹配"><a href="#exact和strict精致匹配" class="headerlink" title="exact和strict精致匹配"></a>exact和strict精致匹配</h3><ul>
<li>当path属性没有加exact的时候/mine和/mine/ucenter两个路由都会跳转到mine页面，其中/mine/ucenter中包含了两个页面</li>
<li>如果只要每个路由的最后一个节点生效，则可加exact=true（exact默认为true）</li>
<li>加上strict的目的是为了明确  [路由]  和  [路由]/  的区别，若不加，这两个路由代表的是一个路由</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//换成下面代码</span></span><br><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    &lt;MyNav/&gt;</span><br><span class="line">    &#123;<span class="comment">/* &lt;MyNavLink/&gt; */</span>&#125;</span><br><span class="line">    &lt;Route strict exact path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route strict exact path=<span class="string">"/mine"</span> component=&#123;Mine&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/mine/ucenter"</span> component=&#123;UCenter&#125;/&gt;</span><br><span class="line">&lt;<span class="regexp">/BrowserRouter&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="404页面和Switch"><a href="#404页面和Switch" class="headerlink" title="404页面和Switch"></a>404页面和Switch</h3><ul>
<li>创建一个简单的404页面组件，然后在App引入，这样404组件将会匹配任意路由</li>
<li>其实这样是不对的，我们要使输入正确的路由时不出现NotFound页面，需要加上Switch标签</li>
<li>Switch表示BrowserRouter一次只能展现一个组件页面</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">NotFound</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            <span class="number">404</span>页面</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="regexp">    &lt;MyNav/</span>&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &#123;<span class="comment">/* &lt;MyNavLink/&gt; */</span>&#125;</span><br><span class="line">        &lt;Route strict exact path=<span class="string">"/home"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route strict exact path=<span class="string">"/mine"</span> component=&#123;Mine&#125;/&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/mine/ucenter"</span> component=&#123;UCenter&#125;/&gt;</span><br><span class="line">        &lt;Route component=&#123;NotFound&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>BrowserRouter&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果加了Switch不加exact的话，则只有第一个节点生效，其他的不生效</li>
</ul>
<h3 id="render-func"><a href="#render-func" class="headerlink" title="render func"></a>render func</h3><ul>
<li>在Route中可以使用render来替换component,render属性传入的是一个函数，render属性有两种使用方式<ol>
<li>在render的函数中直接写html</li>
<li>在render的函数中写组件，间接渲染html，使用这种方式可以传入参数props，并可以和之前一样传递组件属性值，在组件中使用props来接收属性值</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"/demo"</span> render=&#123;()=&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              Demo</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          &#125;/</span>&gt;</span><br><span class="line">&lt;Route path=<span class="string">"/demo"</span> render=&#123;(props)=&gt;<span class="xml"><span class="tag">&lt;<span class="name">Demo&#123;...props&#125;</span> <span class="attr">name</span>=<span class="string">"Hello"</span>/&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Demo = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &#123;props.name&#125;, Demo</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Demo</span></span><br></pre></td></tr></table></figure></div>

<h3 id="NavLink的使用和高亮"><a href="#NavLink的使用和高亮" class="headerlink" title="NavLink的使用和高亮"></a>NavLink的使用和高亮</h3><ul>
<li>一般情况下，我们在使用导航栏的时候，导航栏都会有一个高亮效果来表示被选中的项，这时就可以使用NavLink来替换Link</li>
<li>要使活动项应用某些css样式，有三种方式：<ol>
<li>默认方式，使用NavLink会让标签自动地给活动项添加class=”active”，则可以使用该class设置样式，适合样式较复杂且不同活动项有相同样式的情况</li>
<li>使用activeClassName属性，使活动项添加一个手动设置的类名，适合样式较复杂且不同活动项有不同样式的情况</li>
<li>使用activeStyle属性，可以，使活动项直接添加css样式，适合样式较少的情况</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./style.css"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNavLink</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">activeClassName</span>=<span class="string">"selected"</span> <span class="attr">exact</span> <span class="attr">to</span>=<span class="string">"/"</span>&gt;</span>Home页面<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">                &lt;li&gt;&lt;NavLink exact to="/mi</span>ne<span class="string">"&gt;Mine页面&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li&gt;&lt;NavLink activeStyle=&#123;&#123;color:'green'&#125;&#125; to="</span>/mine/ucenter<span class="string">"&gt;UCenter页面&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">                &lt;li&gt;&lt;NavLink to="</span>/demo<span class="string">"&gt;Demo页面&lt;/NavLink&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="读取Url参数"><a href="#读取Url参数" class="headerlink" title="读取Url参数"></a>读取Url参数</h3><ul>
<li>在react中，如果要在Url再加上Url节点参数的话，可以在path属性中添加Url节点参数，例如：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的/:id?/:name?都为节点参数，而其中的?代表该参数可以为空</span></span><br><span class="line">&lt;Route path=<span class="string">"/demo/:id?/:name?"</span> render=&#123;(props)=&gt;<span class="xml"><span class="tag">&lt;<span class="name">Demo&#123;...props&#125;</span> <span class="attr">name</span>=<span class="string">"Hello"</span>/&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在Demo中就可以使用props.match读取这两个参数的值</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取节点参数值</span></span><br><span class="line"><span class="keyword">const</span> id = props.match.params.id</span><br><span class="line"><span class="keyword">const</span> name = props.match.params.name</span><br></pre></td></tr></table></figure></div>

<h3 id="读取querystring参数"><a href="#读取querystring参数" class="headerlink" title="读取querystring参数"></a>读取querystring参数</h3><ul>
<li>在react中，如果要读取Url中查询字符串参数的值，则有两种方式可以读取：<ol>
<li>使用URLSearchParams来读取</li>
<li>使用第三方库querystring来读取</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取查询字符串参数值的第一种方式</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(props.location.search)</span><br><span class="line"><span class="built_in">console</span>.log(params.get(<span class="string">"name"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(params.get(<span class="string">"age"</span>));</span><br><span class="line"><span class="comment">//提取查询字符串参数值的第二种方式</span></span><br><span class="line"><span class="keyword">const</span> querystr = props.location.search.replace(<span class="string">'?'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="keyword">const</span> value = querystring.parse(querystr);</span><br><span class="line"><span class="built_in">console</span>.log(value.name);</span><br><span class="line"><span class="built_in">console</span>.log(value.age);</span><br></pre></td></tr></table></figure></div>

<h3 id="Link-to-object"><a href="#Link-to-object" class="headerlink" title="Link to-object"></a>Link to-object</h3><ul>
<li>Link to-object可以设置path携带查询字符串，即在to属性中添加一些其他附带的值：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里的Url为http://localhost:3000/mine?sort=name#the-hash</span></span><br><span class="line"><span class="comment">//state是隐性携带的参数</span></span><br><span class="line">&lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">NavLink</span> <span class="attr">exact</span>  <span class="attr">to</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">                    pathname: "/mine",</span></span><br><span class="line"><span class="xml">                    //默认查询字符串，search和hash是显性参数</span></span><br><span class="line"><span class="xml">                    search: "?sort=name",</span></span><br><span class="line"><span class="xml">                    hash: "#the-hash",</span></span><br><span class="line"><span class="xml">                    state:&#123; fromApp: true &#125;//隐性参数</span></span><br><span class="line"><span class="xml">                &#125;&#125;&gt;Mine页面<span class="tag">&lt;/<span class="name">NavLink</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Redirect重定向"><a href="#Redirect重定向" class="headerlink" title="Redirect重定向"></a>Redirect重定向</h3><ul>
<li>如果没有对一个组件声明一个路由，则可以使用Redirect来跳转页面，比如：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123; Redirect, Prompt &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            isLogin: <span class="literal">true</span>,</span><br><span class="line">            name:<span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> isLogin = <span class="keyword">this</span>.state.isLogin</span><br><span class="line">        <span class="comment">//判断isLogin，为true则显示shop页面，为false则跳转到home页面</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    isLogin ? </span><br><span class="line">                    &lt;div&gt;</span><br><span class="line">                        Shop</span><br><span class="line">                    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                    : &lt;Redirect to="/</span><span class="string">"/&gt;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><ul>
<li>withRouter在react中是一个高阶组件，作用是将一个组件包裹进<code>Route</code>里面, 然后<code>react-router</code>的三个对象<code>history, location, match</code>就会被放进这个组件的<code>props</code>属性中</li>
<li>则可以在这个组件中使用<code>history, location, match</code>这三个对象</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MineDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    clickHandler = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.props);</span><br><span class="line">        <span class="comment">//使用history进行跳转</span></span><br><span class="line">        <span class="keyword">this</span>.props.history.push(<span class="string">"/"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.clickHandler&#125;&gt;回到home页面&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(MineDemo);</span><br></pre></td></tr></table></figure></div>

<h3 id="Prompt"><a href="#Prompt" class="headerlink" title="Prompt"></a>Prompt</h3><ul>
<li><code>Prompt</code>可以用来触发提示信息，<code>when</code>属性表示触发的条件，而<code>message</code>表示提示信息的内容</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这里，当name的值为空时跳转则不会触发提示信息，而不为空时则会触发提示信息</span></span><br><span class="line">&lt;Prompt when=&#123; <span class="keyword">this</span>.state.name &#125;</span><br><span class="line">                message=&#123; <span class="string">"你确定要离开吗？"</span> &#125;/&gt;</span><br><span class="line">&lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.name&#125; onChange=&#123;(e)=&gt;<span class="keyword">this</span>.setState(&#123;<span class="attr">name</span>:e.target.value&#125;)&#125;/&gt;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-React</category>
      </categories>
      <tags>
        <tag>-React -JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(4)——List和Set</title>
    <url>/2020/07/20/Redis-4-%E2%80%94%E2%80%94List%E5%92%8CSet/</url>
    <content><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>Redis的List是通过Linked List（链表）来实现的String集合，所以插入数据的速度很快。</p>
<p>但是缺点就是在数据量比较大的时候，访问某个数据的时间可能会很长，但针对这种情况，可以使用Sorted Set，这个一会再说。</p>
<p>下面看命令</p>
<h2 id="LPUSH，RPUSH，LRANGE"><a href="#LPUSH，RPUSH，LRANGE" class="headerlink" title="LPUSH，RPUSH，LRANGE"></a>LPUSH，RPUSH，LRANGE</h2><p><strong>LPUSH</strong>会向List的左侧（头部）添加一个新的元素，而<strong>RPUSH</strong>会把新的元素添加到List的右侧（尾部）。</p>
<p><strong>LRANGE</strong>命令可以按索引区间显示List的一部分，它的个试试LRANGE List-Key start end。如果想显示整个list的话，这两个索引就可以是0和-1，其中-1就表示最后一个元素。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123160654136-1671270493.png" alt="img"></p>
<p>LPUSH和RPUSH，可以一次添加多个元素：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123160838318-619924373.png" alt="img"></p>
<h2 id="LPOP，RPOP"><a href="#LPOP，RPOP" class="headerlink" title="LPOP，RPOP"></a>LPOP，RPOP</h2><p>POP动作有两个效果：一个是获取到元素，另一个是把元素从list中删除。</p>
<p><strong>LPOP</strong>就是从左边（头部）POP，<strong>RPOP</strong>就是从右边（尾部）POP。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123161208960-846738752.png" alt="img"></p>
<p>而如果list里面已经没有元素了，这时执行pop就会返回null：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123161320676-520520177.png" alt="img"></p>
<h2 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h2><p><strong>LTRIM</strong>命令可以对list进行剪切，其格式为LTRIM list-key start end，返回的就是剪切的部分：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123161814139-6957150.png" alt="img"></p>
<h2 id="BRPOP，BLPOP"><a href="#BRPOP，BLPOP" class="headerlink" title="BRPOP，BLPOP"></a>BRPOP，BLPOP</h2><p><strong>BRPOP</strong>和<strong>BLPOP</strong>这两个命令与RPOP和LPOP类似，但是当list里没有元素的时候，它们可以几秒钟，如果这期间有新的元素添加到了list里，那么就会停止等待返回该元素，否则就会一直等到设定的时间结束，然后返回null：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123162957260-281062253.png" alt="img"></p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123163012860-1594542944.png" alt="img"></p>
<p>例子里面的5 就是等待5秒。</p>
<p>而如果这个参数改为<strong>0</strong>，那就是永远等待：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123163132084-1089080593.png" alt="img"></p>
<p>而当一旦有新的元素加入的时候，该命令就会立即返回元素：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123163301854-2051424296.png" alt="img"></p>
<p>此外您还应该研究一下<strong>RPOPLPUSH</strong>和<strong>BRPOPLPUSH</strong>这两个命令。</p>
<h2 id="自动创建和移除Key"><a href="#自动创建和移除Key" class="headerlink" title="自动创建和移除Key"></a>自动创建和移除Key</h2><p>通过Redis的命令我们可以发现，</p>
<p>当我们为集合添加元素的时候，如果集合的key不存在，那么Redis会为我们创建一个空的集合，然后再执行插入操作：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123164335952-869554043.png" alt="img"></p>
<p>但要注意的是，不可以为不同类型且key已经存在的集合添加新的数据：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123164231077-969840515.png" alt="img"></p>
<p>而从集合删除数据的时候，如果集合是空的，那么集合的Key就会自动销毁（Stream类型除外）：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123164417580-907220699.png" alt="img"></p>
<p>而针对只读命令（例如LLEN，返回list的长度）也具有同样的效果：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190123164452124-1248700164.png" alt="img"></p>
<hr>
<p>本文转载于埼玉杨的博客：<a href="https://www.cnblogs.com/cgzl/p/10309415.html" target="_blank" rel="noopener">https://www.cnblogs.com/cgzl/p/10309415.html</a></p>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis(5)——Sorted Set</title>
    <url>/2020/07/20/Redis-5-%E2%80%94%E2%80%94Sorted-Set/</url>
    <content><![CDATA[<h1 id="Sorted-SET"><a href="#Sorted-SET" class="headerlink" title="Sorted SET"></a>Sorted SET</h1><p><strong>Sorted Set</strong>有点像Set和Hash的结合体。</p>
<p>和Set一样，它里面的元素是唯一的，类型是String，所以它可以理解为就是一个Set。</p>
<p>但是Set里面的元素是无序的，而Sorted Set里面的元素都带有一个浮点值，叫做分数（score），所以这一点和Hash有点像，因为每个元素都映射到了一个值。</p>
<p>Sorted Set是有序的，规则如下：</p>
<ul>
<li>如果A.score &gt; B.score，那么A &gt; B。</li>
<li>如果A.score == B.score，那么A和B的大小就通过比较字符串来决定了，而A和B的字符串是不会相等的，因为Sorted Set里面的值都是唯一的。</li>
</ul>
<h2 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h2><p><strong>ZADD</strong>可以添加元素到Sorted Set，就和Set的SADD命令差不多：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125184555950-1176067031.png" alt="img"></p>
<p>可以看到ZADD的格式是：zadd key score element。</p>
<h2 id="ZRANGE，ZREVRANGE"><a href="#ZRANGE，ZREVRANGE" class="headerlink" title="ZRANGE，ZREVRANGE"></a>ZRANGE，ZREVRANGE</h2><p><strong>ZRANGE</strong>默认按分数<strong>由低到高</strong>把Sorted Set的元素显示出来：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125184854015-1163136376.png" alt="img"></p>
<p>想按分数要从高到低显示，需要使用<strong>ZREVRANGE</strong>：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125185010583-1207216074.png" alt="img"></p>
<p>也可以一同把分数显示出来，使用参数<strong>WITHSCORES</strong>：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125185111490-371437037.png" alt="img"></p>
<h2 id="ZRANGEBYSCORE"><a href="#ZRANGEBYSCORE" class="headerlink" title="ZRANGEBYSCORE"></a>ZRANGEBYSCORE</h2><p><strong>ZRANGEBYSCORE</strong>可以按范围显示Sorted Set，格式是zrangebyscore key 分数下限 分数上限：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125185545768-1464413844.png" alt="img"></p>
<p>可以看到结果也包括了分数下限和分数上限这两个边。</p>
<h2 id="ZREMRANGEBYSCORE"><a href="#ZREMRANGEBYSCORE" class="headerlink" title="ZREMRANGEBYSCORE"></a>ZREMRANGEBYSCORE</h2><p><strong>ZREMRANGEBYSCORE</strong>可以按范围移除元素：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125185818789-1833129375.png" alt="img"></p>
<p>该命令返回的是移除元素的个数。</p>
<p>其中-inf和inf分别表示负无穷和正无穷。</p>
<h2 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h2><p><strong>ZRANK</strong>命令可以获得元素的排名：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125190053118-429776194.png" alt="img"></p>
<p>注意，排名是从0开始的。</p>
<h2 id="ZREVRANK"><a href="#ZREVRANK" class="headerlink" title="ZREVRANK"></a>ZREVRANK</h2><p><strong>ZREVRANK</strong>这个正好和ZRANK相反，就不说了。</p>
<h2 id="词典分数"><a href="#词典分数" class="headerlink" title="词典分数"></a>词典分数</h2><p>Sorted Set里分数相同的元素是按照词典分数（可以理解为比较字符串）进行排序的。</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125190749501-1752854203.png" alt="img"></p>
<h2 id="ZRANGEBYLEX"><a href="#ZRANGEBYLEX" class="headerlink" title="ZRANGEBYLEX"></a>ZRANGEBYLEX</h2><p><strong>ZRANGEBYLEX</strong>可以按词典范围展示Sorted Set：</p>
<p><img src="https://img2018.cnblogs.com/blog/986268/201901/986268-20190125191239576-1235600280.png" alt="img"></p>
<p>可以看到该命令把开头字目为C到E（不包括E）的元素都显示了出来。</p>
<hr>
<p>本文转载于埼玉杨的博客：<a href="https://www.cnblogs.com/cgzl/p/10321149.html" target="_blank" rel="noopener">https://www.cnblogs.com/cgzl/p/10321149.html</a></p>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——数据类型与数据结构</title>
    <url>/2020/11/07/Redis%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>string，list，set，hast,sortset</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>string，list，set，hast,sortset都只是数据的保存形式，底层的数据结构是：简单动态字符串，双向链表，压缩列表，哈希表，跳表，整数数组，Redis使用了一个哈希表保存所有的键值对</li>
<li>五种数据形式的底层实现<pre><code>a，string：简单动态字符串
b，list：双向链表，压缩列表
c，hash：压缩列表，哈希表
d，Sorted Set：压缩列表，跳表
e，set：哈希表，整数数组</code></pre></li>
<li>List ,hash，set ,sorted set被统称为集合类型，一个键对应了一个集合的数据</li>
<li>集合类型的键和值之间的结构组织：<ol>
<li>Redis使用一个哈希表保存所有键值对，一个哈希表实则是一个数组，数组的每个元素称为哈希桶。</li>
<li>哈希桶中的元素保存的不是值的本身，而是指向具体值的指针</li>
</ol>
</li>
<li>哈希冲突解决<ol>
<li>Redis的hash表是全局的，所以当写入大量的key时，将会带来哈希冲突，可以使用渐进式地扩容来减低哈希冲突（不用一次性扩容的原因是单次请求操作可能会触发扩容，这时会导致长时间的阻塞）</li>
<li>Redis解决hash冲突的方式，是链式哈希：同一个哈希桶中的多个元素用一个链表来保存</li>
</ol>
</li>
<li>一次性扩容<ol>
<li>为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2，起始时hash2没有分配空间</li>
<li>随着数据增多，Redis执行分三步执行rehash;<ul>
<li>给hash2分配更大的内存空间，如是hash1的两倍</li>
<li>把hash1中的数据重新映射并拷贝到哈希表2中</li>
<li>释放hash1的空间</li>
</ul>
</li>
</ol>
</li>
<li>渐进式扩容<ol>
<li>由于步骤2重新映射非常耗时，会阻塞redis</li>
<li>讲集中迁移数据，改成每处理一个请求时，就从hash1中的第一个索引位置，顺带将这个索引位置上的所有entries拷贝到hash2中。</li>
</ol>
</li>
<li>压缩列表，跳表的特点<ol>
<li>压缩列表类似于一个数组，不同的是:压缩列表在表头有三个字段zlbytes,zltail和zllen分别表示长度，列表尾的偏移量和列表中的entry的个数，压缩列表尾部还有一个zlend，表示列表结束，所以压缩列表定位第一个和最后一个是O(1),但其他就是O(n)</li>
<li>跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位，时间复杂度是O(logn)，适合用来进行区域查询</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-MySql实例导入导出数据</title>
    <url>/2020/12/03/SequoiaDB-MySql%E5%AE%9E%E4%BE%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<ul>
<li>SequoiaSQL-MySQL 实例支持数据导入以及导出操作， 而其中就包含 CSV 格式导入导出和基于 mysqldump 工具的导入导出两种原生 MySQL 数据库所支持的方式。</li>
</ul>
<h3 id="CSV-导出"><a href="#CSV-导出" class="headerlink" title="CSV 导出"></a>CSV 导出</h3><p>添加 MySQL 数据库导入导出的路径配置，然后进行数据库 CSV 格式数据的导出。</p>
<h4 id="导出导入参数配置"><a href="#导出导入参数配置" class="headerlink" title="导出导入参数配置"></a>导出导入参数配置</h4><p>1）在 auto.cnf 文件中加入导入导出路径的参数配置；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /opt/sequoiasql/mysql/database/3306/auto.cnf &lt;&lt; EOF</span><br><span class="line">secure_file_priv = "/opt/sequoiasql/mysql/tmp"</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<p>2）创建存放数据路径；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/sequoiasql/mysql/tmp</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>secure_file_priv默认为NULL， 表示不允许导入导出操作，需要在配置文件中进行更改。</p>
</blockquote>
<p>3）重启 MySQL 数据库实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/sdb_sql_ctl restart myinst</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/6db15fabad72d0c3161df146c6b2fafd-0" alt="图片描述"></p>
<h4 id="登录到-MySQL-实例"><a href="#登录到-MySQL-实例" class="headerlink" title="登录到 MySQL 实例"></a>登录到 MySQL 实例</h4><p>4）登录 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<h4 id="CSV格式数据导出"><a href="#CSV格式数据导出" class="headerlink" title="CSV格式数据导出"></a>CSV格式数据导出</h4><p>1）进行创建并使用 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>2）创建包含自增主键字段的 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>), </span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>3）插入数据并执行查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Jacky"</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Alice"</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>4）执行 sql 语句进行导出， 其中字段以逗号(,)分隔，以双引号(“)作为字符串标识符，以回车换行(\r\n)作为记录分割符；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee   </span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/opt/sequoiasql/mysql/tmp/employee_export.csv'</span>   </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span></span><br><span class="line"><span class="keyword">ESCAPED</span> <span class="keyword">BY</span> <span class="string">'"'</span></span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\r\n'</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/1eff4ee4f16129ba59f1e168f3bb18f8-0" alt="图片描述"></p>
<p>5）退出 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h4 id="导出的-CSV-格式数据检查"><a href="#导出的-CSV-格式数据检查" class="headerlink" title="导出的 CSV 格式数据检查"></a>导出的 CSV 格式数据检查</h4><p>6）检查导出的数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat /opt/sequoiasql/mysql/tmp/employee_export.csv;</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/5d49615b0c0ec0c7938ed7d13aecf815-0" alt="图片描述"></p>
<h3 id="CSV-导入"><a href="#CSV-导入" class="headerlink" title="CSV 导入"></a>CSV 导入</h3><p>创建一张测试表 employee_import_test ，然后将上一小节导出的 CSV 数据内容导入该测试表中并进行数据验证。</p>
<h4 id="创建测试表"><a href="#创建测试表" class="headerlink" title="创建测试表"></a>创建测试表</h4><p>1）登入 MySQL；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）在 MySQL 实例中创建导入测试的分区表 employee_import_test；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee_import_test </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>), </span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span>=sequoiadb <span class="keyword">COMMENT</span>=<span class="string">"雇员表, sequoiadb: &#123; table_options: &#123; ShardingKey: &#123; 'empno': 1 &#125;, ShardingType: 'hash', 'Compressed': true,'CompressionType': 'lzw', 'AutoSplit': true, 'EnsureShardingIndex': false &#125; &#125;"</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/5b06a40243a82b660a2d8f1290d4eec2-0" alt="图片描述"></p>
<h4 id="CSV-格式数据导入"><a href="#CSV-格式数据导入" class="headerlink" title="CSV 格式数据导入"></a>CSV 格式数据导入</h4><p>3）导入语句操作；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">'/opt/sequoiasql/mysql/tmp/employee_export.csv'</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> employee_import_test</span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></span><br><span class="line"><span class="keyword">OPTIONALLY</span> <span class="keyword">ENCLOSED</span> <span class="keyword">BY</span> <span class="string">'"'</span></span><br><span class="line"><span class="keyword">ESCAPED</span> <span class="keyword">BY</span> <span class="string">'"'</span></span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\r\n'</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1540/1207281/bb739cf0ffa038dd1e4b871e405486a3-0" alt="图片描述"></p>
<h4 id="导入的-CSV-格式数据检查"><a href="#导入的-CSV-格式数据检查" class="headerlink" title="导入的 CSV 格式数据检查"></a>导入的 CSV 格式数据检查</h4><p>4）导入的数据检查；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee_import_test;</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/5206c86fd850b8dc04ae907c7c8e9b38-0" alt="图片描述"></p>
<p>5）退出 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="mysqldump-导出"><a href="#mysqldump-导出" class="headerlink" title="mysqldump 导出"></a>mysqldump 导出</h3><p>通过 mysqldump 导出可直接由 MySQL Shell 执行导入的 sql 数据文件。</p>
<h4 id="mysqldump-导出-1"><a href="#mysqldump-导出-1" class="headerlink" title="mysqldump 导出"></a>mysqldump 导出</h4><p>1）mysqldump 工具导出，路径为（/opt/sequoiasql/mysql/tmp/employee_import_test.sql）；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysqldump -h 127.0.0.1 -u root   company employee_import_test &gt; /opt/sequoiasql/mysql/tmp/employee_import_test.sql</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note：</p>
<p>mysqldump 导出的是 SQL 逻辑执行语句， 其有比较多的参数命令，可通过 mysqldump –help 罗列其中的参数进行查看</p>
</blockquote>
<p>2）mysqldump工具导出数据检查；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat /opt/sequoiasql/mysql/tmp/employee_import_test.sql</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/cd63810881fe9465c5291ca3be623172-0" alt="图片描述"></p>
<blockquote>
<p>Note：</p>
<p>因为内容较多， 仅截了图中的部分内容。</p>
</blockquote>
<h3 id="mysqldump-导入"><a href="#mysqldump-导入" class="headerlink" title="mysqldump 导入"></a>mysqldump 导入</h3><p>通过 mysqldump 直接导入 sql 数据文件并进行数据校验。</p>
<h4 id="清理数据表"><a href="#清理数据表" class="headerlink" title="清理数据表"></a>清理数据表</h4><p>1）登录 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）删除表 employee_import_test，为后面导入测试做准备；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> employee_import_test;</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/776356cee993cb55001048e58c6d48fb-0" alt="图片描述"></p>
<h4 id="mysqldump-工具导入"><a href="#mysqldump-工具导入" class="headerlink" title="mysqldump 工具导入"></a>mysqldump 工具导入</h4><p>1）mysqldump 导出后生成的文件是sql语句的集合，可以直接执行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">SOURCE /opt/sequoiasql/mysql/tmp/employee_import_test.sql;</span><br></pre></td></tr></table></figure></div>

<h4 id="mysqldump-工具导入检查"><a href="#mysqldump-工具导入检查" class="headerlink" title="mysqldump 工具导入检查"></a>mysqldump 工具导入检查</h4><p>2）导入数据检查；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee_import_test;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note：</p>
<p>因为我们导出的是数据表， 所以导入的时候， 需要选择好相应的数据库。</p>
</blockquote>
<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1540/1207281/320949ac49a5debff53db530901a8799-0" alt="图片描述"></p>
]]></content>
      <categories>
        <category>-SequoiaDB-MySql</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-MySql执行计划分析</title>
    <url>/2020/12/03/SequoiaDB-MySql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="执行计划分析"><a href="#执行计划分析" class="headerlink" title="执行计划分析"></a>执行计划分析</h3><ul>
<li>通过 mysqldumpslow 只能找出慢SQL，分析一条SQL为什么执行慢需要查看它的执行计划。在MySQL中，可以通过 explain 命令查看一条sql的执行计划。而执行 explain 的分析指标解释如下：</li>
</ul>
<ul>
<li><p>id:记录 select 序列号，有几个 select 就有几个 id，id 的顺序按select 出现的顺序递增</p>
</li>
<li><p>table：执行计划所在的表，可能是实际存在的，也可能是临时表，临时表由系统起名</p>
</li>
<li><p>select_type：表示 select 的类型，常见取值如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单表，不使用表连接或子查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>主查询，即外层的查询</td>
</tr>
<tr>
<td>UNION</td>
<td>UNION中的第二个或者后面的查询语句</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询中的第一个</td>
</tr>
</tbody></table>
</li>
<li><p>partitions：如果查询是基于分区表的话，会显示查询将访问的分区</p>
</li>
<li><p>possible_keys：可能用到的索引</p>
</li>
<li><p>key：实际用到的索引，这个字段很重要，如果实际key为空，想强制使用前面的possible_keys，可以在查询中使用force index</p>
</li>
<li><p>key_len：索引的长度，一般规律是所用到索引的列数越多，key_len 越长，SQL的性能也越佳</p>
</li>
<li><p>ref：显示在key列记录的索引中，表查找值所用到的列或常量，该列不需要太过关注</p>
</li>
<li><p>rows：读取并扫描的行数，行数越少，效率越高</p>
</li>
<li><p>filtered：存储引擎返回的数据在 server 层过滤后，剩下多少满足查询的记录数量的比例(百分比)</p>
</li>
<li><p>extra：额外信息，主要是不适合在其他列中显示，但十分重要的信息，比如下压给引擎的条件</p>
</li>
<li><p>type：这一列表示关联类型或访问类型，即 MySQL 决定如何查找表中的行</p>
</li>
<li><p>type 取值有如下几种，依次从最优到最差分别为：NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
</li>
</ul>
<h3 id="创建数据库及数据表"><a href="#创建数据库及数据表" class="headerlink" title="创建数据库及数据表"></a>创建数据库及数据表</h3><ul>
<li>创建 company 数据库和 employee 数据表用于后续小节分析执行计划。</li>
</ul>
<p>1）登录 MySQL Shell 连接 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）在 MySQL 实例中创建新数据库 company，并切换到 company；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）在 MySQL 实例 company 数据库中创建分区表 employee；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (empno)</span><br><span class="line">) <span class="keyword">ENGINE</span> = sequoiadb <span class="keyword">COMMENT</span> = <span class="string">"雇员表, sequoiadb: &#123; table_options: &#123; ShardingKey: &#123; 'empno': 1 &#125;, ShardingType: 'hash', 'Compressed': true, 'CompressionType': 'lzw', 'AutoSplit': true, 'EnsureShardingIndex': false &#125; &#125;"</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="构造数据"><a href="#构造数据" class="headerlink" title="构造数据"></a>构造数据</h3><p>使用 MySQL 的存储过程，构造出测试数据用于计划分析。</p>
<h4 id="构造数据-1"><a href="#构造数据-1" class="headerlink" title="构造数据"></a>构造数据</h4><p>使用存储过程构造数据，生成 1000 条测试数据到 employee 表中；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> gen_data;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> gen_data(<span class="keyword">IN</span> <span class="keyword">num</span> <span class="built_in">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> i <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> i = <span class="number">0</span>;</span><br><span class="line">WHILE i &lt; num DO</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> (i, <span class="string">'Name'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">SET</span> i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程生成 1000 条数据</span></span><br><span class="line"><span class="keyword">CALL</span> gen_data(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div>

<p>操作截图:<br><img src="https://doc.shiyanlou.com/courses/1541/1207281/d7da5c9733ad1ac3457ac7eb8717423f-0" alt="图片描述"></p>
<blockquote>
<p><strong>注意</strong>:<br>仅为实验需要，仅用了1000条数据</p>
</blockquote>
<h4 id="数据检查"><a href="#数据检查" class="headerlink" title="数据检查"></a>数据检查</h4><p>检查存储过程构造的数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图: <img src="https://doc.shiyanlou.com/courses/1541/1207281/3b20e5df60d4edb2b13c994c09caeb2b-0" alt="图片描述"></p>
<p>退出MySQL；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="慢查询日志配置"><a href="#慢查询日志配置" class="headerlink" title="慢查询日志配置"></a>慢查询日志配置</h3><p>开启慢查询日志需要修改配置文件并重启 MySQL 数据库实例。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>1)修改MySQL配置文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; /opt/sequoiasql/mysql/database/3306/auto.cnf &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启慢查询日志</span></span><br><span class="line">slow_query_log=on </span><br><span class="line"><span class="meta">#</span><span class="bash"> 慢查询日志存放路径</span></span><br><span class="line">slow_query_log_file = /opt/sequoiasql/mysql/database/sdb-mysql-slow.log </span><br><span class="line"><span class="meta">#</span><span class="bash"> 超过多长时间的查询为慢查询</span></span><br><span class="line">long_query_time = 1 </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<p>2）重启 MySQL 数据库实例生效；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/sdb_sql_ctl restart myinst</span><br></pre></td></tr></table></figure></div>

<p>3）登录MySQL；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>4）进行数据查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sleep</span>(<span class="number">2</span>), empno, ename, age <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> empno = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, age <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> empno = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sleep</span>(<span class="number">2</span>), empno, ename, age <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> empno = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意</strong>:<br>因为数据量不大， 为了构造慢查询情况，其中 sleep(2) 是为了构造查询 SQL 比较慢。</p>
</blockquote>
<p>操作截图: <img src="https://doc.shiyanlou.com/courses/1541/1207281/2f9ff6db1624d57ce8eecadce7791c2f-0" alt="图片描述"></p>
<p>5）退出MySQL；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<p>6）分析慢查询SQL；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow /opt/sequoiasql/mysql/database/sdb-mysql-slow.log</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意</strong>: 开启慢查询日志后，MySQL 会记录执行时间超出 long_query_time 的 sql 语句，对于生成的慢查询日志，可以使用 MySQL 自带的 mysqldumpslow 工具进行分析，mysqldumpslow 有比较多的分析参数， 可以通过 mysqldumpslow –help 查看。</p>
</blockquote>
<p>操作截图: <img src="https://doc.shiyanlou.com/courses/1541/1207281/6b2d6b2baeef45a6085717a67e1da41b-0" alt="图片描述"></p>
<h3 id="执行计划分析-1"><a href="#执行计划分析-1" class="headerlink" title="执行计划分析"></a>执行计划分析</h3><p>查看执行计划对于分析慢查询的优化具有重要意义。</p>
<p>1）登录 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）查看执行计划； 通过 mysqldumpslow 只能找出慢 SQL，分析一条SQL为什么执行慢需要查看它的执行计划。在 MySQL 中，可以通过 explain 命令查看一条sql的执行计划。如查看刚才使用 mysqldumpslow 找到的慢 SQL 的执行计划；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图: <img src="https://doc.shiyanlou.com/courses/1541/1207281/7355701f9c0ac2644bf1f39be70bc17a-0" alt="图片描述"></p>
<blockquote>
<p><strong>注意</strong>:<br>如图可通过 EXPALIN 分析 SQL 的执行计划， 看到此到 SQL 没有走索引。</p>
</blockquote>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>3）观察索引对执行计划的影响，为数据表 employee 的 age 查询字段创建索引；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> age_Index <span class="keyword">ON</span> employee(age);</span><br></pre></td></tr></table></figure></div>

<p>操作截图: <img src="https://doc.shiyanlou.com/courses/1541/1207281/3476b255fb5dcd1e6e4bf7443be70d5f-0" alt="图片描述"></p>
<h4 id="再次执行计划分析"><a href="#再次执行计划分析" class="headerlink" title="再次执行计划分析"></a>再次执行计划分析</h4><p>4）在创建好索引的表上再次进行执行计划分析；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图: <img src="https://doc.shiyanlou.com/courses/1541/1207281/b273ed8a1bd8a7da086933393ef0baa3-0" alt="图片描述"></p>
]]></content>
      <categories>
        <category>-SequoiaDB-MySql</category>
      </categories>
      <tags>
        <tag>-MySql -SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-MySql的备份与恢复</title>
    <url>/2020/12/03/SequoiaDB-MySql%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><ul>
<li>数据库备份功能，是一种最直接、有效确保数据安全的方法，MySQL 实例支持原生 MySQL 数据备份方法。</li>
</ul>
<h4 id="备份单库几个表"><a href="#备份单库几个表" class="headerlink" title="备份单库几个表"></a>备份单库几个表</h4><p>1）mysqldump 工具按表导出，路径为（/opt/sequoiasql/mysql/tmp/employee.sql）；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）创建 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）创建包含自增主键字段的 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>), </span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>4）插入数据并执行查询;</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Jacky"</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Alice"</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>5）退出MySQL Shell 界面;</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<p>6）进行数据备份；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/sequoiasql/mysql/tmp</span><br><span class="line">/opt/sequoiasql/mysql/bin/mysqldump -h 127.0.0.1 -u root  company employee &gt; /opt/sequoiasql/mysql/tmp/employee.sql</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>mysqldump 导出的是 sql 执行语句,包含数据。 其中导出的命令包含以下示例命令：</p>
<ul>
<li>备份所有库: mysqldump -h 127.0.0.1 -u root -p -A &gt; tmp/employee_import_test.sql</li>
<li>备份单个库所有表: mysqldump -h 127.0.0.1 -u root -p -B 库名&gt; tmp/employee_import_test.sql</li>
<li>备份单个库单个表: mysqldump -h 127.0.0.1 -u root -p 库名 表名&gt; tmp/employee_import_test.sql</li>
<li>备份单个库某几个表: mysqldump -h 127.0.0.1 -u root -p 库名 表名 表名&gt; tmp/employee_import_test.sql</li>
</ul>
</blockquote>
<p>7）数据检查；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat /opt/sequoiasql/mysql/tmp/employee.sql</span><br></pre></td></tr></table></figure></div>

<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/4688d0d05b4fde212abb9d7e23abd274-0" alt="图片描述"></p>
<blockquote>
<p>Note： 因为内容较多， 仅截了图中的部分内容</p>
</blockquote>
<p>1）创建备份数据存放文件夹；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiasql/mysql/bin</span><br><span class="line">mkdir /home/sdbadmin/mysqlbak</span><br></pre></td></tr></table></figure></div>

<h4 id="备份单库单表"><a href="#备份单库单表" class="headerlink" title="备份单库单表"></a>备份单库单表</h4><p>2）备份单个库单个表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 127.0.0.1 -u root  company employee&gt; /home/sdbadmin/mysqlbak/company_employee.sql</span><br></pre></td></tr></table></figure></div>

<h4 id="备份单个库"><a href="#备份单个库" class="headerlink" title="备份单个库"></a>备份单个库</h4><p>3）备份单个库所有表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 127.0.0.1 -u root  -B company&gt; /home/sdbadmin/mysqlbak/company.sql</span><br></pre></td></tr></table></figure></div>

<h4 id="备份所有库"><a href="#备份所有库" class="headerlink" title="备份所有库"></a>备份所有库</h4><p>4）备份所有库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h 127.0.0.1 -u root  -A &gt; /home/sdbadmin/mysqlbak/all.sql</span><br></pre></td></tr></table></figure></div>

<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><p>在 MySQL Shell 里面直接执行由 mysqldump 导出的 sql 文件进行数据恢复操作。</p>
<h4 id="数据恢复操作"><a href="#数据恢复操作" class="headerlink" title="数据恢复操作"></a>数据恢复操作</h4><p>1）登录 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）删除 company 数据库;</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> company;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note：</p>
<p>在恢复数据前需删除数据库以便查看数据恢复操作。</p>
</blockquote>
<p>3）检查 company 数据库是否已经删除;</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1540/1207281/294e6f0ab9166d1d0cd32dab0c148495-0" alt="img"></p>
<p>4）进行数据恢复，mysqldump 导出后生成的文件是 sql 语句的集合，可以直接执行;</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">SOURCE /home/sdbadmin/mysqlbak/all.sql;</span><br></pre></td></tr></table></figure></div>

<h4 id="mysqldump-工具恢复检查"><a href="#mysqldump-工具恢复检查" class="headerlink" title="mysqldump 工具恢复检查"></a>mysqldump 工具恢复检查</h4><p>1）mysqldump 导出后生成的文件是sql语句的集合，可以直接执行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note： 因为我们导出的是数据表， 所以导入的时候， 需要选择好相应的数据库</p>
</blockquote>
<p>操作截图:</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/cacbdde7b8c0daa0f57e65843e662e5c-0" alt="图片描述"></p>
]]></content>
      <categories>
        <category>-SequoiaDB-MySql</category>
      </categories>
      <tags>
        <tag>-MySql -SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——高性能IO模型</title>
    <url>/2020/11/07/Redis%E2%80%94%E2%80%94%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>Redis是单线程，主要是指Redis的网络IO和键值对读写都是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程。</li>
<li>但Redis的其他功能，比如持久化、异步删除、集群数据同步等，是由额外的线程执行的。所以，严格上来说，Redis并不是单线程。</li>
</ul>
<h3 id="Redis的单线程设计机制"><a href="#Redis的单线程设计机制" class="headerlink" title="Redis的单线程设计机制"></a>Redis的单线程设计机制</h3><h4 id="为什么不用多线程"><a href="#为什么不用多线程" class="headerlink" title="为什么不用多线程"></a>为什么不用多线程</h4><ul>
<li>由于多线程在访问共享数据时效果并不是很理想，并且多线程开销比较大，即即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变成串行，系统吞吐量并没有随着线程的增加而增加</li>
<li>而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。</li>
</ul>
<h4 id="单线程Redis为什么这么快？"><a href="#单线程Redis为什么这么快？" class="headerlink" title="单线程Redis为什么这么快？"></a>单线程Redis为什么这么快？</h4><ul>
<li>一方面，Redis属于内存数据库，拥有较快的访问速度，再加上Redis使用了高效的存储结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。</li>
<li>另一方面，Redis采用了多路复用机制，使其能够在网络IO操作中并发处理大量的客户端请求，实现高吞吐率。</li>
</ul>
<h3 id="Redis多路复用机制"><a href="#Redis多路复用机制" class="headerlink" title="Redis多路复用机制"></a>Redis多路复用机制</h3><ul>
<li><p>要弄明白Redis的多路复用机制，首先需要理解基本IO模型和潜在的阻塞点。</p>
</li>
<li><p>以 Get 请求为例，Redis为了处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p>
<p><img src="https://static001.geekbang.org/resource/image/e1/c9/e18499ab244e4428a0e60b4da6575bc9.jpg" alt="img"></p>
</li>
<li><p>这里有两个很明显的阻塞点：accept()和recv()，当Redis监听到一个连接请求，但一致未能成功建立连接时，就会阻塞在accept()函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。</p>
</li>
<li><p>这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，幸运的是，socket 网络模型本身支持非阻塞模式。</p>
</li>
</ul>
<h4 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h4><ul>
<li>Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上，如果想要使用 socket 非阻塞模式，就必须要了解这三个函数的调用返回类型和设置模式。</li>
<li>在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字。</li>
<li>然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。</li>
<li>最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/1c/4a/1ccc62ab3eb2a63c4965027b4248f34a.jpg" alt="img"></p>
<ul>
<li>Redis套接字类型与非阻塞设置针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。</li>
<li>虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。</li>
<li>类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。</li>
<li>这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。</li>
</ul>
<h4 id="基于多路复用的高性能IO模型"><a href="#基于多路复用的高性能IO模型" class="headerlink" title="基于多路复用的高性能IO模型"></a>基于多路复用的高性能IO模型</h4><ul>
<li><p>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
</li>
<li><p>下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg" alt="img"></p>
<ul>
<li>为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。</li>
<li>那么，回调机制是怎么工作的呢？其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。</li>
<li>这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。</li>
<li>这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。</li>
</ul>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-PostgreSql实例执行计划</title>
    <url>/2020/12/03/SequoiaDB-PostgreSql%E5%AE%9E%E4%BE%8B%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h3 id="实例与数据引擎中集合关联"><a href="#实例与数据引擎中集合关联" class="headerlink" title="实例与数据引擎中集合关联"></a>实例与数据引擎中集合关联</h3><p>将 PostgreSQL 实例中的外部表与 SequoiaDB 中的集合空间、集合关联。</p>
<p>1）创建 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<p>2）创建 employee2 表（把 pushdownsort 和 pushdownlimit 参数设置为关闭）；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> employee2 </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span>, pushdownsort <span class="string">'off'</span>, pushdownlimit <span class="string">'off'</span> );</span><br></pre></td></tr></table></figure></div>

<p>3）创建 manager 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> manager </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INTEGER</span>,</span><br><span class="line">department <span class="built_in">TEXT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'manager'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<p>4）更新表的统计信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ANALYZE</span> employee;</span><br><span class="line"><span class="keyword">ANALYZE</span> employee2;</span><br><span class="line"><span class="keyword">ANALYZE</span> manager;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li>集合空间与集合必须已经存在于 SequoiaDB，否则查询出错。</li>
<li>如果需要对接 SequoiaDB 的 decimal 字段，则需要在 options 中指定 decimal ‘on’ 。</li>
<li>pushdownsort 设置是否下压排序条件到 SequoiaDB，默认为 on，关闭为 off。</li>
<li>pushdownlimit 设置是否下压 limit 和 offset 条件到 SequoiaDB，默认为 on，关闭为 off。</li>
<li>开启 pushdownlimit 时，必须同时开启 pushdownsort，否则可能会造成结果非预期的问题。</li>
<li>默认情况下，表的字段映射到 SequoiaDB 中为小写字符，如果强制指定字段为大写字符，创建方式参考“<a href="http://doc.sequoiadb.com/cn/index-cat_id-1432190715-edition_id-302" target="_blank" rel="noopener">注意事项1</a>”。</li>
<li>映射 SequoiaDB 的数组类型，创建方式参考“<a href="http://doc.sequoiadb.com/cn/index-cat_id-1432190715-edition_id-302" target="_blank" rel="noopener">注意事项2</a>”。</li>
</ul>
</blockquote>
<h3 id="PostgreSQL执行计划查看"><a href="#PostgreSQL执行计划查看" class="headerlink" title="PostgreSQL执行计划查看"></a>PostgreSQL执行计划查看</h3><p>1）在 PostgreSQL 中执行条件查询语句，并查看执行计划；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">ANALYZE</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> manager b <span class="keyword">ON</span> a.empno = b.empno <span class="keyword">WHERE</span> a.empno = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/5e8ee75591eebfadb333034f340e2918-0" alt="图片描述"></p>
<p>从执行计划可以看出：</p>
<ol>
<li>两个表的连接方式为 Nested Loop Join；</li>
<li>“Foreign Namespace”, 表示查询涉及到的外部表分别映射到 SequoiaDB 巨杉数据库的 company.employee 和 company.manager 集合中；</li>
<li>“Filter”，表示把 SQL 语句的查询条件转为 JavaScript 语法的查询条件。而最终，PostgreSQL 会把 JavaScript 语法的查询条件下压到 SequoiaDB 巨杉数据库对应的集合中执行；</li>
</ol>
<p>2）在 PostgreSQL 中执行分页查询语句，并查看执行计划；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">ANALYZE</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> empno <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">ANALYZE</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee2 <span class="keyword">ORDER</span> <span class="keyword">BY</span> empno <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">5</span> <span class="keyword">OFFSET</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/02195977561d108bbeb6d19b56b8d23d-0" alt="图片描述"></p>
<p>对比以上两个外部表的执行计划，可以看到：</p>
<ol>
<li>employee 外部表的执行计划，PostgreSQL 把 limit、offset 和排序条件下压到 SequoiaDB 巨杉数据库中执行（分页和排序是在 SequoiaDB 巨杉数据库中完成），因为创建 employee 外部表时，没有指定 pushdownsort 和 pushdownlimit 参数，默认为开启。</li>
<li>employee2 外部表的执行计划，PostgreSQL 没有把 limit、offset 和排序条件下压到 SequoiaDB 巨杉数据库中执行（由 PostgreSQL 完成分页和排序），因为创建 employee2 外部表时，设置了 pushdownsort 和 pushdownlimit 参数为关闭。</li>
</ol>
<p>3）退出 PostgreSQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB-PostgreSql</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -PostgreSql</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-PostgreSql元数据同步</title>
    <url>/2020/12/03/SequoiaDB-PostgreSql%E5%85%83%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h3 id="元数据同步"><a href="#元数据同步" class="headerlink" title="元数据同步"></a>元数据同步</h3><ul>
<li>元数据同步指在两个或多个 PostgreSQL 实例之间，完成元数据（如：建外部表等 DDL 操作）的同步。元数据同步工具主要用于定时解析主 SSQL 日志中新增的 DDL 操作语句并下发到各备 SSQL 执行，同时能过滤日志中执行失败的 DDL 操作语句。以两个 PostgreSQL 实例为例（一主一备），在主 PostgreSQL 实例中创建数据库和外部表，并通过元数据同步工具，实现将新创建的数据库和外部表同步到备 PostgreSQL 实例中，完成元数据同步。</li>
</ul>
<h3 id="创建-PostgreSQL-实例-myinst-和-myinst1"><a href="#创建-PostgreSQL-实例-myinst-和-myinst1" class="headerlink" title="创建 PostgreSQL 实例 myinst 和 myinst1"></a>创建 PostgreSQL 实例 myinst 和 myinst1</h3><p>1）切换到 SequoiaSQL-PostgreSQL 安装目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiasql/postgresql</span><br></pre></td></tr></table></figure></div>

<p>2）添加实例；</p>
<p>添加实例 myinst（作为主 PostgreSQL 实例）；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl addinst myinst -D database/5432/ -p 5432</span><br></pre></td></tr></table></figure></div>

<p>添加实例 myinst1（作为备 PostgreSQL 实例）；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl addinst myinst1 -D database/5433/ -p 5433</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>指定实例名为 myinst，该实例名映射相应的数据目录和日志路径，用户可以根据自己需要指定不同的实例名，实例默认端口号为 5432。</p>
</blockquote>
<p>3）查看实例，可以看到实例名为 myinst 的数据和日志目录信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl listinst</span><br></pre></td></tr></table></figure></div>

<p>4）启动实例；</p>
<p>启动实例 myinst；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl start myinst</span><br></pre></td></tr></table></figure></div>

<p>启动实例 myinst1；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl start myinst1</span><br></pre></td></tr></table></figure></div>

<p>5）查看实例状态；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl status</span><br></pre></td></tr></table></figure></div>

<h3 id="配置-PostgreSQL-实例免密登录"><a href="#配置-PostgreSQL-实例免密登录" class="headerlink" title="配置 PostgreSQL 实例免密登录"></a>配置 PostgreSQL 实例免密登录</h3><p>若 PostgreSQL 实例开启了用户鉴权，需要创建元数据同步用户以及配置免密登录。</p>
<p>1）进入 sdbadmin 的 home 目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /home/sdbadmin</span><br></pre></td></tr></table></figure></div>

<p>2）同步工具已提前放置在 sdbadmin 的 home 目录，解压同步工具；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tar xvf SsqlDisseminateDDL.tar</span><br></pre></td></tr></table></figure></div>

<p>3）进入解压目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd SsqlDisseminateDDL</span><br></pre></td></tr></table></figure></div>

<p>4）拷贝免密文件到 home 目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp .pgpass /home/sdbadmin/</span><br></pre></td></tr></table></figure></div>

<p>5）将文件权限设置为0600；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">chmod 0600 /home/sdbadmin/.pgpass</span><br></pre></td></tr></table></figure></div>

<h3 id="PostgreSQL-实例日志设置"><a href="#PostgreSQL-实例日志设置" class="headerlink" title="PostgreSQL 实例日志设置"></a>PostgreSQL 实例日志设置</h3><p>1）进入 myinst 实例的数据目录，修改部分配置；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiasql/postgresql/database/5432</span><br></pre></td></tr></table></figure></div>

<p>2）为了配合元数据同步，需要对应修改 postgresql.conf 配置文件的参数；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo "log_destination = 'csvlog'" &gt;&gt; postgresql.conf</span><br><span class="line">echo "logging_collector = on" &gt;&gt; postgresql.conf</span><br><span class="line">echo "log_directory = '/opt/sequoiasql/postgresql/database/5432/pg_log'" &gt;&gt; postgresql.conf</span><br><span class="line">echo "log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'" &gt;&gt; postgresql.conf</span><br><span class="line">echo "log_rotation_age = 28d" &gt;&gt; postgresql.conf</span><br><span class="line">echo "log_rotation_size = 20MB" &gt;&gt; postgresql.conf</span><br><span class="line">echo "log_statement = 'ddl'" &gt;&gt; postgresql.conf</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li>log_destination：设置输出的日志类型；</li>
<li>logging_collector：是否开启日志功能，默认为关闭（off），开启为 on；</li>
<li>log_directory：日志输出目录；</li>
<li>log_filename：日志文件名称命名规则；</li>
<li>log_rotation_age：单个日志文件的保存周期，默认保存 1 天（1d）；</li>
<li>log_rotation_size：单个日志文件的大小， 若超过指定大小，那么将新生成一个日志文件；</li>
<li>log_statement：控制记录哪些 SQL 语句；</li>
</ul>
</blockquote>
<h3 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h3><p>将元数据同步程序及 config 配置文件拷贝到本地，并查看 config 文件内容。</p>
<p>1）拷贝元数据同步工具到数据目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /home/sdbadmin/SsqlDisseminateDDL/SsqlDisseminateDDL ./</span><br></pre></td></tr></table></figure></div>

<p>2）拷贝元数据同步工具配置到数据目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /home/sdbadmin/SsqlDisseminateDDL/config ./</span><br></pre></td></tr></table></figure></div>

<p>3）查看 config 配置内容；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">more config</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/45bd2c1b7c9e23260041865416b8fb24-0" alt="图片描述"></p>
<p>注：配置文件中参数包括：目标 PostgreSQL 实例 myinst1 运行的服务器名，端口号；源 PostgreSQL 实例 myinst 的安装目录，数据目录，解析日志目录；PostgreSQL 同步用户；以及元数据同步程序的执行时间间隔、执行日志目录，执行日志文件前缀。</p>
<h3 id="重启-myinst-实例"><a href="#重启-myinst-实例" class="headerlink" title="重启 myinst 实例"></a>重启 myinst 实例</h3><p>创建配置文件指定的解析日志目录和执行日志目录，重启源 PostgreSQL 实例 myinst，使配置生效；</p>
<p>1）创建日志目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/sequoiasql/postgresql/database/5432/pg_log</span><br><span class="line">mkdir /opt/sequoiasql/postgresql/database/5432/log</span><br></pre></td></tr></table></figure></div>

<p>2）重启 myinst 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/sdb_sql_ctl restart myinst</span><br></pre></td></tr></table></figure></div>

<h3 id="启动元数据同步工具"><a href="#启动元数据同步工具" class="headerlink" title="启动元数据同步工具"></a>启动元数据同步工具</h3><p>元数据同步工具在启动后会一直常驻后台运行，主要用于定时解析主 PostgreSQL 实例日志中新增的 DDL 操作语句并下发到各备 PostgreSQL 实例中执行。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">nohup python /opt/sequoiasql/postgresql/database/5432/SsqlDisseminateDDL &amp;</span><br></pre></td></tr></table></figure></div>

<h3 id="在-SequoiaDB-中建立集合空间和集合"><a href="#在-SequoiaDB-中建立集合空间和集合" class="headerlink" title="在 SequoiaDB 中建立集合空间和集合"></a>在 SequoiaDB 中建立集合空间和集合</h3><p>进入 SequoiaDB Shell，在 SequoiaDB 巨杉数据库引擎中创建 company 集合空间和 employee 集合。</p>
<p>1）使用 Linux 命令进入 SequoiaDB Shell 命令行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 JavaScript 语法，连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建 company_domain 数据域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 company 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建 employee 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）写入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.insert( &#123; <span class="string">"empno"</span>: <span class="number">1</span>, <span class="string">"ename"</span>: <span class="string">"Jack"</span>, <span class="string">"age"</span>: <span class="number">35</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>7）关闭 db 数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">db.close();</span><br></pre></td></tr></table></figure></div>

<p>8）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="验证元数据同步"><a href="#验证元数据同步" class="headerlink" title="验证元数据同步"></a>验证元数据同步</h3><p>在主 PostgreSQL 实例中创建 company 数据库并配置连接信息创建 employee 外部表，然后登录备 PostgreSQL 实例查看是否已经创建了数据库和外部表。</p>
<h4 id="在-myinst-实例中创建数据库"><a href="#在-myinst-实例中创建数据库" class="headerlink" title="在 myinst 实例中创建数据库"></a>在 myinst 实例中创建数据库</h4><p>1）在 PostgreSQL 的 myinst 实例创建数据库 company；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/sdb_sql_ctl createdb company myinst</span><br></pre></td></tr></table></figure></div>

<p>2）查看数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -l</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/1d9add777fbb83cb0419245aefe1f2ae-0" alt="图片描述"></p>
<h4 id="加载-SequoiaDB-连接驱动"><a href="#加载-SequoiaDB-连接驱动" class="headerlink" title="加载 SequoiaDB 连接驱动"></a>加载 SequoiaDB 连接驱动</h4><p>1）登录 PostgreSQL Shell 连接 myinst 实例的 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5432 company</span><br></pre></td></tr></table></figure></div>

<p>2）加载 SequoiaDB 连接驱动；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION sdb_fdw;</span><br></pre></td></tr></table></figure></div>

<p>3）在 PostgreSQL 实例中配置 SequoiaDB 连接参数；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SERVER</span> sdb_server <span class="keyword">FOREIGN</span> <span class="keyword">DATA</span> WRAPPER sdb_fdw </span><br><span class="line">OPTIONS </span><br><span class="line">(</span><br><span class="line">address <span class="string">'127.0.0.1'</span>, </span><br><span class="line">service <span class="string">'11810'</span>, </span><br><span class="line"><span class="keyword">user</span> <span class="string">''</span>, </span><br><span class="line"><span class="keyword">password</span> <span class="string">''</span>, </span><br><span class="line">preferedinstance <span class="string">'A'</span>, </span><br><span class="line"><span class="keyword">transaction</span> <span class="string">'on'</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="实例与数据引擎中集合关联"><a href="#实例与数据引擎中集合关联" class="headerlink" title="实例与数据引擎中集合关联"></a>实例与数据引擎中集合关联</h4><p>将 PostgreSQL 实例中的外部表与 SequoiaDB 中的集合空间、集合关联。</p>
<p>1）创建 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<p>2）查询 myinst 实例 employee 表中的数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>3）退出 myinst 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h4 id="查询-myinst1-实例是否已经建表成功"><a href="#查询-myinst1-实例是否已经建表成功" class="headerlink" title="查询 myinst1 实例是否已经建表成功"></a>查询 myinst1 实例是否已经建表成功</h4><p>1）登录 PostgreSQL Shell 连接 myinst1 实例的 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5433 company</span><br></pre></td></tr></table></figure></div>

<p>2）查询 myinst1 实例 employee 表中的数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>3）退出 myinst1 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB-PostgreSql</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -PostgreSql</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-PostgreSql实例操作与事务</title>
    <url>/2020/12/03/SequoiaDB-PostgreSql%E5%AE%9E%E4%BE%8B%E6%93%8D%E4%BD%9C%E4%B8%8E%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="创建域、集合空间和集合"><a href="#创建域、集合空间和集合" class="headerlink" title="创建域、集合空间和集合"></a>创建域、集合空间和集合</h3><p>进入 SequoiaDB Shell，在 SequoiaDB 巨杉数据库引擎中创建 company 集合空间、 employee 集合和 manager 集合。</p>
<p>1）使用 Linux 命令进入 SequoiaDB Shell 命令行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 JavaScript 语法，连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建 company_domain 数据域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 company 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建 employee 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"empno"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）创建 manager 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"manager"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"empno"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>7）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在 SequoiaSQL-PostgreSQL 实例中创建 company 数据库，为接下来验证 PostgreSQL 语法特性做准备。</p>
<p>1）在 PostgreSQL 实例创建数据库 company；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/sdb_sql_ctl createdb company myinst</span><br></pre></td></tr></table></figure></div>

<p>2）查看数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -l</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/1d9add777fbb83cb0419245aefe1f2ae-0" alt="图片描述"></p>
<h3 id="配置-PostgreSQL-实例"><a href="#配置-PostgreSQL-实例" class="headerlink" title="配置 PostgreSQL 实例"></a>配置 PostgreSQL 实例</h3><p>在 PostgreSQL 实例中加载 SequoiaDB 的连接驱动并配置连接参数。</p>
<h4 id="加载-SequoiaDB-连接驱动"><a href="#加载-SequoiaDB-连接驱动" class="headerlink" title="加载 SequoiaDB 连接驱动"></a>加载 SequoiaDB 连接驱动</h4><p>1）登录到 PostgreSQL 实例 Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5432 company</span><br></pre></td></tr></table></figure></div>

<p>2）加载 SequoiaDB 连接驱动；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION sdb_fdw;</span><br></pre></td></tr></table></figure></div>

<h4 id="配置与-SequoiaDB-连接参数"><a href="#配置与-SequoiaDB-连接参数" class="headerlink" title="配置与 SequoiaDB 连接参数"></a>配置与 SequoiaDB 连接参数</h4><p>在 PostgreSQL 实例中配置 SequoiaDB 连接参数：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SERVER</span> sdb_server <span class="keyword">FOREIGN</span> <span class="keyword">DATA</span> WRAPPER sdb_fdw </span><br><span class="line">OPTIONS </span><br><span class="line">(</span><br><span class="line">address <span class="string">'127.0.0.1'</span>, </span><br><span class="line">service <span class="string">'11810'</span>, </span><br><span class="line"><span class="keyword">user</span> <span class="string">''</span>, </span><br><span class="line"><span class="keyword">password</span> <span class="string">''</span>, </span><br><span class="line">preferedinstance <span class="string">'A'</span>, </span><br><span class="line"><span class="keyword">transaction</span> <span class="string">'on'</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h3 id="实例与数据引擎中集合关联"><a href="#实例与数据引擎中集合关联" class="headerlink" title="实例与数据引擎中集合关联"></a>实例与数据引擎中集合关联</h3><p>将 PostgreSQL 实例中的外部表并与 SequoiaDB 中的集合空间、集合关联。</p>
<p>1）创建 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INTEGER</span>,</span><br><span class="line">ename <span class="built_in">TEXT</span>,</span><br><span class="line">age <span class="built_in">INTEGER</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<p>2）创建 manager 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> manager </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INTEGER</span>,</span><br><span class="line">department <span class="built_in">TEXT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'manager'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<h3 id="基本数据操作"><a href="#基本数据操作" class="headerlink" title="基本数据操作"></a>基本数据操作</h3><p>SequoiaDB 巨杉数据库的 PostgreSQL 实例支持完整的 CRUD 数据基本操作。</p>
<p>1）验证基本的数据写入操作；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'Jacky'</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'Alice'</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> manager <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'Sales Department'</span>);</span><br></pre></td></tr></table></figure></div>

<p>2）验证单表查询与排序；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> empno <span class="keyword">ASC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>3）验证两表关联功能；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee, manager <span class="keyword">WHERE</span> employee.empno = manager.empno;</span><br></pre></td></tr></table></figure></div>

<p>4）验证数据更新能力；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employee <span class="keyword">SET</span> ename = <span class="string">'Bob'</span> <span class="keyword">WHERE</span> empno = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<p>5）查看数据结果；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>6）验证数据删除能力；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> empno = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>7）查看数据结果并确认 empno 为 2 的记录被删除；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>SequoiaDB 巨杉数据库的 PostgreSQL 数据库实例支持完整的事务操作能力，本小节将验证其回滚与提交能力。</p>
<h4 id="验证回滚能力"><a href="#验证回滚能力" class="headerlink" title="验证回滚能力"></a>验证回滚能力</h4><p>1）开始事务；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></div>

<p>2）写入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> manager <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'Product Department'</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）回滚事务操作；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></div>

<p>4）查询写入数据，确保刚才写入的数据被撤销；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> manager <span class="keyword">WHERE</span> empno = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<h4 id="验证提交能力"><a href="#验证提交能力" class="headerlink" title="验证提交能力"></a>验证提交能力</h4><p>1）开始事务；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></div>

<p>2）写入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> manager <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'Product Department'</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）提交事务；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></div>

<p>4）查询写入数据，确保之前写入的数据被正确提交；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> manager <span class="keyword">WHERE</span> empno = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p>本小节将讲解如何查看并关闭 PostgreSQL 的事务功能，关闭后需要重新进入实例的 Shell 命令行。</p>
<p>1）查看 PostgreSQL 是否打开事务功能；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\des+ sdb_server;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/b20972e94f0fe978ba09f1b8c904237a-0" alt="图片描述"></p>
<p>操作截图中 transaction 的参数值为 on，说明 PostgreSQL 的事务功能已经打开。</p>
<p>2）关闭 PostgreSQL 事务功能；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">SERVER</span> sdb_server OPTIONS ( <span class="keyword">SET</span> <span class="keyword">transaction</span> <span class="string">'off'</span> );</span><br></pre></td></tr></table></figure></div>

<p>3）退出 PostgreSQL 实例 Shell ；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<p>4）登录到 PostgreSQL 实例 Shell，使事务功能关闭设置生效；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5432 company</span><br></pre></td></tr></table></figure></div>

<p>5）开始事务；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure></div>

<p>6）写入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> manager <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'Finance Department'</span>);</span><br></pre></td></tr></table></figure></div>

<p>7）回滚事务操作；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></div>

<p>8）查询写入数据，验证事务功能是否已经关闭；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> manager <span class="keyword">WHERE</span> empno = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/59930c0309e32b64aece0fc2092fd246-0" alt="图片描述"></p>
<p>如操作截图显示，是能够查询到刚刚写入的数据，说明 PostgreSQL 的事务功能已经关闭，数据库没有执行回滚操作。</p>
<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>SequoiaDB 巨杉数据库支持标准的 PostgreSQL 视图功能。本小节将验证其对标准 PostgreSQL 视图能力的支持。</p>
<p>1）创建视图；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> manager_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"> e.ename, m.department</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"> employee <span class="keyword">AS</span> e, manager <span class="keyword">AS</span> m</span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line"> e.empno = m.empno;</span><br></pre></td></tr></table></figure></div>

<p>2）查询视图数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> manager_view;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建自定义函数"><a href="#创建自定义函数" class="headerlink" title="创建自定义函数"></a>创建自定义函数</h3><p>SequoiaDB 巨杉数据库支持标准的 PostgreSQL 自定义函数功能。本小节将验证其对标准 PostgreSQL 自定义函数能力的支持。</p>
<p>1）创建自定义函数；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> totalRecords () <span class="keyword">RETURNS</span> <span class="built_in">INTEGER</span> <span class="keyword">AS</span> $total$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    total <span class="built_in">INTEGER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> total <span class="keyword">FROM</span> employee;</span><br><span class="line">RETURN total;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$total$ language plpgsql;</span><br></pre></td></tr></table></figure></div>

<p>2）调用函数；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> totalRecords();</span><br></pre></td></tr></table></figure></div>

<p>3）退出 PostgreSQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB-PostgreSql</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -PostgreSql</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-PostgreSql实例的创建</title>
    <url>/2020/12/03/SequoiaDB-PostgreSql%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="创建-PostgreSQL-实例"><a href="#创建-PostgreSQL-实例" class="headerlink" title="创建 PostgreSQL 实例"></a>创建 PostgreSQL 实例</h3><p>1）切换到 SequoiaSQL-PostgreSQL 安装目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiasql/postgresql</span><br></pre></td></tr></table></figure></div>

<p>2）添加实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl addinst myinst -D database/5432/</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>指定实例名为 myinst，该实例名映射相应的数据目录和日志路径，用户可以根据自己需要指定不同的实例名，实例默认端口号为 5432。</p>
</blockquote>
<p>3）查看实例，可以看到实例名为 myinst 的数据和日志目录信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl listinst</span><br></pre></td></tr></table></figure></div>

<p>4）启动实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl start myinst</span><br></pre></td></tr></table></figure></div>

<p>5）查看实例状态；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/sdb_sql_ctl status</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1540/1207281/7033659baf8b9a7bd63213e2a615c180-0" alt="图片描述"></p>
<h3 id="在-SequoiaDB-中建立集合空间和集合"><a href="#在-SequoiaDB-中建立集合空间和集合" class="headerlink" title="在 SequoiaDB 中建立集合空间和集合"></a>在 SequoiaDB 中建立集合空间和集合</h3><p>进入 SequoiaDB Shell，在 SequoiaDB 巨杉数据库引擎中创建 company 集合空间和 employee 集合。</p>
<p>1）使用 Linux 命令进入 SequoiaDB Shell 命令行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 JavaScript 语法，连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建 company_domain 数据域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 company 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建 employee 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在 SequoiaSQL-PostgreSQL 实例中创建 company 数据库实例，为接下来验证 PostgreSQL 语法特性做准备。</p>
<p>1）在 PostgreSQL 实例创建数据库 company；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/sdb_sql_ctl createdb company myinst</span><br></pre></td></tr></table></figure></div>

<p>2）查看数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -l</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/1d9add777fbb83cb0419245aefe1f2ae-0" alt="图片描述"></p>
<h3 id="配置-PostgreSQL-实例"><a href="#配置-PostgreSQL-实例" class="headerlink" title="配置 PostgreSQL 实例"></a>配置 PostgreSQL 实例</h3><p>在 PostgreSQL 实例中加载 SequoiaDB 的连接驱动并配置连接参数。</p>
<h4 id="加载-SequoiaDB-连接驱动"><a href="#加载-SequoiaDB-连接驱动" class="headerlink" title="加载 SequoiaDB 连接驱动"></a>加载 SequoiaDB 连接驱动</h4><p>1）登录到 PostgreSQL 实例 Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5432 company</span><br></pre></td></tr></table></figure></div>

<p>2）加载 SequoiaDB 连接驱动；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION sdb_fdw;</span><br></pre></td></tr></table></figure></div>

<h4 id="配置与-SequoiaDB-连接参数"><a href="#配置与-SequoiaDB-连接参数" class="headerlink" title="配置与 SequoiaDB 连接参数"></a>配置与 SequoiaDB 连接参数</h4><p>在 PostgreSQL 实例中配置 SequoiaDB 连接参数：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SERVER</span> sdb_server <span class="keyword">FOREIGN</span> <span class="keyword">DATA</span> WRAPPER sdb_fdw </span><br><span class="line">OPTIONS </span><br><span class="line">(</span><br><span class="line">address <span class="string">'127.0.0.1'</span>, </span><br><span class="line">service <span class="string">'11810'</span>, </span><br><span class="line"><span class="keyword">user</span> <span class="string">''</span>, </span><br><span class="line"><span class="keyword">password</span> <span class="string">''</span>, </span><br><span class="line">preferedinstance <span class="string">'A'</span>, </span><br><span class="line"><span class="keyword">transaction</span> <span class="string">'on'</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li>如果没有配置数据库密码验证，可以忽略 user 与 password 字段。</li>
<li>如果需要提供多个协调节点地址，options 中的 address 字段可以按格式 ‘ip1:port1,ip2:port2,ip3:port3’填写。此时，service 字段可填写任意一个非空字符串。</li>
<li>preferedinstance 设置 SequoiaDB 的连接属性。多个属性以逗号分隔，如：preferedinstance ‘1,2,A’。详细配置请参考 preferedinstance 取值</li>
<li>preferedinstancemode 设置 preferedinstance 的选择模式</li>
<li>sessiontimeout 设置会话超时时间 如：sessiontimeout ‘100’</li>
<li>transaction 设置 SequoiaDB 是否开启事务，默认为 off。开启为 on</li>
<li>cipher 设置是否使用加密文件输入密码，默认为 off。开启为 on</li>
<li>token 设置加密口令</li>
<li>cipherfile 设置加密文件，默认为 ./passwd</li>
</ul>
</blockquote>
<h3 id="实例与数据引擎中集合关联"><a href="#实例与数据引擎中集合关联" class="headerlink" title="实例与数据引擎中集合关联"></a>实例与数据引擎中集合关联</h3><p>将 PostgreSQL 实例中的外部表与 SequoiaDB 中的集合空间、集合关联。</p>
<p>1）创建 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<p>2）查询数据，验证是否能够访问数据引擎；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li>集合空间与集合必须已经存在于 SequoiaDB，否则查询出错。</li>
<li>如果需要对接 SequoiaDB 的 decimal 字段，则需要在 options 中指定 decimal ‘on’ 。</li>
<li>pushdownsort 设置是否下压排序条件到 SequoiaDB，默认为 on，关闭为 off。</li>
<li>pushdownlimit 设置是否下压 limit 和 offset 条件到 SequoiaDB，默认为 on，关闭为 off。</li>
<li>开启 pushdownlimit 时，必须同时开启 pushdownsort，否则可能会造成结果非预期的问题。</li>
<li>默认情况下，表的字段映射到 SequoiaDB 中为小写字符，如果强制指定字段为大写字符，创建方式参考“<a href="http://doc.sequoiadb.com/cn/index-cat_id-1432190715-edition_id-302" target="_blank" rel="noopener">注意事项1</a>”。</li>
<li>映射 SequoiaDB 的数组类型，创建方式参考“<a href="http://doc.sequoiadb.com/cn/index-cat_id-1432190715-edition_id-302" target="_blank" rel="noopener">注意事项2</a>”。</li>
</ul>
</blockquote>
<h3 id="实例进行数据操作"><a href="#实例进行数据操作" class="headerlink" title="实例进行数据操作"></a>实例进行数据操作</h3><p>使用 PostgreSQL 实例操作关联表中的数据。</p>
<h4 id="通过关联表插入数据"><a href="#通过关联表插入数据" class="headerlink" title="通过关联表插入数据"></a>通过关联表插入数据</h4><p>在 PostgreSQL 实例中向外部表 employee 中插入数据：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> (<span class="number">10001</span>, <span class="string">'Georgi'</span>, <span class="number">48</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> (<span class="number">10002</span>, <span class="string">'Bezalel'</span>, <span class="number">21</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="查询-employee-表中的数据"><a href="#查询-employee-表中的数据" class="headerlink" title="查询 employee 表中的数据"></a>查询 employee 表中的数据</h4><p>查询 PostgreSQL 实例外部表的数据：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/e81f99febb12d0512ea81b35dd5cc318-0" alt="图片描述"></p>
]]></content>
      <categories>
        <category>-SequoiaDB-PostgreSql</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -PostgreSql</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful API理论</title>
    <url>/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h3><ul>
<li>Rest就是Representational State Transfer（状态表述转换）的简写</li>
<li>它描述了Webyingyong到底是怎么样设计才算是优良的，这里定义了以下三点：<ol>
<li>一组网页的网络</li>
<li>在这些网页上，用户可以通过点击链接来前进（状态转换）</li>
<li>点击链接的结果是下一个网页（表示程序的下一个状态）被传输到用户那里，并渲染好给用户。</li>
</ol>
</li>
<li>Rest是一种架构风格，而不是规范或者标准，它需要使用一些规范、协议或者标准来实现这种架构风格，但它又与协议无关。Json和Http并不是Rest强制使用的，只是比较多的人用Json和Http来实现Rest架构风格。</li>
</ul>
<h3 id="Rest的优点"><a href="#Rest的优点" class="headerlink" title="Rest的优点"></a>Rest的优点</h3><ol>
<li>性能：由于Rest在通讯上是比较简单和高效的。</li>
<li>组件交互的可扩展性：一般分布式都有这个优点。</li>
<li>组件的可修改性：关注点分离，可以使各个组件以最小的成本和风险进行修改（各自进化）。</li>
<li>可移植性：Rest跟平台或技术都无关，任何平台都可以使用Rest风格来构建应用。</li>
<li>可靠性：Rest提出的是一种无状态约束，这种约束就可以在系统发生故障后轻松地恢复系统。像传统的Mvc就是有状态的，即Cookie和Session</li>
<li>可视性</li>
</ol>
<h3 id="Rest的约束"><a href="#Rest的约束" class="headerlink" title="Rest的约束"></a>Rest的约束</h3><ol>
<li>客户端-服务器（前后端分离）</li>
<li>无状态：服务器无须记住客户端的状态，即客户端会记录自己的状态</li>
<li>统一的资源接口/界面<ol>
<li>资源的标识（URI）</li>
<li>通过表述来对资源进行操纵</li>
<li>带有自我描述信息</li>
<li>超媒体作为应用程序状态的引擎（HATEOAS）</li>
</ol>
</li>
<li>多层系统 ：系统中的每一层只知道自己的上一层或下一层。</li>
<li>可缓存：缓存响应数据，可以减少客户端感知资源的响应时间，提高可用性和可靠性，客户端可以选择从缓存或数据源获取数据。</li>
<li>按需编码（可选约束）</li>
</ol>
<h3 id="Richardson成熟度模型"><a href="#Richardson成熟度模型" class="headerlink" title="Richardson成熟度模型"></a>Richardson成熟度模型</h3><ul>
<li>Level0，POX沼泽：只使用了Http协议</li>
<li>Level1，资源：每个资源都映射到不同的URI，但Http动词没有用对</li>
<li>Level2，动词：正确地使用了Http动词</li>
<li>Level3，超媒体：支持HATEOAS</li>
<li>当WebApi达到Level3后，才有可能是一个Restful Api。</li>
</ul>
<h3 id="资源命名"><a href="#资源命名" class="headerlink" title="资源命名"></a>资源命名</h3><h4 id="使用名词，而不是动词"><a href="#使用名词，而不是动词" class="headerlink" title="使用名词，而不是动词"></a>使用名词，而不是动词</h4><ul>
<li><p>比如：我想获取系统中所有地用户，错误地URI：api/getusers</p>
</li>
<li><p>在Rest中，获取是一个动词，应该由Http动词来表示，所以正确的URI是：GET api/users</p>
</li>
</ul>
<h4 id="要体现资源的结构-关系"><a href="#要体现资源的结构-关系" class="headerlink" title="要体现资源的结构/关系"></a>要体现资源的结构/关系</h4><ul>
<li>假如后端Api由若干种资源，而用户这个资源于其他的资源并没有直接的关系，这样的话获取用户资源的URI应该是api/users，而不是api/products/users，因为user和product没有直接的关系。</li>
<li>通过id获取单个用户的URI应该是：api/users/{userId}</li>
<li>这样写的好处是可以让Api具有很好的可预测性和一致性。</li>
</ul>
<blockquote>
<p>例子：获取公司下面的员工信息和某一个员工的信息</p>
<p>URI分别是：</p>
<p>获取公司下面的员工信息：api/companies/{companyId}/employees</p>
<p>获取公司下面某一个员工的信息：</p>
<p>api/companies/{companyId}/employees/{employeeId}</p>
<p>这样就能体现公司资源和员工资源的关系</p>
</blockquote>
<h4 id="自定义查询"><a href="#自定义查询" class="headerlink" title="自定义查询"></a>自定义查询</h4><ul>
<li>有一些操作并不是针对于资源的，而是对资源的获取加以条件的，例如：排序、过滤、分页等，对于这些条件查询一般都是用查询字符串（query string）来表示</li>
</ul>
<blockquote>
<p>例子：获取所有的用户信息，并按照年龄从小到大进行排列</p>
<p>正确的做法是：api/users?orderby=age</p>
</blockquote>
<h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><ul>
<li>有一些需求总是无法满足Restful的约束，比如：想获取系统里所有用户的数量。</li>
<li>妥协的做法：api/users/total_amount_of_user</li>
</ul>
<h3 id="Http方法"><a href="#Http方法" class="headerlink" title="Http方法"></a>Http方法</h3><ul>
<li>不同的动作可以作用于相同的资源URI，下面使用公司的资源来表示各个Http方法是如何使用的</li>
</ul>
<h4 id="POST：添加一个公司信息"><a href="#POST：添加一个公司信息" class="headerlink" title="POST：添加一个公司信息"></a>POST：添加一个公司信息</h4><p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-05-05.png" alt="Snipaste_2020-09-20_16-05-05"></p>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><ul>
<li>获取一个公司信息</li>
</ul>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-06-24.png" alt="Snipaste_2020-09-20_16-06-24"></p>
<ul>
<li>获取集合资源（获取符合查询条件的公司资源）</li>
</ul>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-08-15.png" alt="Snipaste_2020-09-20_16-08-15"></p>
<h4 id="DELETE：删除一个公司信息"><a href="#DELETE：删除一个公司信息" class="headerlink" title="DELETE：删除一个公司信息"></a>DELETE：删除一个公司信息</h4><p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-09-31.png" alt="Snipaste_2020-09-20_16-09-31"></p>
<h4 id="PATCH：更新公司信息"><a href="#PATCH：更新公司信息" class="headerlink" title="PATCH：更新公司信息"></a>PATCH：更新公司信息</h4><p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-10-28.png" alt="Snipaste_2020-09-20_16-10-28"></p>
<h4 id="PUT：替换公司信息"><a href="#PUT：替换公司信息" class="headerlink" title="PUT：替换公司信息"></a>PUT：替换公司信息</h4><p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-12-11.png" alt="Snipaste_2020-09-20_16-12-11"></p>
<h4 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h4><ul>
<li>HEAD和GET几乎是一样的，只有一点不同：HEAD的API不应该返回相应的body，HEAD可以用来获取资源上的一些信息。</li>
<li>比如在一个支持缓存的系统中，Head就可以返回某一个资源是否是有效的或者资源最近是否被更新了，也可以用来检查URI是否存在，即资源是否存在。</li>
<li>Head的代码基本上和Get是一致的，但它并不返回响应体</li>
</ul>
<h4 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h4><ul>
<li>用来获取针对某个Api中的资源所支持的操作</li>
<li>一般在响应消息头中添加Allow来表示所允许的Http方法</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-13-24.png" alt="Snipaste_2020-09-20_16-13-24"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-59-36.png" alt="Snipaste_2020-09-20_17-59-36"></p>
<h3 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h3><ul>
<li><p>Http状态码主要是要来判断请求是否执行成功了，如果请求失败了，那失败的原因是什么，也就是谁应该为它负责。</p>
</li>
<li><p>状态码可分为以下5类：</p>
<ol>
<li>1xx：信息，服务器收到请求，需要请求方继续执行操作。</li>
<li>2xx：成功，服务器成功执行客户端所请求的操作。</li>
<li>3xx：重定向，需要进一步的操作以完成请求</li>
<li>4xx：客户端错误，请求包含语法错误或请求内容不正确。</li>
<li>5xx：服务端错误，服务器在处理请求的过程中发生了错误。</li>
</ol>
</li>
<li><p>以下是常见的状态码：</p>
</li>
</ul>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-34-15.png" alt="Snipaste_2020-09-20_16-34-15"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-34-38.png" alt="Snipaste_2020-09-20_16-34-38"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-34-59.png" alt="Snipaste_2020-09-20_16-34-59"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_16-35-10.png" alt="Snipaste_2020-09-20_16-35-10"></p>
<ul>
<li>还有一个422Unprocessable entity状态码，它通常是用来表示语义上有错误，即在服务器实体验证失败时可返回该状态码。</li>
</ul>
<h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><ul>
<li>针对一个响应，当有多种表述格式可用时（json、xml等），如何选取一个最佳的表述，这就需要进行内容协商。</li>
<li>当Http服务器对请求返回响应时，它不仅返回资源本身，也应在响应中指明资源的内容类型（Media Type），比如text/html，表示内容类型为text/html，前面text为主类型，html为子类型，当请求一个图片资源时，可以将它标记为image/jpg或image/gif</li>
</ul>
<h4 id="常见的媒体类型"><a href="#常见的媒体类型" class="headerlink" title="常见的媒体类型"></a>常见的媒体类型</h4><p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-17-41.png" alt="Snipaste_2020-09-20_17-17-41"></p>
<h4 id="Accept：输出"><a href="#Accept：输出" class="headerlink" title="Accept：输出"></a>Accept：输出</h4><ul>
<li>表示客户端可接受的响应内容类型</li>
<li>如果请求中没有Accept的值，则服务器就会返回Api默认的媒体类型数据，当客户端就有可能无法解析服务器发送的数据，如果客户端添加了Accept Header，但服务器并不支持客户端请求的媒体类型，这时候，服务器就应该返回406Not Acceptable来告诉客户端不支持这个媒体类型的数据。</li>
</ul>
<h4 id="Content-Type：输入"><a href="#Content-Type：输入" class="headerlink" title="Content-Type：输入"></a>Content-Type：输入</h4><ul>
<li>表示请求正文的Media Type（一般用于POST和PUT请求中）</li>
<li>在Http Header中，Content-Type一般有三种：<ol>
<li><code>application/x-www-form-urlencoded</code>：数据被编码为名称/值对。这是标准的编码格式。</li>
<li><code>multipart/form-data</code>： 数据被编码为一条消息，页上的每个控件对应消息中的一个部分。</li>
<li><code>text/plain</code>： 数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。postman软件里标的是RAW。</li>
</ol>
</li>
<li>当action为get时候，浏览器用<code>x-www-form-urlencoded</code>的编码方式把form数据转换成一个字串（name1=value1&amp;name2=value2…），然后把这个字串追加到url后面，用<code>?</code>分割，加载这个新的url。</li>
<li>当action为post时候，浏览器把form数据封装到http body中，然后发送到server。 如果没有<code>type=file</code>的控件，用默认的application/x-www-form-urlencoded就可以了。 但是如果有<code>type=file</code>的话，就要用到multipart/form-data了。</li>
<li>当action为post且Content-Type类型是<code>multipart/form-data</code>，浏览器会把整个表单以控件为单位分割，并为每个部分加上Content-Disposition(form-data或者file),Content-Type(默认为text/plain),name(控件<code>name</code>)等信息，并加上分割符(boundary)。</li>
</ul>
<h3 id="Http-Header"><a href="#Http-Header" class="headerlink" title="Http Header"></a>Http Header</h3><ul>
<li>Http Header分为请求头和响应头两部分</li>
<li>常见的请求消息头</li>
</ul>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-35-56.png" alt="Snipaste_2020-09-20_17-35-56"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-36-10.png" alt="Snipaste_2020-09-20_17-36-10"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-36-36.png" alt="Snipaste_2020-09-20_17-36-36"></p>
<ul>
<li>常见的响应消息头</li>
</ul>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-41-43.png" alt="Snipaste_2020-09-20_17-41-43"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-42-09.png" alt="Snipaste_2020-09-20_17-42-09"></p>
<p><img src="/2020/09/20/Restful-API%E7%90%86%E8%AE%BA/Snipaste_2020-09-20_17-42-19.png" alt="Snipaste_2020-09-20_17-42-19"></p>
]]></content>
      <categories>
        <category>-RestfulApi</category>
      </categories>
      <tags>
        <tag>-RestfulApi</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-PostgreSql数据导入导出</title>
    <url>/2020/12/03/SequoiaDB-PostgreSql%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h3 id="在-SequoiaDB-中建立集合空间和集合"><a href="#在-SequoiaDB-中建立集合空间和集合" class="headerlink" title="在 SequoiaDB 中建立集合空间和集合"></a>在 SequoiaDB 中建立集合空间和集合</h3><p>进入 SequoiaDB Shell，在 SequoiaDB 巨杉数据库引擎中创建 company 集合空间和 employee 集合。</p>
<p>1）使用 Linux 命令进入 SequoiaDB Shell 命令行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 JavaScript 语法，连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建 company_domain 数据域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 company 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建 employee 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）写入测试数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">db.company.employee.insert( &#123; <span class="string">"empno"</span>: i, <span class="string">"ename"</span>: <span class="string">"TEST"</span>, <span class="string">"age"</span>: <span class="number">20</span> &#125; ) </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>7）查询记录数；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<p>8）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>在 SequoiaSQL-PostgreSQL 实例中创建 company 数据库，为接下来验证 PostgreSQL 语法特性做准备。</p>
<p>1）在 PostgreSQL 实例创建数据库 company；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/sdb_sql_ctl createdb company myinst</span><br></pre></td></tr></table></figure></div>

<p>2）查看数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -l</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/1d9add777fbb83cb0419245aefe1f2ae-0" alt="图片描述"></p>
<h3 id="配置-PostgreSQL-实例"><a href="#配置-PostgreSQL-实例" class="headerlink" title="配置 PostgreSQL 实例"></a>配置 PostgreSQL 实例</h3><p>在 PostgreSQL 实例中加载 SequoiaDB 的连接驱动并配置连接参数。</p>
<h4 id="加载-SequoiaDB-连接驱动"><a href="#加载-SequoiaDB-连接驱动" class="headerlink" title="加载 SequoiaDB 连接驱动"></a>加载 SequoiaDB 连接驱动</h4><p>1）登录到 PostgreSQL 实例 Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5432 company</span><br></pre></td></tr></table></figure></div>

<p>2）加载 SequoiaDB 连接驱动；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> EXTENSION sdb_fdw;</span><br></pre></td></tr></table></figure></div>

<h4 id="配置与-SequoiaDB-连接参数"><a href="#配置与-SequoiaDB-连接参数" class="headerlink" title="配置与 SequoiaDB 连接参数"></a>配置与 SequoiaDB 连接参数</h4><p>在 PostgreSQL 实例中配置 SequoiaDB 连接参数：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SERVER</span> sdb_server <span class="keyword">FOREIGN</span> <span class="keyword">DATA</span> WRAPPER sdb_fdw </span><br><span class="line">OPTIONS </span><br><span class="line">(</span><br><span class="line">address <span class="string">'127.0.0.1'</span>, </span><br><span class="line">service <span class="string">'11810'</span>, </span><br><span class="line"><span class="keyword">user</span> <span class="string">''</span>, </span><br><span class="line"><span class="keyword">password</span> <span class="string">''</span>, </span><br><span class="line">preferedinstance <span class="string">'A'</span>, </span><br><span class="line"><span class="keyword">transaction</span> <span class="string">'on'</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h3 id="实例与数据引擎中集合关联"><a href="#实例与数据引擎中集合关联" class="headerlink" title="实例与数据引擎中集合关联"></a>实例与数据引擎中集合关联</h3><p>将 PostgreSQL 实例中的外部表与 SequoiaDB 中的集合空间、集合关联。</p>
<p>1）创建 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FOREIGN</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">SERVER</span> sdb_server</span><br><span class="line">OPTIONS ( collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, <span class="built_in">decimal</span> <span class="string">'on'</span> );</span><br></pre></td></tr></table></figure></div>

<p>2）查询数据，验证是否能够访问数据引擎；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><p>通过 COPY (SELECT…) 命令将外部表 employee 的数据导出为 .csv 文件；</p>
<p>1）导出数据到 .csv 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">COPY (SELECT * FROM employee) TO '/opt/sequoiasql/postgresql/employee.csv' with delimiter ',' csv;</span><br></pre></td></tr></table></figure></div>

<p>2）查看 csv 文件内容；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">\! more /opt/sequoiasql/postgresql/employee.csv</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>!前包含反斜线“\”，退出查看按 ctrl + c</p>
</blockquote>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/fdd9491c5cc9197d35feb3ba21cc045d-0" alt="图片描述"></p>
<p>3）退出 PostgreSQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>PostgreSQL 的 COPY FORM 命令不支持直接向外部表中导入数据，一旦数据需要恢复，可以用 SequoiaDB 的导入工具 sdbimprt 完成向集合导入数据。</p>
<h4 id="清空-employee-集合内数据"><a href="#清空-employee-集合内数据" class="headerlink" title="清空 employee 集合内数据"></a>清空 employee 集合内数据</h4><p>1）使用 Linux 命令进入 SequoiaDB Shell 命令行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 JavaScript 语法，连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）统计数据量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<p>4）清空集合内数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.truncate();</span><br></pre></td></tr></table></figure></div>

<p>5）验证是否被清空，查询结果为 0；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h4 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h4><p>1）通过 sdbimprt 工具从备份文件中恢复数据到 employee 数据集合中。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">sdbimprt <span class="attribute">--hosts</span>=localhost:11810 <span class="attribute">--type</span>=csv <span class="attribute">--file</span>=/opt/sequoiasql/postgresql/employee.csv <span class="attribute">--fields</span>=<span class="string">"empno int, ename string, age int"</span>  -c company -l employee</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/c035c40a92e5d4743cc430cda9639c2e-0" alt="图片描述"></p>
<p>2）登录到 PostgreSQL 实例 Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/postgresql/bin/psql -p 5432 company</span><br></pre></td></tr></table></figure></div>

<p>3）PostgreSQL shell 中验证数据量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>4）退出 PostgreSQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB-PostgreSql</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -PostgreSql</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-Spark创建元数据库</title>
    <url>/2020/12/03/SequoiaDB-Spark%E5%88%9B%E5%BB%BA%E5%85%83%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>本示例使用 MySQL 实例存储 Spark 引擎的元数据信息，故需要在 MySQL 实例中创建一个数据库进行存储。</p>
<ul>
<li>使用 MySQL Shell 连接 SequoiaDB-MySQL 实例；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 metauser 用户；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'metauser'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'metauser'</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>给 metauser 用户授权；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'metauser'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>刷新权限；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建元数据库；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> metastore <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">'latin1'</span> <span class="keyword">COLLATE</span> <span class="string">'latin1_bin'</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建测试数据库及数据表"><a href="#创建测试数据库及数据表" class="headerlink" title="创建测试数据库及数据表"></a>创建测试数据库及数据表</h3><p>在 SequoiaSQL-MySQL 实例中创建数据表，为 Spark 安装完毕后进行数据操作测试提供测试数据。SequoiaSQL-MySQL 实例默认使用 SequoiaDB 数据库存储引擎，在 MySQL 上创建表将同步在 SequoiaDB 上创建对应的分区表（hash分区，包含所有分区组）。自动分区时，分区键按顺序优先使用主键字段和唯一索引字段。如果两者都没有，则不做分区。</p>
<ul>
<li>创建数据库，并切换到该数据库；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建包含自增主键字段的 employee 表；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>), </span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进行基本的数据写入操作；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Jacky"</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Alice"</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>退出 MySQL Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="Spark-实例配置"><a href="#Spark-实例配置" class="headerlink" title="Spark 实例配置"></a>Spark 实例配置</h3><p>Spark 安装包和 MySQL 驱动已放置在 /home/sdbadmin/soft 目录下，本示例使用 Spark 的 standalone 模式安装。</p>
<h4 id="解压-Spark-安装包"><a href="#解压-Spark-安装包" class="headerlink" title="解压 Spark 安装包"></a>解压 Spark 安装包</h4><ul>
<li>进入安装包存放目录；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /home/sdbadmin/soft</span><br></pre></td></tr></table></figure></div>

<ul>
<li>解压安装包；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf spark-2.4.4-bin-hadoop2.7.tar.gz -C /opt</span><br></pre></td></tr></table></figure></div>

<h4 id="设置免密"><a href="#设置免密" class="headerlink" title="设置免密"></a>设置免密</h4><p>部署 Spark 实例为了实现自动化操作,需要配置 ssh 免密码登陆方式。</p>
<p>1）执行 ssh-keygen 生成公钥和密钥，执行后连续回车即可；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/a5607d8a34d509d9cbcf7d8efbb61f4e-0" alt="img"></p>
<p>2）执行 ssh-copy-id，把公钥拷贝到本机的 sdbadmin 用户；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id  sdbadmin@sdbserver1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>用户 sdbadmin 的密码是：<code>sdbadmin</code></p>
</blockquote>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/3066dab3a8830a2f5948170ce714ae5d-0" alt="img"></p>
<h4 id="设置-spark-env-sh"><a href="#设置-spark-env-sh" class="headerlink" title="设置 spark-env.sh"></a>设置 spark-env.sh</h4><ul>
<li>进入 Spark 的配置目录；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/spark-2.4.4-bin-hadoop2.7/conf</span><br></pre></td></tr></table></figure></div>

<ul>
<li>从模板中拷贝 spark-env.sh 文件；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure></div>

<ul>
<li>设置 Spark 实例的 Master；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo "SPARK_MASTER_HOST=sdbserver1" &gt;&gt; spark-env.sh</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看 spark-env.sh 文件是否设置成功；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat spark-env.sh</span><br></pre></td></tr></table></figure></div>

<h4 id="设置元数据库"><a href="#设置元数据库" class="headerlink" title="设置元数据库"></a>设置元数据库</h4><p>指定 Spark 实例的元数据信息存放的数据库信息。</p>
<ul>
<li>创建设置元数据数据库配置文件 hive-site.xml；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/spark-2.4.4-bin-hadoop2.7/conf/hive-site.xml &lt;&lt; EOF</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;jdbc:mysql://localhost:3306/metastore?useSSL=false&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;metauser&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;metauser&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;datanucleus.autoCreateSchema&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;creates necessary schema on a startup if one doesn't exist. set this to false, after creating it once&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检查是否创建成功；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat /opt/spark-2.4.4-bin-hadoop2.7/conf/hive-site.xml</span><br></pre></td></tr></table></figure></div>

<h4 id="拷贝相关驱动"><a href="#拷贝相关驱动" class="headerlink" title="拷贝相关驱动"></a>拷贝相关驱动</h4><ul>
<li><p>用户只要将 SequoiaDB for Spark 连接器 spark-sequoiadb_2.11-3.4.jar 和 SequoiaDB 的 Java 驱动 sequoiadb-driver-3.4.jar 加入 Spark 的 jar 目录即可，另外本示例使用了 MySQL 作为元数据存储数据库，也需要加入 MySQL 的 Java 驱动 mysql-jdbc.jar。</p>
</li>
<li><p>拷贝 spark-sequoiadb_2.11-3.4.jar 驱动连接器；</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /opt/sequoiadb/spark/spark-sequoiadb_2.11-3.4.jar  /opt/spark-2.4.4-bin-hadoop2.7/jars/</span><br></pre></td></tr></table></figure></div>

<ul>
<li>拷贝 SequoiaDB 的 java 驱动 sequoiadb-driver-3.4.jar；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /opt/sequoiadb/java/sequoiadb-driver-3.4.jar  /opt/spark-2.4.4-bin-hadoop2.7/jars/</span><br></pre></td></tr></table></figure></div>

<ul>
<li>拷贝 MySQL 的 java 驱动 mysql-jdbc.jar；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /home/sdbadmin/soft/mysql-jdbc.jar  /opt/spark-2.4.4-bin-hadoop2.7/jars/</span><br></pre></td></tr></table></figure></div>

<h4 id="设置-Spark-日志级别"><a href="#设置-Spark-日志级别" class="headerlink" title="设置 Spark 日志级别"></a>设置 Spark 日志级别</h4><ul>
<li><p>由于 Spark 默认日志级别为 INFO ，运行 spark-sql 客户端时会打印大量日志输出屏幕，为了避免这个问题把日志级别改* 为 ERROR。</p>
</li>
<li><p>拷贝 log4j.properties；</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp log4j.properties.template  log4j.properties</span><br></pre></td></tr></table></figure></div>

<ul>
<li>log4j.properties 中设置日志级别；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sed -i 's/log4j.rootCategory=INFO, console/log4j.rootCategory=ERROR, console/g' log4j.properties</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检查日志输出配置是否成功；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat log4j.properties</span><br></pre></td></tr></table></figure></div>

<h3 id="测试-SparkSQL-实例"><a href="#测试-SparkSQL-实例" class="headerlink" title="测试 SparkSQL 实例"></a>测试 SparkSQL 实例</h3><p>之前的小节已经创建了 Spark 元数据库，并且通过 SequoiaSQL-MySQL 实例创建了分区表。本小节将对 SparkSQL 实例进行测试。</p>
<ul>
<li>进入 Spark 的安装目录；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line">cd /opt/spark<span class="number">-2.4</span><span class="number">.4</span>-bin-hadoop2<span class="number">.7</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>启动 Spark；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看 Spark 的 master 和 worker 是否启动完成；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1541/1207281/685430475a7abba486a0208de223bc65-0" alt="img"></p>
<ul>
<li>启动 spark-sql 客户端；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/spark-sql</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 company 数据库；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建映射表；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> company.employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="keyword">STRING</span>,</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) <span class="keyword">USING</span> com.sequoiadb.spark OPTIONS (host <span class="string">'localhost:11810'</span>, collectionspace <span class="string">'company'</span>, collection <span class="string">'employee'</span>, username <span class="string">''</span>, <span class="keyword">password</span> <span class="string">''</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li><code>host</code> 参数指定 SequoiaDB 数据库的协调节点/独立节点地址，多个地址以”,”分隔</li>
<li><code>collectionspace</code> 参数指定 SequoiaDB 数据库的集合空间名，该集合空间必须已经存在</li>
<li><code>collection</code> 参数指定 SequoiaDB 数据库的集合名，该集合必须已经存在且属于 <code>collectionspace</code> 参数所指定的集合空间</li>
<li><code>username</code> 参数指定 SequoiaDB 数据库的连接用户名，若 SequoiaDB 数据库没有配置用户则设为空串(‘’)</li>
<li><code>password</code> 参数指定 SequoiaDB 数据库的连接用户对应的密码，若 SequoiaDB 数据库没有配置用户则设为空串(‘’)</li>
</ul>
</blockquote>
<ul>
<li>测试运行 sql；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(age) <span class="keyword">FROM</span> company.employee;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>退出 spark-sql 客户端；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">exit;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB-Spark</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-Spark实例创建与使用</title>
    <url>/2020/12/04/SequoiaDB-Spark%E5%AE%9E%E4%BE%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="SequoiaDB-Spark实例创建与使用"><a href="#SequoiaDB-Spark实例创建与使用" class="headerlink" title="SequoiaDB-Spark实例创建与使用"></a>SequoiaDB-Spark实例创建与使用</h2><h3 id="安装-Spark-实例"><a href="#安装-Spark-实例" class="headerlink" title="安装 Spark 实例"></a>安装 Spark 实例</h3><p>下面开始安装 Spark 实例，并对 Spark 实例进行必要的配置。</p>
<h4 id="解压-Spark-安装包"><a href="#解压-Spark-安装包" class="headerlink" title="解压 Spark 安装包"></a>解压 Spark 安装包</h4><p>1）检查 Spark 安装包；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls -trl /home/sdbadmin/soft/</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/bb4c027c1c181b51b6b426634b031b90-0" alt="1542-610-1"></p>
<p>2）解压 Spark 安装包；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tar -zxf /home/sdbadmin/soft/spark-2.4.4-bin-hadoop2.7.tar.gz -C /opt</span><br></pre></td></tr></table></figure></div>

<h4 id="添加驱动包"><a href="#添加驱动包" class="headerlink" title="添加驱动包"></a>添加驱动包</h4><p>1）拷贝 SequoiaDB for Spark 的连接器到 Spark 的 jars 目录下；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /opt/sequoiadb/spark/spark-sequoiadb_2.11-3.4.jar /opt/spark-2.4.4-bin-hadoop2.7/jars/</span><br></pre></td></tr></table></figure></div>

<p>2）拷贝 MySQL 驱动到 Spark 的 jars 目录下；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /home/sdbadmin/soft/mysql-jdbc.jar /opt/spark-2.4.4-bin-hadoop2.7/jars/</span><br></pre></td></tr></table></figure></div>

<p>3）拷贝 SequoiaDB 的 JAVA 驱动到 Spark 的 jars 目录下；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /opt/sequoiadb/java/sequoiadb-driver-3.4.jar /opt/spark-2.4.4-bin-hadoop2.7/jars/</span><br></pre></td></tr></table></figure></div>

<h4 id="设置免密"><a href="#设置免密" class="headerlink" title="设置免密"></a>设置免密</h4><p>1）执行 ssh-keygen 生成公钥和密钥，执行后连续回车即可；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></div>

<p>2）执行 ssh-copy-id，把公钥拷贝到本机的 sdbadmin 用户；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id  sdbadmin@sdbserver1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>sdbadmin 的密码是：<code>sdbadmin</code> 。 单机不需要拷贝到其它服务器上，如果是多机部署，需要配置所有服务器的互相关系。</p>
</blockquote>
<h4 id="配置-Spark"><a href="#配置-Spark" class="headerlink" title="配置 Spark"></a>配置 Spark</h4><p>1）设置 spark-env.sh；</p>
<p>从模板中复制一份 spark-env.sh 脚本：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /opt/spark-2.4.4-bin-hadoop2.7/conf/spark-env.sh.template /opt/spark-2.4.4-bin-hadoop2.7/conf/spark-env.sh</span><br></pre></td></tr></table></figure></div>

<p>在 spark-env.sh 中设置 WORKER 的数量和 MASTER 的 IP；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo "SPARK_WORKER_INSTANCES=2" &gt;&gt; /opt/spark-2.4.4-bin-hadoop2.7/conf/spark-env.sh</span><br><span class="line">echo "SPARK_MASTER_IP=127.0.0.1" &gt;&gt; /opt/spark-2.4.4-bin-hadoop2.7/conf/spark-env.sh</span><br></pre></td></tr></table></figure></div>

<p>2）复制以下代码到实验环境终端执行，用于创建设置元数据信息的数据库配置文件 hive-site.xml；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /opt/spark-2.4.4-bin-hadoop2.7/conf/hive-site.xml &lt;&lt; EOF</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hive.metastore.schema.verification&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;false&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;jdbc:mysql://localhost:3306/metastore&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;Driver class name for a JDBC metastore&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;metauser&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;metauser&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">      &lt;name&gt;datanucleus.autoCreateSchema&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">      &lt;description&gt;creates necessary schema on a startup if one doesn't exist. set this to false, after creating it once&lt;/description&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<h4 id="配置-Spark-元数据库"><a href="#配置-Spark-元数据库" class="headerlink" title="配置 Spark 元数据库"></a>配置 Spark 元数据库</h4><p>1）使用 Linux 命令进入 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）创建 metauser 用户；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'metauser'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'metauser'</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/dadb2110e578da42604ef2c2fe755b0a-0" alt="1542-610-3"></p>
<p>3）给 metauser 用户授权；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'metauser'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/be92979fc0c48b4df2524cb0567173f5-0" alt="1542-610-4"></p>
<p>4）创建 Spark 元数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> metastore <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">'latin1'</span> <span class="keyword">COLLATE</span> <span class="string">'latin1_bin'</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/402f6dd5278c7c5bed9bffc9f2a7169b-0" alt="1542-610-5"></p>
<p>5）刷新权限；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/a9d2c03cfd24eccc58195dae6d62afed-0" alt="1542-610-6"></p>
<p>6） 退出 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="启动-Spark-服务"><a href="#启动-Spark-服务" class="headerlink" title="启动 Spark 服务"></a>启动 Spark 服务</h3><p>本课程演示如何使用 Spark Thrift Server 服务连接 Spark 进行数据操作，所以需要启动 Spark 和 Spark Thrift Server 服务。</p>
<p>1） 启动 Spark；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/spark-2.4.4-bin-hadoop2.7/sbin/start-all.sh</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/31c9e3da7b150cd27fc3604ea891ba31-0" alt="1542-610-7"></p>
<p>2）启动 thriftserver 服务；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/spark-2.4.4-bin-hadoop2.7/sbin/start-thriftserver.sh</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/4575f232fdabedfc6054e9c59a30cb8d-0" alt="1542-610-8"></p>
<p>3） 检查进程启动状态；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></div>

<p>4） 检查端口监听状态；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 10000</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/c59b79202d81658745530ab4abf754ee-0" alt="1542-610-9"></p>
<blockquote>
<p>Note:</p>
<p>本实验环境性能较低，启动 Spark 的耗时较长，请耐心等待 10000 端口的监听状态；如截图所示，此时 10000 端口监听成功即可继续执行后续操作。</p>
</blockquote>
<h3 id="在-SequoiaDB-建立集合空间和集合"><a href="#在-SequoiaDB-建立集合空间和集合" class="headerlink" title="在 SequoiaDB 建立集合空间和集合"></a>在 SequoiaDB 建立集合空间和集合</h3><p>进入 SequoiaDB Shell，在 SequoiaDB 巨杉数据库引擎中创建 company 集合空间和 employee 集合。</p>
<p>1）使用 Linux 命令进入 SequoiaDB Shell 命令行；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 JavaScript 语法，连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>2）创建 company_domain 逻辑域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>3）创建 company 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 employee 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/8a986975b479eecf299fb94eeaeb682f-0" alt="1542-610-10"></p>
<h3 id="在-SparkSQL-关联集合空间和集合"><a href="#在-SparkSQL-关联集合空间和集合" class="headerlink" title="在 SparkSQL 关联集合空间和集合"></a>在 SparkSQL 关联集合空间和集合</h3><p>SparkSQL 通过 Spark-SequoiaDB 连接组件关联 SequoiaDB 的集合空间和集合，将 SequoiaDB 巨杉数据库引擎作为 SparkSQL 的数据源进行相应的数据计算。</p>
<h4 id="SparkSQL-与-SequoiaDB-的集合空间和集合关联"><a href="#SparkSQL-与-SequoiaDB-的集合空间和集合关联" class="headerlink" title="SparkSQL 与 SequoiaDB 的集合空间和集合关联"></a>SparkSQL 与 SequoiaDB 的集合空间和集合关联</h4><p>1）使用 Beeline 客户端工具连接至 thriftserver 服务；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/spark-2.4.4-bin-hadoop2.7/bin/beeline -u 'jdbc:hive2://localhost:10000'</span><br></pre></td></tr></table></figure></div>

<p>2）创建并切换至 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）创建 employee 表；</p>
<p>创建 employee 表，并且与 SequoiaDB 中的集合 employee 进行关联：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno  <span class="built_in">INT</span>,</span><br><span class="line">ename  <span class="keyword">STRING</span>,</span><br><span class="line">age    <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">USING</span> com.sequoiadb.spark OPTIONS </span><br><span class="line">( </span><br><span class="line">host <span class="string">'localhost:11810'</span>, </span><br><span class="line">collectionspace <span class="string">'company'</span>, </span><br><span class="line">collection <span class="string">'employee'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>当前环境未开启鉴权，因此忽略了 username 和 password 参数。</p>
</blockquote>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/5fa19ce996c1be2ecacd887f720171cc-0" alt="1542-610-11"></p>
<h4 id="SequoiaDB-SparkSQL-建表语法说明"><a href="#SequoiaDB-SparkSQL-建表语法说明" class="headerlink" title="SequoiaDB-SparkSQL 建表语法说明"></a>SequoiaDB-SparkSQL 建表语法说明</h4><p>在 SparkSQL 中关联 SequoiaDB 集合空间和集合的 SQL 语法如下；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &lt;[<span class="keyword">TEMPORARY</span>] <span class="keyword">TABLE</span> | <span class="keyword">TEMPORARY</span> <span class="keyword">VIEW</span>&gt; &lt;tableName&gt; [(<span class="keyword">SCHEMA</span>)]</span><br><span class="line"><span class="keyword">USING</span> com.sequoiadb.spark OPTIONS (&lt;<span class="keyword">option</span>&gt;, &lt;<span class="keyword">option</span>&gt;, ...);</span><br></pre></td></tr></table></figure></div>

<p>语法说明：</p>
<ul>
<li>TEMPORARY 表示为临时表或视图，只在创建表或视图的会话中有效，会话退出后自动删除。</li>
<li>表名后紧跟的 SCHEMA 可不填，连接器会自动生成。自动生成的 SCHEMA 字段顺序与集合中记录的顺序不一致，因此如果对 SCHEMA 的字段顺序有要求，应该显式定义 SCHEMA。</li>
<li>OPTIONS 为参数列表，参数是键和值都为字符串类型的键值对，其中值的前后需要有单引号，多个参数之间用逗号分隔。</li>
</ul>
<h4 id="SequoiaDB-SparkSQL-建表参数说明"><a href="#SequoiaDB-SparkSQL-建表参数说明" class="headerlink" title="SequoiaDB-SparkSQL 建表参数说明"></a>SequoiaDB-SparkSQL 建表参数说明</h4><p>下面是部分常用的 SequoiaDB-SparkSQL 建表参数说明，完整的建表参数请参考 <a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190712-edition_id-304" target="_blank" rel="noopener">SequoiaDB-SparkSQL 参数说明</a>。</p>
<ul>
<li>host ：SequoiaDB 协调节点/独立节点地址，多个地址以 “,” 分隔。例如：“server1:11810, server2:11810”。</li>
<li>collectionspace ：集合空间名称。</li>
<li>collection ：集合名称（不包含集合空间名称）。</li>
<li>username ：数据库用户名。</li>
<li>passwordtype : 密码类型，取值为“cleartext”或“file”，分别表示明文密码和文件密钥。</li>
<li>password ：数据库用户名对应的用户密码。</li>
<li>preferredinstance ：指定分区优先选择的节点实例。</li>
</ul>
<h3 id="在-Beeline-中进行数据操作"><a href="#在-Beeline-中进行数据操作" class="headerlink" title="在 Beeline 中进行数据操作"></a>在 Beeline 中进行数据操作</h3><p>在 Beeline 客户端中对 SequoiaDB 巨杉数据库的集合进行数据写入、查询操作。</p>
<p>1）写入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> ( <span class="number">10001</span>, <span class="string">'Georgi'</span>, <span class="number">48</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> ( <span class="number">10002</span>, <span class="string">'Bezalel'</span>, <span class="number">21</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> ( <span class="number">10003</span>, <span class="string">'Parto'</span>, <span class="number">33</span> );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> ( <span class="number">10004</span>, <span class="string">'Chirstian'</span>, <span class="number">40</span> );</span><br></pre></td></tr></table></figure></div>

<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/6d7c7a5d31b09c8bce451aa1c5a32a4d-0" alt="1542-610-12"></p>
<p>2）进行数据查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/41138f5eb03e5749b14c242e89cae8df-0" alt="1542-610-13"></p>
<h3 id="通过连接器自动生成-Schema-创建表"><a href="#通过连接器自动生成-Schema-创建表" class="headerlink" title="通过连接器自动生成 Schema 创建表"></a>通过连接器自动生成 Schema 创建表</h3><p>SequoiaDB-SparkSQL 支持通过连接器自动生成 SCHEMA 来创建关联表，这样可以在建表时不指定 SCHEMA 信息。</p>
<p>1）通过连接器自动生成 SCHEMA 来创建 employee_auto_schema 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee_auto_schema <span class="keyword">USING</span> com.sequoiadb.spark OPTIONS </span><br><span class="line">(</span><br><span class="line">host <span class="string">'localhost:11810'</span>,</span><br><span class="line">collectionspace <span class="string">'company'</span>,</span><br><span class="line">collection <span class="string">'employee'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>通过连接器自动生成 SCHEMA，要求在建表时 SequoiaDB 的关联集合中就已经存在数据记录。</p>
</blockquote>
<p>2）查看表 employee_auto_schema 的结构信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">DESC employee_auto_schema;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/f5d0ae41a071828789c2dcd7cfbb5896-0" alt="1542-610-14"></p>
<p>3）查询 employee_auto_schema 的数据记录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee_auto_schema;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>SparkSQL 表 employee 和 employee_auto_schema 关联的都是 SequoiaDB 中的集合 company.employee，所以这两张 SparkSQL 表的对应数据是完全一致的。</p>
</blockquote>
<h3 id="通过-SQL-结果集创建表"><a href="#通过-SQL-结果集创建表" class="headerlink" title="通过 SQL 结果集创建表"></a>通过 SQL 结果集创建表</h3><p>SequoiaDB-SparkSQL 支持 <code>CREATE TABLE ... AS SELECT ...</code> 语法，通过 SQL 结果集创建新表。</p>
<h4 id="通过-SQL-结果集创建表-1"><a href="#通过-SQL-结果集创建表-1" class="headerlink" title="通过 SQL 结果集创建表"></a>通过 SQL 结果集创建表</h4><p>1）通过已有表 employee 创建表 employee_bak，并将表中的数据存放到指定域和集合空间中；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee_bak <span class="keyword">USING</span> com.sequoiadb.spark OPTIONS </span><br><span class="line">(</span><br><span class="line">host <span class="string">'localhost:11810'</span>,</span><br><span class="line"><span class="keyword">domain</span> <span class="string">'company_domain'</span>,</span><br><span class="line">collectionspace <span class="string">'company'</span>,</span><br><span class="line">collection <span class="string">'employee_bak'</span>,</span><br><span class="line">autosplit <span class="literal">true</span>,</span><br><span class="line">shardingkey <span class="string">'&#123;_id:1&#125;'</span>,</span><br><span class="line">shardingtype <span class="string">'hash'</span>,</span><br><span class="line">compressiontype <span class="string">'lzw'</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/07b1ab4881eb54b734d27ff6105940f3-0" alt="图片描述"></p>
<p>2）查看 employee_bak 表中的数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee_bak;</span><br></pre></td></tr></table></figure></div>

<p>3）退出 Beeline Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">!quit</span><br></pre></td></tr></table></figure></div>

<h4 id="使用-CREATE-TABLE-AS-SELECT-语法建表参数说明"><a href="#使用-CREATE-TABLE-AS-SELECT-语法建表参数说明" class="headerlink" title="使用 CREATE TABLE ... AS SELECT ... 语法建表参数说明"></a>使用 <code>CREATE TABLE ... AS SELECT ...</code> 语法建表参数说明</h4><p>下面是部分 SequoiaDB-SparkSQL 使用 <code>CREATE TABLE ... AS SELECT ...</code> 语法建表的参数说明，完整的建表参数请参考 <a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190712-edition_id-304" target="_blank" rel="noopener">SequoiaDB-SparkSQL 参数说明</a>。</p>
<ul>
<li>host ：SequoiaDB 协调节点/独立节点地址，多个地址以 “,” 分隔。例如：“server1:11810, server2:11810”。</li>
<li>domain ：创建集合空间时指定所属域。如果集合空间已存在，则忽略该参数。</li>
<li>collectionspace ：集合空间名称。</li>
<li>collection ：集合名称（不包含集合空间名称）。</li>
<li>autosplit ：创建集合时指定是否自动切分。必须配合散列分区和域使用。</li>
<li>shardingkey ：创建集合时指定的分区键。</li>
<li>shardingtype ：创建集合时指定的分区类型，取值可以是“hash”和“range”，分别表示散列分区和范围分区。</li>
<li>compressiontype ：创建集合时指定的压缩类型，取值可以是“none”、“lzw”和“snappy”，“none”表示不进行压缩。</li>
</ul>
]]></content>
      <categories>
        <category>-SequoiaDB-Spark</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB备份与恢复</title>
    <url>/2020/12/02/SequoiaDB%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<h3 id="准备测试数据"><a href="#准备测试数据" class="headerlink" title="准备测试数据"></a>准备测试数据</h3><ul>
<li>通过 Linux 命令行进入 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 javascript 语言连接协调节点，获取数据库连接；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 company_domain 逻辑域；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 company 集合空间；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 employee 集合；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>写入测试数据。使用 javascript 的 for 循环向 employee 表写入1000条记录；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">db.company.employee.insert( &#123; <span class="attr">empno</span>: i, <span class="attr">ename</span>: <span class="string">"TEST"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="全量备份与增量备份"><a href="#全量备份与增量备份" class="headerlink" title="全量备份与增量备份"></a>全量备份与增量备份</h3><p>当前版本中，数据库备份支持全量备份和增量备份。全量备份过程中会阻塞数据库变更操作，即数据插入、更新、删除等变更操作会被阻塞直到全量备份完成才会执行；增量备份过程中不阻塞数据库变更操作。</p>
<ul>
<li>全量备份：备份整个数据库的配置、数据和日志（可选）；</li>
<li>增量备份：在上一个全量备份或增量备份的基础上备份新增的日志和配置；增量备份需要保证日志的连续性和一致性，如果日志不连续，或日志 Hash 校验不一致，则增量备份失败。因此，周期性的增量备份需要计算好日志和周期的关系，以防止日志覆写。</li>
</ul>
<p>在协调节点上对整个数据库或指定组进行备份，默认是只在该数据组主节点上进行备份。Catalog 编目组的名称固定为 SYSCatalogGroup。</p>
<p>使用 Sdb.backup() 命令可以进行备份。具体参数说明参考</p>
<ul>
<li><a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190664-edition_id-0" target="_blank" rel="noopener">数据备份</a></li>
</ul>
<h4 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h4><ul>
<li>执行集群全量备份命令</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.backup( &#123; <span class="attr">Name</span>: <span class="string">"cluster_backup"</span>, <span class="attr">Path</span>: <span class="string">"/tmp/%g"</span>, <span class="attr">Overwrite</span>: <span class="literal">true</span>, <span class="attr">Description</span>: <span class="string">"full backup"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>Path 中的 “%g”是一个通配符代表group name，当在协调节点上执行命令使用该参数时，需要使用通配符，以避免所有的节点往同一个路径下进行操作而导致未知IO错误。</p>
</blockquote>
<ul>
<li>退出 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="code"><pre><span class="line">quit<span class="comment">;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>检查备份文件是否生成；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls /tmp</span><br><span class="line">ls /tmp/group1/</span><br><span class="line">ls /tmp/group2/</span><br><span class="line">ls /tmp/group3/</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/860139b7833ae444ea57c68c8b469cc1-0" alt="全量备份"></p>
<p>可以看到，在/tmp目录下有 4 个文件夹，SYSCatalogGroup，group1，group2 和 group3 ，分别对应编目节点组，数据组 1 ，数据组 2，数据组 3。</p>
<h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><ul>
<li>通过 Linux 命令行进入 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 javascript 语言连接协调节点，获取数据库连接；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>写入 500 条增量数据；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1000</span>; i &lt; <span class="number">1500</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">db.company.employee.insert( &#123; <span class="attr">empno</span>: i, <span class="attr">ename</span>: <span class="string">"TEST"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行增量备份；这里EnsureInc表示为增量备份</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.backup( &#123; <span class="attr">Name</span>: <span class="string">"cluster_backup"</span>, <span class="attr">Path</span>: <span class="string">"/tmp/%g"</span>, <span class="attr">EnsureInc</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看备份信息；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.listBackup( &#123; <span class="attr">Path</span>: <span class="string">"/tmp"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/616748c8144c730f475978909e6040e9-0" alt="查看备份信息"></p>
<ul>
<li>退出 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="code"><pre><span class="line">quit<span class="comment">;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>检查备份文件是否生成；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls /tmp/group1/</span><br><span class="line">ls /tmp/group2/</span><br><span class="line">ls /tmp/group3/</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>增量备份的备份名应和上一次全量备份保持一致。</p>
</blockquote>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/662f9912e38d3acb9dba089437422791-0" alt="增量备份"></p>
<p>可以看到，相比于第一次备份生成的文件，本次增量备份在 group1 ，group2 和 group3 目录下新生成了两个文件。</p>
<h3 id="全量恢复与增量恢复"><a href="#全量恢复与增量恢复" class="headerlink" title="全量恢复与增量恢复"></a>全量恢复与增量恢复</h3><p>使用备份的数据恢复当前集群中的节点或者恢复到离线数据的说明：</p>
<ul>
<li>恢复当前集群中的节点：执行数据恢复必须确保该节点对应的数据组已停止运行，数据恢复首先会清空原节点的所有数据和日志，然后从备份的数据中恢复配置、数据和日志。</li>
<li>恢复到离线数据：可以将全量备份和增量备份的数据不断合并成一份与节点内数据完全相同格式的离线数据，可以在原节点故障后使用该离线数据实现快速恢复。</li>
</ul>
<p>如果一个分区组包含多个数据节点，必须停止该组中每个数据节点并进行恢复。如果将备份的数据恢复至非备份数据节点，添加 –isSelf 参数并设置成 false，同时设置相关的配置参数。</p>
<p>恢复分区组其他节点数据，恢复方式有以下几种：</p>
<ol>
<li>删除该分区组中其它数据节点的所有 .data 和 .idx 、.lobd、.lobm 文件以及 replicalog 日志，节点启动后会自行同步数据。</li>
<li>拷贝恢复节点的所有 .data 和 .idx 、.lobd、.lobm文件拷贝至其它数据节点的数据目录和索引目录下，以及将该节点的所有 replicalog 日志拷贝至其它数据节点的 replicalog 日志目录下。</li>
<li>将备份文件拷贝至其它数据节点，并通过 sdbrestore 工具恢复。</li>
</ol>
<p>使用 sdbrestore 可以进行数据恢复，具体参数说明参考下面这个链接：(sdbrestore)[<a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190666-edition_id-0]" target="_blank" rel="noopener">http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190666-edition_id-0]</a></p>
<h4 id="全量恢复"><a href="#全量恢复" class="headerlink" title="全量恢复"></a>全量恢复</h4><ul>
<li>通过 Linux 命令行进入 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 javascript 语言连接协调节点，获取数据库连接；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除集群上的集合空间；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.dropCS(<span class="string">"company"</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>退出 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>停止所有节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstop -t all</span><br></pre></td></tr></table></figure></div>

<ul>
<li>执行全量恢复操作；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbrestore -p /tmp/SYSCatalogGroup/ -n cluster_backup -b 0 -i 0</span><br><span class="line">sdbrestore -p /tmp/group1/ -n cluster_backup -b 0 -i 0</span><br><span class="line">sdbrestore -p /tmp/group2/ -n cluster_backup -b 0 -i 0</span><br><span class="line">sdbrestore -p /tmp/group3/ -n cluster_backup -b 0 -i 0</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>-b 后面带的参数代表需要从第几次备份开始恢复，从 0 开始算起，缺省由系统自动计算 ( -1 )。</p>
<p>-i 后面带的参数代表需要恢复到第几次数据备份，从 0 开始算起，缺省恢复到最后一次 ( -1 )。</p>
</blockquote>
<ul>
<li>启动节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstart -t all</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>执行全量恢复时要先停节点，恢复完后再启动，为了方便，将整个集群停下来 恢复的时候需要按节点恢复，分别是编目节点，数据组1，数据组2，数据组3</p>
</blockquote>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/53609c8eb609c2a778a322de7000afe2-0" alt="全量恢复1"></p>
<ul>
<li>检查数据是否正确，此时只能查到集合中的第一次插入的数据；</li>
</ul>
<p>通过 Linux 命令行进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>统计 company.employee 数据量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/e8051268e56d055dfcae88ea41d1cf0d-0" alt="全量恢复后检查"></p>
<p>退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<p>此时只能看到第一次插入的 1000 条记录，第二次插入的 500 条记录看不到。</p>
<h4 id="增量恢复"><a href="#增量恢复" class="headerlink" title="增量恢复"></a>增量恢复</h4><ul>
<li>停止所有节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstop -t all</span><br></pre></td></tr></table></figure></div>

<ul>
<li>增量恢复操作；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbrestore -p /tmp/group1/ -n cluster_backup -b -1</span><br><span class="line">sdbrestore -p /tmp/group2/ -n cluster_backup -b -1</span><br><span class="line">sdbrestore -p /tmp/group3/ -n cluster_backup -b -1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>启动节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstart -t all</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/06a5a1854dc2c701d95ddb28bc11eca8-0" alt="增量恢复"></p>
<ul>
<li>检查数据是否正确，此时能看到第二次插入的记录； 通过 Linux 命令行进入 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>统计 company.employee 数据量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSS"><figure class="iseeu highlight /css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.company</span><span class="selector-class">.employee</span><span class="selector-class">.count</span>();</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/9b94fac37f6cae4b2452ff443278a2db-0" alt="增量恢复后检查"></p>
<p>退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ABNF"><figure class="iseeu highlight /abnf"><table><tr><td class="code"><pre><span class="line">quit<span class="comment">;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB使用shell来创建集群并进行部署并创建实例</title>
    <url>/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="安装SequoiaDB"><a href="#安装SequoiaDB" class="headerlink" title="安装SequoiaDB"></a>安装SequoiaDB</h3><p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-26_14-09-34.png" alt="Snipaste_2020-11-26_14-09-34"></p>
<ul>
<li>先创建三台虚拟机，然后将ip配置为192.168.xx.11-13，然后配置hostname和hosts</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">hostname sdb1</span><br><span class="line">hostname sdb2</span><br><span class="line">hostname sdb3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将下面的内容追加到/etc/hosts中</span></span><br><span class="line">192.168.xx.11 sdb1</span><br><span class="line">192.168.xx.12 sdb2</span><br><span class="line">192.168.xx.13 sdb3</span><br></pre></td></tr></table></figure></div>

<ul>
<li>关闭掉三台机子的防火墙，把开机自启动防火墙设置成禁止</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br><span class="line">systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></div>

<ul>
<li>安装SequoiaDB</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf sequoiadb-5.0.1-linux_x86_64.tar.gz</span><br><span class="line">cd sequoiadb-5.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> --mode表示安装时采用的模式，text表示使用shell交互模式，--SMS表示，最后的<span class="literal">true</span>表示启动SequoiaSAC</span></span><br><span class="line">./sequoiadb-5.0.1-linux_x86_64-installer.run --mode text --SMS true</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在安装完之后，就可以通过图形化界面或者shell来创建集群了。</li>
</ul>
<h3 id="使用shell创建集群"><a href="#使用shell创建集群" class="headerlink" title="使用shell创建集群"></a>使用shell创建集群</h3><ul>
<li>创建临时的协调节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用集群管理对象来创建临时的协调节点</span></span><br><span class="line">var oma = new Oma("localhost", 11790)</span><br><span class="line">oma.createCoord(18900, "/opt/sequoiadb/database/tmp/coord/18900")</span><br></pre></td></tr></table></figure></div>

<ul>
<li>启动临时协调节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">oma.startNode(18900)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>连接临时协调节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">var db = new Sdb("localhost", 18900)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建编目节点组</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">db.createCataRG("sdb1", 11800, "/opt/sequoiadb/database/catalog/11800")</span><br></pre></td></tr></table></figure></div>

<ul>
<li>获取编目节点组的句柄，用于创建其他编目节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">var rg = db.getRG(1)</span><br><span class="line">var node = rg.createNode("sdb2", 11800, "/opt/sequoiadb/database/catalog/11800")</span><br><span class="line">node.start()</span><br><span class="line">var node = rg.createNode("sdb3", 11800, "/opt/sequoiadb/database/catalog/11800")</span><br><span class="line">node.start()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用临时协调节点创建数据节点组group1，并创建数据节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">var rg = db.createRG("group1")</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在数据组group1中创建三个数据节点</span></span><br><span class="line">rg.createNode("sdb1", 11820, "/opt/sequoiadb/database/data/11820")</span><br><span class="line">rg.createNode("sdb2", 11820, "/opt/sequoiadb/database/data/11820")</span><br><span class="line">rg.createNode("sdb3", 11820, "/opt/sequoiadb/database/data/11820")</span><br><span class="line">rg.start()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>再使用临时协调节点创建数据节点组group2，并创建数据节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">var rg = db.createRG("group2")</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在数据组group2中创建三个数据节点</span></span><br><span class="line">rg.createNode("sdb1", 11830, "/opt/sequoiadb/database/data/11830")</span><br><span class="line">rg.createNode("sdb2", 11830, "/opt/sequoiadb/database/data/11830")</span><br><span class="line">rg.createNode("sdb3", 11830, "/opt/sequoiadb/database/data/11830")</span><br><span class="line">rg.start()</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>这样就创建了一个两分区三副本的一个数据集群</p>
</li>
<li><p>创建协调节点组并启动，然后删除之前的临时协调节点</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建协调节点组并启动</span></span><br><span class="line">var rg = db.createCoordRG()</span><br><span class="line">rg = db.getRG(2)</span><br><span class="line">rg.createNode("sdb1", 11810, "/opt/sequoiadb/database/coord/11810")</span><br><span class="line">rg.createNode("sdb2", 11810, "/opt/sequoiadb/database/coord/11810")</span><br><span class="line">rg.createNode("sdb3", 11810, "/opt/sequoiadb/database/coord/11810")</span><br><span class="line">rg.start()</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除之前的临时协调节点</span></span><br><span class="line">oma.stopNode(18900)</span><br><span class="line">oma.removeCoord(18900)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这样，一个集群就创建好了</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">SPARK_MASTER_PORT&#x3D;&quot;7077&quot;</span><br><span class="line">SPARK_MASTER_WEBUI_PORT&#x3D;&quot;8080&quot;</span><br><span class="line">SPARK_MASTER_IP&#x3D;&quot;sdb1&quot;</span><br><span class="line">SPARK_WORKER_INSTANCES&#x3D;&quot;1&quot;</span><br><span class="line">MASTER&#x3D;&quot;spark:&#x2F;&#x2F;$&#123;SPARK_MASTER_IP&#125;:$&#123;SPARK_MASTER_PORT&#125;&quot;</span><br><span class="line">SPARK_WORKER_MEMORY&#x3D;&quot;1g&quot;</span><br><span class="line">SPARK_WORKER_CORES&#x3D;1</span><br><span class="line">export JAVA_HOME&#x3D;&quot;&#x2F;root&#x2F;jdk1.8.0_202&quot;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建SparkSql实例"><a href="#创建SparkSql实例" class="headerlink" title="创建SparkSql实例"></a>创建SparkSql实例</h3><h4 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h4><ul>
<li>首先，为三台虚拟机sdb1、sdb2、sdb3解压JDK压缩包，并配置Java环境变量</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf ./jdk-8u202-linux-x64.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在/etc/profile的最后面添加</span></span><br><span class="line">export JAVA_HOME=[jdk目录]</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后重新进入用户，刷新环境变量</span></span><br><span class="line">su - root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用以下语句来验证配置是否正确</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure></div>

<ul>
<li>为三台虚拟机配置ssh，以便虚拟机之间互相连接时不用验证身份</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成ssh密钥，密钥将会在~/.ssh/id_rsa.pub生成</span></span><br><span class="line">ssh-keygen</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将生成的密钥拷贝到ssh连接认证密钥文件中（~/.ssh/authorized_keys）</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@localhost</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在其余两台虚拟机也执行以上两个操作，然后将sdb2和sdb3的密钥拷贝到sdb1的authorized_keys中，再将sdb1的authorized_keys复制到sdb2和sdb3中</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">scp ~/.ssh/authorized_keys root@sdb2:~/.ssh/</span><br><span class="line">scp ~/.ssh/authorized_keys root@sdb3:~/.ssh/</span><br></pre></td></tr></table></figure></div>

<h4 id="Spark配置"><a href="#Spark配置" class="headerlink" title="Spark配置"></a>Spark配置</h4><ul>
<li>在三台虚拟机中安装sparksql，并修改sparksql的环境配置</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf spark-2.4.7-bin-hadoop2.7.tgz</span><br><span class="line">cd spark-2.4.7-bin-hadoop2.7/conf</span><br><span class="line">cp spark-env.sh.template spark-env.sh</span><br><span class="line">vi spark-env.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在spark-env.sh文件中添加以下语句</span></span><br><span class="line">SPARK_MASTER_PORT="7077" # spark实例的端口</span><br><span class="line">SPARK_MASTER_WEBUI_PORT="8080" # spark的webui端口</span><br><span class="line">SPARK_MASTER_IP="sdb1" # spark的主宿主ip，这里可以指定宿主名</span><br><span class="line">SPARK_WORKER_INSTANCES="1"  # 指定spark的worker实例个数</span><br><span class="line">MASTER="spark://$&#123;SPARK_MASTER_IP&#125;:$&#123;SPARK_MASTER_PORT&#125;" # spark的连接url</span><br><span class="line">SPARK_WORKER_MEMORY="1g" # worker的内存容量</span><br><span class="line">SPARK_WORKER_CORES=1 # worker的核数</span><br><span class="line">export JAVA_HOME="/root/jdk1.8.0_202" # 指定JDK目录</span><br></pre></td></tr></table></figure></div>

<ul>
<li>再将spark-env.sh文件复制到sdb2和sdb3</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">scp spark-env.sh sdb2:/root/spark-2.4.7-bin-hadoop2.7/conf/</span><br><span class="line">scp spark-env.sh sdb3:/root/spark-2.4.7-bin-hadoop2.7/conf/</span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改spark的slaves，指定集群列表</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp slaves.template slaves</span><br><span class="line">vi slaves</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在slaves文件中添加以下语句</span></span><br><span class="line">sdb1</span><br><span class="line">sdb2</span><br><span class="line">sdb3</span><br></pre></td></tr></table></figure></div>

<ul>
<li>再将slaves文件复制到sdb2和sdb3</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">scp ./slaves sdb2:/root/spark-2.4.7-bin-hadoop2.7/conf/</span><br><span class="line">scp ./slaves sdb3:/root/spark-2.4.7-bin-hadoop2.7/conf/</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将sequoiadb的驱动jar包复制到spark的jars目录中</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在spark的目录下执行以下语句</span></span><br><span class="line">cp /opt/sequoiadb/java/sequoiadb-driver-5.0.1.jar jars/</span><br><span class="line">cp /opt/sequoiadb/spark/spark-sequoiadb_2.11-5.0.1.jar jars/</span><br></pre></td></tr></table></figure></div>

<h4 id="Spark运行"><a href="#Spark运行" class="headerlink" title="Spark运行"></a>Spark运行</h4><ul>
<li>在三台虚拟机中启动sparksql</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sbin/start-all.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在sdb1运行jps命令可以看到sdb1既有一个主节点，又有一个工作节点，而在sdb2和sdb3中没有主节点</span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure></div>

<ul>
<li>启动Thrift Server服务，使spark可以兼容HiveServer2（接口和协议），这样我们就可以使用hive的beeline访问Spark Thrift Server执行相关语句</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sbin/start-thriftserver.sh --master spark://sdb1:7077</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用beeline连接Thrift Server服务，在用户名密码上直接回车</span></span><br><span class="line">bin/beeline</span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_00-02-10.png" alt="Snipaste_2020-11-27_00-02-10"></p>
<h4 id="部署集合空间"><a href="#部署集合空间" class="headerlink" title="部署集合空间"></a>部署集合空间</h4><ul>
<li>使用巨杉数据库引擎的集合空间可以很容易地在不同的宿主之间操作同一个spark实例，具体步骤：</li>
<li>在sdb2中进入sequoiadb的shell环境</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - sdbadmin</span><br><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入shell环境后，执行下面语句</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个Sdb实例，用于连接SequoiaDB</span></span><br><span class="line">db = <span class="keyword">new</span> Sdb(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//在SequoiaDB中创建集合空间foo，并在空间中创建集合bar</span></span><br><span class="line">db.createCS(<span class="string">"foo"</span>).createCL(<span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在sdb1的beeline中创建数据表，并指定该表的宿主、集合空间、集合</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*using表示使用巨杉数据库引擎*/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">name</span> <span class="keyword">string</span>) <span class="keyword">using</span> com.sequoiadb.spark options (host <span class="string">"sdb1:11810, sdb2:11810, sdb3:11810"</span>, collectionspace <span class="string">"foo"</span>, collection <span class="string">"bar"</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在sdb2中往bar中插入数据</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line">db.foo.bar.insert(&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">"sequoiadb"</span>&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>插入后可以在sdb1中看到这条数据</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1</span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_00-13-45.png" alt="Snipaste_2020-11-27_00-13-45"></p>
<ul>
<li>同样，在sdb1中插入数据，在sdb2中也可以查看到，这个就不演示了</li>
</ul>
<h3 id="创建sequoiasql-mysql实例"><a href="#创建sequoiasql-mysql实例" class="headerlink" title="创建sequoiasql-mysql实例"></a>创建sequoiasql-mysql实例</h3><ul>
<li>首先，安装sequoiasql-mysql的服务器</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd sequoiadb-5.0.1</span><br><span class="line">./sequoiasql-mysql-5.0.1-linux_x86_64-installer.run --mode text</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入sdbadmin角色，再cd到<code>/opt/sequoiasql/mysql/</code>目录里</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - sdbadmin</span><br><span class="line">cd /opt/sequoiasql/mysql/</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用巨杉数据库提供的sdb_sql_ctl工具来部署mysql实例</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里默认端口是3306，可以使用-p来指定端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bin/sdb_sql_ctl addinst [实例名] -D [实例目录]</span></span><br><span class="line">bin/sdb_sql_ctl addinst mytest -D /opt/sequoiasql/mysql/database/3306</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看实例列表</span></span><br><span class="line">bin/sdb_sql_ctl listinst</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用status来查看mytest实例的状态</span></span><br><span class="line">bin/sdb_sql_ctl status mytest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止实例</span></span><br><span class="line">bin/sdb_sql_ctl stop [实例名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动实例</span></span><br><span class="line">bin/sdb_sql_ctl start [实例名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用delinst来删除实例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bin/sdb_sql_ctl delinst [实例名]</span></span><br><span class="line">bin/sdb_sql_ctl delinst mytest</span><br></pre></td></tr></table></figure></div>

<ul>
<li>启动完实例后，这个mysql实例已经在巨杉系统架构中进行管理了，进入mysql的shell环境</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -h 127.0.0.1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这时，创建出来的database和table都可以在sequoiadb的sdb工具查询到</li>
</ul>
<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_09-43-55.png" alt="MySql"></p>
<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_09-44-10.png" alt="SequoiaDB"></p>
<h3 id="创建sequoiasql-postgresql实例"><a href="#创建sequoiasql-postgresql实例" class="headerlink" title="创建sequoiasql-postgresql实例"></a>创建sequoiasql-postgresql实例</h3><ul>
<li>首先，安装sequoiasql-posgresql的服务器</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd sequoiadb-5.0.1</span><br><span class="line">./sequoiasql-postgresql-5.0.1-x86_64-installer.run --mode text</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入sdbadmin角色，再cd到<code>/opt/sequoiasql/postgresql/</code>目录里，创建一个database目录</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - sdbadmin</span><br><span class="line">cd /opt/sequoiasql/postgresql/</span><br><span class="line">mkdir database</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用巨杉数据库提供的sdb_sql_ctl工具来部署postgresql实例，这个和mysql一样</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里默认端口是5432，可以使用-p来指定端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bin/sdb_sql_ctl addinst [实例名] -D [实例目录]</span></span><br><span class="line">bin/sdb_sql_ctl addinst mytest -D /opt/sequoiasql/mysql/database/3306</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看实例列表</span></span><br><span class="line">bin/sdb_sql_ctl listinst</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用status来查看mytest实例的状态</span></span><br><span class="line">bin/sdb_sql_ctl status mytest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止实例</span></span><br><span class="line">bin/sdb_sql_ctl stop [实例名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动实例</span></span><br><span class="line">bin/sdb_sql_ctl start [实例名]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以使用delinst来删除实例</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> bin/sdb_sql_ctl delinst [实例名]</span></span><br><span class="line">bin/sdb_sql_ctl delinst mytest</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用<code>bin/createdb [数据库名称]</code>来创建pgsql的数据库，然后使用<code>bin/psql</code>进入pgsql的shell环境</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">bin/createdb foo</span><br><span class="line">bin/psql foo</span><br></pre></td></tr></table></figure></div>

<ul>
<li>加载 SequoiaDB 连接驱动</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">foo=# create extension sdb_fdw;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在pgsql中创建巨杉服务器，设置一些配置信息</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> address：表示该服务器对应的宿主，service：服务端口，transaction：是否开启事务，还有一些其他的配置项，可以到官网查看</span></span><br><span class="line">create server sdb_server foreign data wrapper sdb_fdw options(address 'localhost', service '11810', transaction 'on',);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建外表</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定服务器，并设置集合空间和集合</span></span><br><span class="line">create foreign table test(name text, id numeric) server sdb_server options(collectionspace 'foo', collection 'bar', decimal 'on');</span><br></pre></td></tr></table></figure></div>

<ul>
<li>现在，这个test表在sdb1中的psql中可以访问到，在sdb2中的sdb中也可以访问到</li>
</ul>
<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_09-59-38.png" alt="psql"></p>
<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_10-02-51.png" alt="sdb"></p>
<h3 id="同步MySql"><a href="#同步MySql" class="headerlink" title="同步MySql"></a>同步MySql</h3><ul>
<li>由于在sdb1使用mysql命令创建的数据表在sdb2中使用mysql命令访问不到，所以需要一个同步mysql命令的一个过程。即现在只做到sequoiadb层面的同步，但并没有做到在mysql层面上的同步，这里就需要使用一个meta_sync的工具</li>
</ul>
<p><img src="/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B/D:%5CMy_blog%5Csource_posts%5CSequoiaDB%E4%BD%BF%E7%94%A8shell%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E5%B9%B6%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%5CSnipaste_2020-11-27_10-22-11.png" alt="Snipaste_2020-11-27_10-22-11"></p>
<ul>
<li>首先切换到sdbadmin用户，在三台虚拟机登录mysql的shell，然后执行以下语句：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">'sdbadmin'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span>  <span class="string">'sdbadmin'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">all</span> <span class="keyword">on</span> *.* <span class="keyword">TO</span> <span class="string">'sdbadmin'</span>@<span class="string">'%'</span> <span class="keyword">with</span> <span class="keyword">grant</span>  <span class="keyword">option</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建存放同步日志auditlog目录，并修改实例的配置文件<code>auto.cnf</code></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir database/3306/auditlog</span><br><span class="line">vi database/3306/auto.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在[mysqld]部分添加以下内容：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载审计插件</span></span><br><span class="line">plugin-load=server_audit=server_audit.so</span><br><span class="line"><span class="meta">#</span><span class="bash"> 记录审计日志的操作类型，当用于元数据同步时仅记录 DDL 和 DCL 即可</span></span><br><span class="line">server_audit_events=QUERY_DDL,QUERY_DCL</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启审计</span></span><br><span class="line">server_audit_logging=ON</span><br><span class="line"><span class="meta">#</span><span class="bash"> 审计日志路径及文件名</span></span><br><span class="line">server_audit_file_path=/opt/sequoiasql/mysql/database/auditlog/server_audit.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制日志文件轮转，保持配置为 OFF 即可</span></span><br><span class="line">server_audit_file_rotate_now=OFF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 审计日志文件大小阈值，默认 10MB，超过该大小时将进行轮转，单位为byte</span></span><br><span class="line">server_audit_file_rotate_size=10485760</span><br><span class="line"><span class="meta">#</span><span class="bash"> 审计日志保留个数，超过后会丢弃最旧的</span></span><br><span class="line">server_audit_file_rotations=999</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出类型为文件</span></span><br><span class="line">server_audit_output_type=file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 限制每行查询日志的大小为100kb，若表比较复杂，对应的操作语句比较长，建议增大该值</span></span><br><span class="line">server_audit_query_log_limit=102400</span><br></pre></td></tr></table></figure></div>

<ul>
<li>切换至root用户，把server_audit.so复制到plugin目录下，修改权限使得sdbadmin用户可以运行它</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /opt/sequoiasql/mysql/tools/lib/release/server_audit.so /opt/sequoiasql/mysql/lib/plugin/</span><br><span class="line">chmod a+x /opt/sequoiasql/mysql/lib/plugin/server_audit.so</span><br></pre></td></tr></table></figure></div>

<ul>
<li>切换至sdbadmin用户，重启 MySQL 实例</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb_sql_ctl restart myinst</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在tools/metaSync目录中，有两个文件，一个是<code>config.sample</code>，另一个是<code>log.config.sample</code>，将它们拷贝到当前目录，并改名为<code>config</code>和<code>log.config</code>，注意这两个文件的配置需要根据情况进行修改</li>
<li>在三台虚拟机中启动工具</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">python /opt/sequoiasql/mysql/tools/metaSync/meta_sync.py &amp;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>完成环境配置后，可通过在各实例进行少量 DDL 操作，进行简单的同步验证</li>
</ul>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><h4 id="卸载mysql服务"><a href="#卸载mysql服务" class="headerlink" title="卸载mysql服务"></a>卸载mysql服务</h4><ul>
<li>进入sdbadmin用户，停止mysql实例</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - sdbadmin</span><br><span class="line">bin/sdb_sql_ctl stop mytest</span><br></pre></td></tr></table></figure></div>

<ul>
<li>停止实例后，查看有没有关于mysql的进程，有的话就杀死进程</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ps -ef |grep mysql</span><br><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>杀死同步工具meta_sync的进程</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ps -ef |grep python</span><br><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>进入root用户，执行卸载程序</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line">cd /opt/sequoiasql/mysql/</span><br><span class="line">./uninstall</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果不想保存原数据的话，可以把mysql文件给删除</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiasql/</span><br><span class="line">rm -rf mysql/</span><br></pre></td></tr></table></figure></div>

<h4 id="卸载postgresql服务"><a href="#卸载postgresql服务" class="headerlink" title="卸载postgresql服务"></a>卸载postgresql服务</h4><ul>
<li>进入sdbadmin用户，停止posgresql实例</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - sdbadmin</span><br><span class="line">bin/sdb_sql_ctl stop mytest</span><br></pre></td></tr></table></figure></div>

<ul>
<li>停止实例后，进入root用户，执行卸载程序</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">su - root</span><br><span class="line">cd /opt/sequoiasql/postgresql/</span><br><span class="line">./uninstall</span><br></pre></td></tr></table></figure></div>

<ul>
<li>如果不想保存原数据的话，可以把postgresql文件给删除</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiasql/</span><br><span class="line">rm -rf postgresql/</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这样就把pgsql完全卸载了。</li>
</ul>
<h4 id="卸载sequoiadb服务"><a href="#卸载sequoiadb服务" class="headerlink" title="卸载sequoiadb服务"></a>卸载sequoiadb服务</h4><ul>
<li>进入sdbadmin用户，停止sequoiadb所有的节点</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstop -t all</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看关于sdb的进程，如果有sdbcm进程，就将其杀死</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ps -ef |grep sdb</span><br><span class="line">sdbcmtop</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看sdbadmin是否有运行与sdb相关的进程，有的话就将其杀死</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ps -ef |grep sdbadmin</span><br></pre></td></tr></table></figure></div>

<ul>
<li>切换到root用户，执行卸载程序</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiadb/</span><br><span class="line">./uninstall --mode text</span><br></pre></td></tr></table></figure></div>

<ul>
<li>最后将sequoiadb目录和sequoiasql目录删除</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">rm -rf /opt/sequoiadb</span><br><span class="line">rm -rf /opt/sequoiasql</span><br></pre></td></tr></table></figure></div>

<ul>
<li>这样就卸载完毕。</li>
</ul>
]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB集群扩容与缩容</title>
    <url>/2020/12/02/SequoiaDB%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9%E4%B8%8E%E7%BC%A9%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="创建域、集合空间、集合"><a href="#创建域、集合空间、集合" class="headerlink" title="创建域、集合空间、集合"></a>创建域、集合空间、集合</h3><ul>
<li>通过 Linux 命令行进入 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<ul>
<li>通过 javascript 语言连接协调节点，获取数据库连接；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 company_domain 逻辑域；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 company 集合空间；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建 employee 集合；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<h3 id="写入测试数据"><a href="#写入测试数据" class="headerlink" title="写入测试数据"></a>写入测试数据</h3><p>使用 JavaScript 的 for 循环向 employee 表写入 1000 条记录，用于测试。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">db.company.employee.insert( &#123; <span class="attr">ename</span>: <span class="string">"TEST"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125; ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><ul>
<li><p>集群扩容是通过在集群中新增分区组实现的，新增分区组可以在原有服务器也可以是新加入集群的服务器，本小节通过在本机新增 group4 展示扩容的场景。</p>
</li>
<li><p>创建一个新的数据组；</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createRG(<span class="string">"group4"</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在 group4 上创建1个数据节点副本；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.getRG(<span class="string">"group4"</span>).createNode(<span class="string">"sdbserver1"</span>, <span class="number">11850</span>, <span class="string">"/opt/sequoiadb/database/data/11850/"</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>createNode() 方法的定义格式有四个参数：host，service，dbpath，config，如上表所示，host，dbpath 为字符串类型，Service 类型支持 int 或 string ，必填；最后一个是 Json 对象，选填，如配置日志大小，是否打开事务等，具体可参考<a href="http://doc.sequoiadb.com/cn/SequoiaDB-cat_id-1432190643-edition_id-304" target="_blank" rel="noopener">数据库配置</a>。</p>
<p>格式：( “&lt;主机名&gt;”, “&lt;端口号&gt;”, “&lt;节点路径&gt;, “[ {key : value, … } ] )</p>
<p>createNode 方法的详细说明请参考：<a href="http://doc.sequoiadb.com/cn/index-cat_id-1432190867-edition_id-304" target="_blank" rel="noopener">createNode 方法说明</a>。</p>
</blockquote>
<ul>
<li>启动 group4 数据组；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.getRG(<span class="string">"group4"</span>).start();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数据域 company_domain 增加数据组；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.getDomain(<span class="string">"company_domain"</span>).addGroups( &#123; <span class="attr">Groups</span>: [ <span class="string">'group4'</span> ] &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将集合的数据迁移部分到新的数据组上；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.split(<span class="string">"group1"</span>, <span class="string">"group4"</span>, <span class="number">25</span>);</span><br><span class="line">db.company.employee.split(<span class="string">"group2"</span>, <span class="string">"group4"</span>, <span class="number">25</span>);</span><br><span class="line">db.company.employee.split(<span class="string">"group3"</span>, <span class="string">"group4"</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>以上split的含义时是把 group1、group2 和 group3 上的数据分别移25%到 group4 上。 split 方法的详细说明请参考：<a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190844-edition_id-304" target="_blank" rel="noopener">split 方法说明</a>。</p>
</blockquote>
<h4 id="分析数据分布"><a href="#分析数据分布" class="headerlink" title="分析数据分布"></a>分析数据分布</h4><ul>
<li>连接第一个数据分区的存储节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db1 = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11820</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计第一个数据分区的数据量；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db1.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>连接第二个数据分区的存储节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db2 = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11830</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计第二个数据分区的数据量；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db2.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>连接第三个数据分区的存储节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db3 = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11840</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计第三个数据分区的数据量；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db3.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>连接第四个数据分区的存储节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db4 = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11850</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计第四个数据分区的数据量；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db4.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/5d5401257e1bbbba329660efea88786f-0" alt="扩容完成"></p>
<p>可以看到，四个数据组上的记录数基本为平均分布。</p>
<h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><ul>
<li>本小节展示把 group4 的数据迁移到其他节点后把其剔出 company_domain 域，并把 group4 删除的操作。</li>
<li>将集合1在新数据组上的数据迁移回旧的数据组；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.split(<span class="string">"group4"</span>, <span class="string">"group1"</span>, <span class="number">33</span>);</span><br><span class="line">db.company.employee.split(<span class="string">"group4"</span>, <span class="string">"group2"</span>, <span class="number">50</span>);</span><br><span class="line">db.company.employee.split(<span class="string">"group4"</span>, <span class="string">"group3"</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计 group1，group2，group3 数据量，它们加起来等于 1000 ；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db1.company.employee.count();</span><br><span class="line">db2.company.employee.count();</span><br><span class="line">db3.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>把 group4 移出 company_domain 域；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.getDomain(<span class="string">"company_domain"</span>).removeGroups( &#123; <span class="attr">Groups</span>: [ <span class="string">'group4'</span> ] &#125; );</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除上一章新增加的数据组和数据节点；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.removeRG(<span class="string">"group4"</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计 employee 的数据量；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.count();</span><br></pre></td></tr></table></figure></div>

<p>数据量为1000，说明数据被正确迁移回来了。</p>
<h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><ul>
<li>关闭 db、db1、db2、db3、db4 数据库连接；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.close();</span><br><span class="line">db1.close();</span><br><span class="line">db2.close();</span><br><span class="line">db3.close();</span><br><span class="line">db4.close();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>退出 SequoiaDB Shell；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>检查集群状态是否正常；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdblist -l -m local</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1480/1207281/1ae2f9df5e7cccd13c81ee1ca97c5b21-0" alt="缩容完成"></p>
<p>可以看到，group4 已经从集群中剔除。</p>
]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis——AOF日志</title>
    <url>/2020/11/07/Redis%E2%80%94%E2%80%94AOF%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<ul>
<li>Redis是一个内存数据库，这时就会有一个问题，一旦服务器宕机，内存中的数据将会丢失。目前，Redis 的持久化主要有两大机制，即 AOF（Append Only File）日志和 RDB 快照。</li>
</ul>
<h3 id="AOF日志是如何实现的"><a href="#AOF日志是如何实现的" class="headerlink" title="AOF日志是如何实现的"></a>AOF日志是如何实现的</h3><ul>
<li>说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/40/1f/407f2686083afc37351cfd9107319a1f.jpg" alt="img"></p>
<ul>
<li>以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/4d/9f/4d120bee623642e75fdf1c0700623a9f.jpg" alt="img"></p>
<h3 id="先写日志的好处"><a href="#先写日志的好处" class="headerlink" title="先写日志的好处"></a>先写日志的好处</h3><ul>
<li>为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li>而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。</li>
<li>除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</li>
</ul>
<h3 id="先写日志的坏处"><a href="#先写日志的坏处" class="headerlink" title="先写日志的坏处"></a>先写日志的坏处</h3><ul>
<li>不过，AOF 也有两个潜在的风险：<ol>
<li>首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</li>
<li>其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li>
</ol>
</li>
</ul>
<h3 id="三种将日志写回磁盘的策略"><a href="#三种将日志写回磁盘的策略" class="headerlink" title="三种将日志写回磁盘的策略"></a>三种将日志写回磁盘的策略</h3><ul>
<li>其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值：<ol>
<li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>
<li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>
<li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ol>
</li>
<li>三种策略的优缺点：</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg" alt="img"></p>
<ul>
<li>但随着接收的写命令越来越多，AOF 文件会越来越大。这也就意味着，我们一定要小心 AOF 文件过大带来的性能问题。</li>
<li>这里的“性能问题”，主要在于以下三个方面：一是，文件系统本身对文件大小有限制，无法保存过大的文件；二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</li>
<li>这个时候，AOF 重写机制就登场了。</li>
</ul>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><ul>
<li>AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录键值对的最终状态，从而实现对 某个键值对 重复操作后产生的多条操作记录压缩成一条 的效果。进而实现压缩AOF文件的大小。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/65/08/6528c699fdcf40b404af57040bb8d208.jpg" alt="img"></p>
<ul>
<li>和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</li>
</ul>
<h3 id="一个拷贝，两处日志"><a href="#一个拷贝，两处日志" class="headerlink" title="一个拷贝，两处日志"></a>一个拷贝，两处日志</h3><ul>
<li>”一个拷贝“是指主线程fork子进程时，bgrewriteaof 子进程是会拷贝主线程的页表，即虚实映射关系，而不会拷贝物理内存。子进程复制了主线程页表，也能共享访问主线程的内存数据了，此时，类似于有了主线程的所有内存数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</li>
<li>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</li>
<li>而第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg" alt="img"></p>
<ul>
<li>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</li>
</ul>
]]></content>
      <categories>
        <category>-Redis</category>
      </categories>
      <tags>
        <tag>-Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB使用sdbtop监控</title>
    <url>/2020/12/02/SequoiaDB%E4%BD%BF%E7%94%A8sdbtop%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<p>sdbtop 是一个 SequoiaDB 数据库的性能监控工具。通过 sdbtop，可以监控和查看集群中各个节点的监视信息。</p>
<p>1）运行 sdbtop 并连接上数据库，其中协调节点服务端口为 11810；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbtop -i localhost -s 11810</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/6948319f219366c64fc9bdf0a1336288" alt="img"></p>
<p>2）按 “d” 键，切换至数据库性能指标界面，按 “Tab” 键切换至 “AVERAGE” 模式，查看此时数据库的性能指标；</p>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/be8c3ab8281e2cd78ce6a776585bc274" alt="img"></p>
<p>3）按 “q” 键，退出 sdbtop；</p>
<h4 id="sdbtop监控数据库状态"><a href="#sdbtop监控数据库状态" class="headerlink" title="sdbtop监控数据库状态"></a>sdbtop监控数据库状态</h4><p>在 SequoiaDB 安装目录 bin 中执行：sdbtop –h 显示参数信息</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>缩写</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–help</td>
<td>-h</td>
<td>返回基本帮助和用法文本</td>
</tr>
<tr>
<td>–version</td>
<td>-v</td>
<td>sdbtop版本信息</td>
</tr>
<tr>
<td>–confpath</td>
<td>-c</td>
<td>sdbtop 的配置文件，sdbtop 界面形态以及输出字段都依赖该文件（缺省使用默认配置文件）</td>
</tr>
<tr>
<td>–hostname</td>
<td></td>
<td>指定需要监控的主机名</td>
</tr>
<tr>
<td>–servicename</td>
<td></td>
<td>指定监控的端口服务名</td>
</tr>
<tr>
<td>–usrname</td>
<td></td>
<td>数据库用户名</td>
</tr>
<tr>
<td>–password</td>
<td></td>
<td>数据库密码</td>
</tr>
<tr>
<td>–ssl</td>
<td></td>
<td>使用 SSL 连接。</td>
</tr>
</tbody></table>
<h4 id="sdbtop组成部分"><a href="#sdbtop组成部分" class="headerlink" title="sdbtop组成部分"></a>sdbtop组成部分</h4><p>进入到sdbtop主窗口后，主要有三部分组成，头部区域、中间区域、底部区域。</p>
<p>头部区域主要包括版本信息、刷新频率（refresh）、快照模式（snapshotMode）、打印模式（displayMode）、快照获取模式（snapshotModeInput）、监控主机名（hostname）、监控端口服务名（servicename）、排序方式（sortingWay）、排序字段（sortingField）、过滤行号（filtering Number）、登录用户名（usrName）。</p>
<p>中间区域主要显示监控信息。具体快捷键如下：</p>
<p>主窗口选择快捷键说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>m</td>
<td>返回主窗口</td>
</tr>
<tr>
<td>s</td>
<td>列出数据库节点上的所有会话</td>
</tr>
<tr>
<td>c</td>
<td>列出数据库节点上的所有集合空间</td>
</tr>
<tr>
<td>t</td>
<td>列出数据库节点上的系统资源使用情况</td>
</tr>
<tr>
<td>d</td>
<td>列出数据库节点的数据库监视信息</td>
</tr>
</tbody></table>
<p>进入主窗口后快捷操作键说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>G</td>
<td>global_snapshot，监控所有的数据节点组</td>
</tr>
<tr>
<td>g</td>
<td>group_snapshot，指定监控某个数据节点组</td>
</tr>
<tr>
<td>n</td>
<td>node_snapshot，列出指定的数据库节点的监视信息</td>
</tr>
<tr>
<td>r</td>
<td>设置刷屏的时间间隔，单位秒/s</td>
</tr>
<tr>
<td>A</td>
<td>将监视信息按照某列进行顺序排序</td>
</tr>
<tr>
<td>D</td>
<td>将监视信息按照某列进行逆序排序</td>
</tr>
<tr>
<td>C</td>
<td>将监视信息按照某个条件进行筛选</td>
</tr>
<tr>
<td>Q</td>
<td>返回没有使用条件进行筛选前的监视信息</td>
</tr>
<tr>
<td>N</td>
<td>将监视信息中对应行号的记录过滤不显示</td>
</tr>
<tr>
<td>W</td>
<td>返回没有使用行号进行过滤前的监视信息</td>
</tr>
<tr>
<td>h</td>
<td>查看使用帮助</td>
</tr>
<tr>
<td>Esc</td>
<td>取消已进入的操作</td>
</tr>
<tr>
<td>Enter</td>
<td>返回上一次监视界面，（在已进入 help 帮助输出中有效）</td>
</tr>
<tr>
<td>F5</td>
<td>强制刷新后台监视信息</td>
</tr>
<tr>
<td>&lt;</td>
<td>向左移动，以查看隐藏的左边列的监视信息</td>
</tr>
<tr>
<td>&gt;</td>
<td>向右移动，以查看隐藏的右边列的监视信息</td>
</tr>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>Tab</td>
<td>切换数据计算的模式（绝对值，平均值，差值三个模式）</td>
</tr>
</tbody></table>
<h4 id="sdbtop监控内容"><a href="#sdbtop监控内容" class="headerlink" title="sdbtop监控内容"></a>sdbtop监控内容</h4><p>sdbtop提供了对数据库节点会话、集合空间、系统资源使用情况、数据库的监控单元。通过这些信息，用户可以了解当前数据库的连接信息以及连接的活动情况，数据库集合空间的分布以及使用情况，数据库集群的资源使用情况，以及数据库集群的读写、更新、删除、复制、索引读写等性能情况。</p>
<p>1）数据库会话监控；</p>
<p>进入主窗口，按‘s’键，列出数据库节点的所有会话信息</p>
<p>按‘Tab’键，可以看到屏幕左上方的‘displayMode’的值会发生切换</p>
<p>按‘r’键，在屏幕最下方输入‘2’，回车，设置刷新间隔时间，可以看到屏幕左上方的‘refresh’的值变为 2</p>
<p>按‘A’键，并输入‘TID’，列表结果按照 TID 进行顺序排序</p>
<p>按‘N’键，并输入1，列表中将原来行号为1的记录过滤不显示</p>
<p>按‘W’键，返回没有按行号进行过滤前的列表信息</p>
<p>按‘C’键，并输入‘TID：1034”进行筛选，则只显示 TID 值为1034的记录</p>
<p>按‘Q’键，返回没有按照筛选条件前的列表信息</p>
<p>按‘&lt;’或者‘&gt;’键，可以查看隐藏在左边或者右边的列</p>
<p>2）数据库集合空间监控 进入主窗口，按‘c’键，列出数据库节点上的所有集合空间</p>
<p>数据库节点上的所有集合空间可以从数据库 SDB_SNAP_COLLECTIONSPACES 快照中获取，在上述窗口中，各监控字段说明如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Name</td>
<td>字符串</td>
<td>集合空间名</td>
</tr>
<tr>
<td>PageSize</td>
<td>整型</td>
<td>集合空间数据页大小</td>
</tr>
<tr>
<td>Collection</td>
<td>字符串数组</td>
<td>集合空间中所包含的所有集合</td>
</tr>
<tr>
<td>Group.GroupName</td>
<td>字符串</td>
<td>该集合空间所在的分区组名列表</td>
</tr>
</tbody></table>
<p>3）数据库系统资源使用情况监控 进入主窗口，按‘t’键，列出数据库节点上的所有集合空间 快捷键功能可参考数据库会话监控。</p>
<p>数据库系统资源使用情况可以从数据库 SDB_SNAP_SYSTEM 快照中获取，在上述窗口中，各监控字段说明如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>UserCPU</td>
<td>浮点数</td>
<td>操作系统启动后所消耗的总用户 CPU（秒）</td>
</tr>
<tr>
<td>SysCPU</td>
<td>浮点数</td>
<td>操作系统启动后所消耗的总系统 CPU（秒）</td>
</tr>
<tr>
<td>IdleCPU</td>
<td>浮点数</td>
<td>操作系统启动后所消耗的总空闲 CPU（秒）</td>
</tr>
<tr>
<td>OtherCPU</td>
<td>浮点数</td>
<td>操作系统启动后所消耗的总其它 CPU（秒）</td>
</tr>
<tr>
<td>RAM</td>
<td>长整型</td>
<td>当前操作系统的总内存空间（字节）</td>
</tr>
<tr>
<td>FreeRAM</td>
<td>长整型</td>
<td>当前操作系统的空闲内存空间（字节）</td>
</tr>
<tr>
<td>MemorySwap</td>
<td>长整型</td>
<td>当前操作系统的总交换空间（字节）</td>
</tr>
<tr>
<td>FreeSwap</td>
<td>长整型</td>
<td>当前操作系统的空闲交换空间（字节）</td>
</tr>
<tr>
<td>VirtualMemory</td>
<td>长整型</td>
<td>当前操作系统的总虚拟空间（字节）</td>
</tr>
<tr>
<td>FreeVirtual</td>
<td>长整型</td>
<td>当前操作系统的空闲虚拟空间（字节）</td>
</tr>
<tr>
<td>DiskSpace</td>
<td>长整型</td>
<td>数据库路径总空间（字节）</td>
</tr>
<tr>
<td>FreeDiskSpace</td>
<td>长整型</td>
<td>数据库路径空闲空间（字节）</td>
</tr>
</tbody></table>
<p>4）数据库集群监控 进入主窗口，按‘d’键，列出数据库集群监控信息。 快捷键功能可参考数据库会话监控。</p>
<p>数据库集群监控信息可以从数据库 SDB_SNAP_DATABASE 快照中获取，在上述窗口中，各监控字段说明如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NumConnects</td>
<td>整型</td>
<td>数据库连接请求数量</td>
</tr>
<tr>
<td>DataRead</td>
<td>长整型</td>
<td>总数据读请求</td>
</tr>
<tr>
<td>IndexRead</td>
<td>长整型</td>
<td>总索引读请求</td>
</tr>
<tr>
<td>DataWrite</td>
<td>长整型</td>
<td>总数据写请求</td>
</tr>
<tr>
<td>IndexWrite</td>
<td>长整型</td>
<td>总索引写请求</td>
</tr>
<tr>
<td>Update</td>
<td>长整型</td>
<td>总更新记录数量</td>
</tr>
<tr>
<td>Delete</td>
<td>长整型</td>
<td>总删除记录数量</td>
</tr>
<tr>
<td>Insert</td>
<td>长整型</td>
<td>总插入记录数量</td>
</tr>
<tr>
<td>ReplUpdate</td>
<td>长整型</td>
<td>复制更新记录数量</td>
</tr>
<tr>
<td>ReplDelete</td>
<td>长整型</td>
<td>复制删除记录数量</td>
</tr>
<tr>
<td>ReplInsert</td>
<td>长整型</td>
<td>复制插入记录数量</td>
</tr>
<tr>
<td>Select</td>
<td>长整型</td>
<td>总选择记录数量</td>
</tr>
<tr>
<td>Read</td>
<td>长整型</td>
<td>总读取记录数量</td>
</tr>
<tr>
<td>ReadTime</td>
<td>长整型</td>
<td>总读取时间（毫秒）</td>
</tr>
<tr>
<td>WriteTime</td>
<td>长整型</td>
<td>总写入时间（毫秒）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记2——注入</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Spring5-x学习笔记2——注入"><a href="#Spring5-x学习笔记2——注入" class="headerlink" title="Spring5.x学习笔记2——注入"></a>Spring5.x学习笔记2——注入</h2><h3 id="什么是注入？"><a href="#什么是注入？" class="headerlink" title="什么是注入？"></a>什么是注入？</h3><p>注入：通过 Spring 工厂及配置文件，为所创建对象的成员变量赋值。</p>
<h3 id="为什么要注入？"><a href="#为什么要注入？" class="headerlink" title="为什么要注入？"></a>为什么要注入？</h3><ul>
<li>通过编码的⽅式，为成员变量进⾏赋值，存在耦合。</li>
<li>注入的好处：<strong>解耦合</strong>。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"/applicationContext.xml"</span>);</span><br><span class="line">    Person person = (Person) ctx.getBean(<span class="string">"person"</span>);</span><br><span class="line">    <span class="comment">// 通过代码为变量赋值, 存在耦合, 如果我们以后想修改变量的值, 需要修改代码, 重新编译</span></span><br><span class="line">    person.setId(<span class="number">1</span>);</span><br><span class="line">    person.setName(<span class="string">"zhenyu"</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure></div>

<h3 id="如何进行注入-开发步骤"><a href="#如何进行注入-开发步骤" class="headerlink" title="如何进行注入[开发步骤]"></a>如何进行注入[开发步骤]</h3><ul>
<li>类的成员变量提供 set get ⽅法</li>
<li>配置 spring 的配置⽂件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.yusael.basic.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>yusael<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></div>

<h3 id="Spring注入的原理分析-简易版"><a href="#Spring注入的原理分析-简易版" class="headerlink" title="Spring注入的原理分析(简易版)"></a>Spring注入的原理分析(简易版)</h3><p>Spring 底层通过<strong>调用对象属性对应的 set 方法</strong>，完成成员变量的赋值，这种⽅式也称为 <strong>Set注入</strong>。<br><img src="https://img-blog.csdnimg.cn/20200521181522851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Set注入详解"><a href="#Set注入详解" class="headerlink" title="Set注入详解"></a>Set注入详解</h3><h4 id="Set注入的变量类型"><a href="#Set注入的变量类型" class="headerlink" title="Set注入的变量类型"></a>Set注入的变量类型</h4><ul>
<li><strong>JDK内置类型</strong><br>8种基本类型 + String、数组类型、set集合、list集合、Map计划和、Properties集合。</li>
<li><strong>用户自定义类型</strong></li>
</ul>
<p>针对于不同类型的成员变量，在<code>&lt;property</code>标签中，需要嵌套其他标签:</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">	xxxxx</span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/2020052118232073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="JDK内置类型"><a href="#JDK内置类型" class="headerlink" title="JDK内置类型"></a>JDK内置类型</h4><ul>
<li>String+8种基本类型</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>yusael<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数组</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"emails"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>abc@qq.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>123@qq.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hello@qq.com<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Set集合</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tels"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>138xxxxxxxxxx<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>139xxxxxxxxxx<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>138xxxxxxxxxx<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="comment">&lt;!--set会自动去重--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<ul>
<li>List集合</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"addresses"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>China<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>Earth<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hell<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Map集合</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"qqs"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>12312312312<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>world<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>21314214214<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">123456789101112</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Properites</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"p"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key1"</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key2"</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"key3"</span>&gt;</span>value3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<ul>
<li>复杂JDK类型（Date、…）</li>
</ul>
<p>需要程序员⾃定义类型转换器，处理。</p>
<h3 id="用户自定义类型"><a href="#用户自定义类型" class="headerlink" title="用户自定义类型"></a>用户自定义类型</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>[开发步骤]：</p>
<ul>
<li>为成员变量提供 set get ⽅法</li>
<li>配置⽂件中进⾏注入（赋值）</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.yusael.dao.UserDAOImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>第⼀种赋值⽅式存在的问题：</p>
<ol>
<li>配置⽂件代码冗余；</li>
<li>被注入的对象 （UserDAO）多次创建，浪费（JVM)内存资源。</li>
</ol>
<p>[开发步骤]：</p>
<ul>
<li>为成员变量提供 set get ⽅法；</li>
<li>配置⽂件中进⾏配置；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.yusael.dao.UserDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<p>Spring4.x 废除了 <code>&lt;ref local=&quot;&quot;/&gt;</code> 基本等效 <code>&lt;ref bean=&quot;&quot;/&gt;</code>；</p>
<h3 id="Set注入的简化"><a href="#Set注入的简化" class="headerlink" title="Set注入的简化"></a>Set注入的简化</h3><h4 id="基于属性的简化"><a href="#基于属性的简化" class="headerlink" title="基于属性的简化"></a>基于属性的简化</h4><p>JDK 类型注入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure></div>

<p>JDK类型注入简化：<code>value</code> 属性只能简化 8种基本类型 + String 注入标签；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<hr>
<p>用户自定义类型注入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.yusael.dao.UserDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<p>用户自定义类型注入简化：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.yusael.dao.UserDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span> <span class="attr">ref</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<h4 id="基于p命名空间的简化"><a href="#基于p命名空间的简化" class="headerlink" title="基于p命名空间的简化"></a>基于p命名空间的简化</h4><p>JDK 类型注入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.yusael.basic.Person"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>10<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>yusael<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></div>

<p>JDK 类型注入 - 基于p命名空间的简化。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">name</span>=<span class="string">"p"</span> <span class="attr">class</span>=<span class="string">"com.yusael.basic.Person"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:name</span>=<span class="string">"yusael"</span> <span class="attr">p:id</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure></div>

<hr>
<p>用户自定义类型注入：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.yusael.dao.UserDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<p>用户自定义类型注入 - 基于p命名空间的简化。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.yusael.dao.UserDAOImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:userDAO-ref</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure></div>

<h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><ul>
<li><strong>注入</strong>：通过 Spring 的配置文件，为成员变量赋值；</li>
<li><strong>Set注入</strong>：Spring 调用 <strong>Set 方法</strong> 通过 配置文件 为成员变量赋值；</li>
<li><strong>构造注入</strong>：Spring 调用 <strong>构造方法</strong> 通过 配置文件 为成员变量赋值；</li>
</ul>
<h3 id="构造注入开发"><a href="#构造注入开发" class="headerlink" title="构造注入开发"></a>构造注入开发</h3><ul>
<li>提供有参构造方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Customer&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>spring 配置文件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.yusael.constructor.Customer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhenyu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>21<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></div>

<h3 id="构造方法重载"><a href="#构造方法重载" class="headerlink" title="构造方法重载"></a>构造方法重载</h3><h4 id="参数个数不同"><a href="#参数个数不同" class="headerlink" title="参数个数不同"></a>参数个数不同</h4><p>参数个数不同时，通过控制 <code>&lt;constructor-arg&gt;</code> 标签的数量进⾏区分；</p>
<p>如果只有一个参数的话，只需要一对 <code>&lt;constructor-arg&gt;</code> 标签：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.yusael.constructor.Customer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhenyu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<p>如果有两个参数的话，用两对 <code>&lt;constructor-arg&gt;</code> 标签，以此类推。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.yusael.constructor.Customer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>zhenyu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>22<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></div>

<h4 id="参数相同"><a href="#参数相同" class="headerlink" title="参数相同"></a>参数相同</h4><p><strong>构造参数个数相同时</strong>，通过在标签引入 <code>type</code> 属性 进⾏类型的区分 <code>&lt;constructor-arg type=&quot;&quot;&gt;</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customer"</span> <span class="attr">class</span>=<span class="string">"com.yusael.constructor.Customer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">value</span>&gt;</span>20<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<h3 id="注入总结"><a href="#注入总结" class="headerlink" title="注入总结"></a>注入总结</h3><p>未来的实战中，应⽤ <strong>set注入</strong> 还是 <strong>构造注入</strong>？</p>
<p>答：set 注入更多。</p>
<ol>
<li>构造注入麻烦（重载）</li>
<li>Spring 框架底层⼤量应⽤了 set注入。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200521235846480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV185411477k?p=63" target="_blank" rel="noopener">B站孙帅</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Data JPA的Repository操作数据库</title>
    <url>/2020/07/10/Spring-Data-JPA%E7%9A%84Repository%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h3><ul>
<li><p>注解：@EnableJpaRepositories，在SpringBoot项目的Main函数上添加该注解，SpringBoot就会自动的查找实现了Jpa的Repository&lt;T, ID&gt;接口并将其托管</p>
</li>
<li><p>Repository&lt;T, ID&gt;接口</p>
<ol>
<li>CrudRepository&lt;T, ID&gt;</li>
<li>PagingAndSortingRepository&lt;T, ID&gt;</li>
<li>JpaRepository&lt;T, ID&gt;</li>
</ol>
<p>在这里实现了这三个接口，只需要指定仓储的实体类型和ID类型，Jpa就会自动地帮我们实现对应实体类的操作数据库的方法。</p>
</li>
</ul>
<h3 id="定义查询"><a href="#定义查询" class="headerlink" title="定义查询"></a>定义查询</h3><ul>
<li>根据方法名定义查询<ol>
<li>find…By…/read…By…/query…By…/get…By…，用于查询</li>
<li>count…By…，用于计数</li>
<li>…OrderBy…[Asc/Desc]，用于排序</li>
<li>And/Or/IgnoreCase，多条件Sql</li>
<li>Top+数字/First/Distinct，Top/First查询</li>
</ol>
</li>
</ul>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ul>
<li>PagingAndSortingRepository&lt;T, ID&gt;：用于分页的Repository接口</li>
<li>Pageable/Sort：分页信息实体和排序信息实体</li>
<li>Slice<T>/Page<T></T></T></li>
</ul>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><ul>
<li><p>@Entity，标记被注解的类是实体类，可被ORM框架用于持续化，常与@Table一起使用，指定关联的数据库表。该注解仅包含name属性，用于指明实体的名字，不指定时默认是实体类的名字，实体名可用于查询语句中。</p>
</li>
<li><p>@Table，该属性与@Entity一起使用，用来描述实体对应的数据库表，其name属性指定实体对应的数据库名，name属性用的较多，catalog和schema属性指定数据表所在目录名或数据库名，跟具体使用数据库相关，uniqueConstraints属性用来对数据表列唯一性做限制，index属性用来描述索引字段，实际使用根据具体需求来配置。</p>
</li>
<li><p>@Id，被该属性标注的实体字段被标记为数据表的主键，与@Column, @GeneratedValue一起配合使用用来描述主键字段，如下实例,People类的id被映射成主键，对应字段名为pid，ORM框架依据具体使用的数据库使用对应的主键生成策略。</p>
</li>
<li><p>@Column，用来描述实体属性对应数据表字段，其中name、nullable、unique、length属性用的较多，分别用来描述字段名、字段是否可以null、字段是否唯一、字段的长度，实际开发中需要用其他属性时，可从参考文献获取api文档地址，查阅文档配置。</p>
</li>
<li><p>@GeneratedValue，用来描述主键生成策略，包含如下策略：GenerationType.TABLE：ORM框架通过数据库的一张特定的表格来生成主键,该策略一般与另外一个注解@TableGenerator一起使用,@TableGenerator对这张特定的表进行描述，该策略的好处就是不依赖于外部环境和数据库的具体实现,在不同数据库间可以很容易的进行移植,但由于其不能充分利用数据库的特性,一般不会优先使用。</p>
</li>
<li><p>@OneToOne，两实体一对一关系，例如雇员和工作证就是一对一关系，一个雇员只能有一个工作证，一个工作证只能属于一个雇员。</p>
<p>单向关联：查询包含关联属性的实体对象时，能同步从数据库中获取关联的实体对象，反过来不行。</p>
<p>双向关联：包含外键定义的实体是拥有关系实体，在关联的非拥有关联实体中，需要用注解的mappedBy属性指明拥有关系实体的关联属性名</p>
<p>顺带说明下@OneToOne注解中的fetch、cascade属性的意义，@OneToMany、@ManyToOne、@ManyToMany同样具有这两个属性，意义是相同的。fetch属性指明数据抓取策略，EAGER即立即抓取，LAZY延迟加载，指明关联实体对象获取策略。</p>
<p>cascade属性指明级联特性：</p>
<p>CascadeType.PERSIST：级联持久化操作，当将实体保存至数据库时，其对应的关联实体也会被保存至数据库；</p>
<p>CascadeType.REMOVE：级联删除操作，从数据库删除当前实体时，关联实体也会被删除；</p>
<p>CascadeType.DETACH：级联脱管，当前实体被ORM框架脱管，关联实体也被同步脱管，处于脱管状态的实体，修改操作不能持久化到数据库；</p>
<p>CascadeType.MERGE：级联合并操作，脱管实体状态被复制ORM框架管理的对应同一条数据库记录的实体中，关联的实体同样执行复制操作。</p>
</li>
<li><p>@OneToMany和@ManyToOne，两实体一对多关系，例如人和电话就是一对多关系，一个人可以有多个电话，一个电话只能属于一个人。</p>
<p>单向关联：例如电话实体类包含人实体类属性，在查询电话实体对象时，能获取到对应的人实体，相反是不行的，查询人实体对象时不能获取到其电话实体；</p>
<p>当实体间关系是双向的：每个实体类都有一个属性指向关联的实体对象，one端实体可以用@OneToMany注解many端实体属性，many端实体可以通@ManyToOne注解one端实体属性。</p>
</li>
<li><p>@ManyToMany，两实体多对多关系，例如学生和所选课程的关系，一个学生可选多个课程，一个课程可被多个学生选，单向关联类同@OneToOne、@OneToMany，查询拥有关系的实体时，才能获取关联实体对象，反之不行；双向关联，任何一方都可以成为关系拥有方法，非关系拥有方需要用mapped属性标明关系拥有方实体对应属性字段，ManyToMany关系数据库层是通过关联表的方式连接两实体对应的数据表，在用@ManyToMany时，可同步用@JoinTable注解指明关联表名及其字段。</p>
</li>
<li><p>@Temporal</p>
<p>用于将java.util.Date和java.util.Calendar的实体属性的持久化，其属性参数value包含如下三种取值：</p>
<p>TemporalType.DATE，持久化时按照java.sql.Date类型来持久化，即只保存年月日yyyy-MM-dd；</p>
<p>TemporalType.TIME，持久化时按照java.sql.Time类型来持久化，即只保存时分秒HH:MM:SS；</p>
<p>TemporalType.TIMESTAMP，持久化时按照java.sql.Timestamp类型来持久化，即保存年月日时分秒yyyy-MM-dd hh:MM:ss。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-SpringBoot -Jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>Shiro基础</title>
    <url>/2020/07/23/Shiro%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="什么是Shiro"><a href="#什么是Shiro" class="headerlink" title="什么是Shiro"></a>什么是Shiro</h3><p>Shiro是一个强大的简单易用的Java安全框架，主要用来更便捷的认证，授权，加密，会话管理。Shiro首要的和最重要的目标就是容易使用并且容易理解。<a href="https://shiro.apache.org/" target="_blank" rel="noopener">Shiro官网</a></p>
<p>Shiro是一个有许多特性的全面的安全框架，下面这幅图可以了解Shiro的特性：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/426671-4f553a3555dcf438.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp" alt="img"></p>
<p>可以看出shiro除了基本的认证，授权，会话管理，加密之外，还有许多额外的特性。</p>
<h3 id="Shiro架构"><a href="#Shiro架构" class="headerlink" title="Shiro架构"></a>Shiro架构</h3><p>Shiro有三个主要的概念：<code>Subject</code>，<code>SecurityManager</code>，<code>Realms</code>，下面这幅图可以看到这些原件之间的交互。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/426671-5458508e59ae958a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/410/format/webp" alt="img"></p>
<ul>
<li>Subject：翻译为主角，当前参与应用安全部分的主角。可以是用户，可以试第三方服务，可以是cron 任务，或者任何东西。主要指一个正在与当前软件交互的东西。<br>所有Subject都需要SecurityManager，当你与Subject进行交互，这些交互行为实际上被转换为与SecurityManager的交互</li>
<li>SecurityManager：安全管理员，Shiro架构的核心，它就像Shiro内部所有原件的保护伞。然而一旦配置了SecurityManager，SecurityManager就用到的比较少，开发者大部分时间都花在Subject上面。<br>请记得，当你与Subject进行交互的时候，实际上是SecurityManager在背后帮你举起Subject来做一些安全操作。</li>
<li>Realms：Realms作为Shiro和你的应用的连接桥，当需要与安全数据交互的时候，像用户账户，或者访问控制，Shiro就从一个或多个Realms中查找。<br>Shiro提供了一些可以直接使用的Realms，如果默认的Realms不能满足你的需求，你也可以定制自己的Realms</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/426671-d2c043d97b735c9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/525/format/webp" alt="img"></p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol>
<li>主体：即访问应用的用户，在Shiro中使用Subject代表用户，用户只有授权后才允许访问相应的资源。</li>
<li>资源：在应用中用户可以访问的任何东西。比如页面、图片、信息等等的一些数据。</li>
<li>权限：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力，即对资源的CRUD。</li>
<li>角色：代表了操作的集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限。</li>
</ol>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>创建一个maven项目，引入如下依赖：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        shiro的核心依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        slf4j的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>然后再创建一个子项目shiro_01_Authentication_ini，在资源文件夹下创建一个shiro.ini文件，使用ini文件来模拟数据库。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#users表示用户</span></span><br><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhangsan</span> = <span class="number">123456</span></span><br><span class="line"><span class="attr">lisi</span> = <span class="number">123456</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAuthenticationApp</span> </span>&#123;</span><br><span class="line">    <span class="comment">//日志输出工具</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger log = LoggerFactory.getLogger(TestAuthenticationApp<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"My First Shiro App"</span>);</span><br><span class="line">        String password = <span class="string">"123456"</span>;</span><br><span class="line">        String username = <span class="string">"zhangsan"</span>;</span><br><span class="line">        <span class="comment">//读取ini文件，创建一个安全管理器的工厂对象</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro.ini"</span>);</span><br><span class="line">        <span class="comment">//使用工厂创建安全管理器</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line">        <span class="comment">//把当前的安全管理器绑定到当前线程</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line">        <span class="comment">//获取主体对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        <span class="comment">//给主体对象设置用户名和密码</span></span><br><span class="line">        AuthenticationToken token = <span class="keyword">new</span> UsernamePasswordToken(username, password);</span><br><span class="line">        <span class="comment">//认证</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">            log.info(<span class="string">"认证通过"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AuthenticationException e)&#123;</span><br><span class="line">            log.info(<span class="string">"认证不通过"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中的<code>setSecurityManager</code>是把当前的安全管理器绑定到当前线程，这样每一个用户的认证操作就对应一个线程，就不会反复地创建线程；</p>
<p><code>AuthenticationException</code>是<code>UnknownAccountException</code>（用户不存在）和<code>IncorrectCredentialsException</code>（密码错误）的父类，所以也可以改成</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//用户进行登录</span></span><br><span class="line">    subject.login(token);</span><br><span class="line">    System.out.println(<span class="string">"认证成功"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (UnknownAccountException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"用户不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"密码不正确"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p>创建一个子项目shiro_02_Authorization_ini，修改ini文件如下：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="INI"><figure class="iseeu highlight /ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[users]</span></span><br><span class="line"><span class="attr">zhangsan</span> = <span class="number">123456</span>, role1</span><br><span class="line"><span class="attr">lisi</span> = <span class="number">123456</span>, role2</span><br><span class="line"><span class="attr">wangwu</span> = <span class="number">123456</span>, role3</span><br><span class="line"><span class="attr">zhaoliu</span> = <span class="number">123456</span>, role2, role3</span><br><span class="line"><span class="attr">sunqi</span> = <span class="number">123456</span>, role4</span><br><span class="line"><span class="comment">#角色，权限的集合</span></span><br><span class="line"><span class="section">[roles]</span></span><br><span class="line"><span class="attr">role1</span> = user:query, user:update, user:delete, user:add, user:export</span><br><span class="line"><span class="attr">role2</span> = user:query, user:add</span><br><span class="line"><span class="attr">role3</span> = user:query, user:export</span><br><span class="line"><span class="comment">#表示所有权限</span></span><br><span class="line"><span class="attr">role4</span> = *:*</span><br></pre></td></tr></table></figure></div>

<p>可以在上面认证代码后面添加如下代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//isAuthenticated：用户是否通过验证</span></span><br><span class="line">System.out.println(<span class="string">"是否认证："</span>+subject.isAuthenticated());</span><br><span class="line"><span class="keyword">if</span> (subject.isAuthenticated())&#123;</span><br><span class="line">    System.out.println(<span class="string">"==========权限判断=========="</span>);</span><br><span class="line">    <span class="keyword">boolean</span> permitted = subject.isPermitted(<span class="string">"user:query"</span>);</span><br><span class="line">    System.out.println(<span class="string">"是否有user:query的权限:"</span>+permitted);</span><br><span class="line">    <span class="keyword">boolean</span>[] permitted1 = subject.isPermitted(<span class="string">"user:query"</span>, <span class="string">"user:add"</span>, <span class="string">"user:export"</span>, <span class="string">"user:delete"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> b : permitted1) &#123;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"==========角色判断=========="</span>);</span><br><span class="line">    <span class="comment">//判断用户是否有某种角色</span></span><br><span class="line">    <span class="keyword">boolean</span> role2 = subject.hasRole(<span class="string">"role2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"是否有role2的角色："</span>+role2);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; roles = Arrays.asList(<span class="string">"role1"</span>, <span class="string">"role2"</span>, <span class="string">"role3"</span>, <span class="string">"role4"</span>);</span><br><span class="line">    <span class="comment">//判断用户是否有角色集合里的角色</span></span><br><span class="line">    <span class="keyword">boolean</span>[] hasRoles = subject.hasRoles(roles);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> hasRole : hasRoles) &#123;</span><br><span class="line">        System.out.println(hasRole);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户登出</span></span><br><span class="line">subject.logout();</span><br><span class="line">System.out.println(<span class="string">"是否认证："</span>+subject.isAuthenticated());</span><br></pre></td></tr></table></figure></div>

<h3 id="使用自定义的Realm"><a href="#使用自定义的Realm" class="headerlink" title="使用自定义的Realm"></a>使用自定义的Realm</h3><p>创建UserRealm，并用Service来模拟从数据库中取值。</p>
<p>realm</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    <span class="keyword">private</span> RoleService roleService = <span class="keyword">new</span> RoleServiceImpl();</span><br><span class="line">    <span class="keyword">private</span> PermissionService permissionService = <span class="keyword">new</span> PermissionServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证，当使用login时会调用此逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//token传入的用户名</span></span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="comment">//token传入的密码</span></span><br><span class="line">        Object credentials = token.getCredentials();</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(credentials);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * shiro是根据用户名把用户对象查询出来。在来做密码的匹配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        User user = userService.queryUserByName(username);</span><br><span class="line">        <span class="comment">//如果查询到用户，则进行认证逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            List&lt;String&gt; roles = roleService.queryRolesByName(username);</span><br><span class="line">            List&lt;String&gt; permissions = permissionService.queryPermissionsByName(username);</span><br><span class="line">            ActiveUser activeUser = <span class="keyword">new</span> ActiveUser(user, roles, permissions);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *进行密码匹配，并将认证后的结果返回</span></span><br><span class="line"><span class="comment">             * 参数说明：</span></span><br><span class="line"><span class="comment">             * 参数1：可以传入任意对象，一般为用户名或用户对象</span></span><br><span class="line"><span class="comment">             * 参数2：从数据库中查询出来的密码</span></span><br><span class="line"><span class="comment">             * 参数3：当前的类名</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(activeUser, user.getPwd(), <span class="keyword">this</span>.getName());</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当返回null，即代表用户不存在时，shiro会抛出UnknowAccountException异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权，即给用户添加权限或角色的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="comment">//添加权限</span></span><br><span class="line"><span class="comment">//        info.addStringPermission("user:query");</span></span><br><span class="line"><span class="comment">//        Collection&lt;String&gt; permissions = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Collections.addAll(permissions, "user:add", "user:export");</span></span><br><span class="line">        ActiveUser activeUser = (ActiveUser) principals.getPrimaryPrincipal();</span><br><span class="line">        List&lt;String&gt; permissions = activeUser.getPermissions();</span><br><span class="line">        <span class="keyword">if</span> (permissions.size()&gt;<span class="number">0</span>)</span><br><span class="line">            info.addStringPermissions(permissions);</span><br><span class="line">        <span class="comment">//添加角色</span></span><br><span class="line"><span class="comment">//        info.addRole("role1");</span></span><br><span class="line"><span class="comment">//        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Collections.addAll(list,  "role2", "role3");</span></span><br><span class="line">        List&lt;String&gt; roles = activeUser.getRoles();</span><br><span class="line">        <span class="keyword">if</span> (roles.size()&gt;<span class="number">0</span>)</span><br><span class="line">            info.addRoles(roles);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>修改主函数中的代码，在安全管理器中设置Realm，把自定义的UserRealm对象注入。</li>
<li>当主函数进行身份认证时，则会走<code>doGetAuthenticationInfo</code>里的逻辑，在创建<code>SimpleAuthenticationInfo</code>对象时，会进行密码匹配，然后返回匹配结果，如果返回null则会抛出<code>UnknownAccountException</code>异常，如果匹配不成功则会抛出<code>IncorrectCredentialsException</code>异常。</li>
<li>当认证通过后就会进行授权，则会走<code>doGetAuthorizationInfo</code>里的逻辑，在这里面则可以为用户添加角色、权限。</li>
<li><code>doGetAuthorizationInfo</code>传入的参数就是在认证逻辑里面<code>SimpleAuthenticationInfo</code>的第一个参数。</li>
</ol>
<p>entity</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//User</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ActiveUser</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>service</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UserServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUserByName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (username)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"zhangsan"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1</span>, username, <span class="string">"123456"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"lisi"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">2</span>, username, <span class="string">"123456"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"sunqi"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">3</span>, username, <span class="string">"123456"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//PermissionServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PermissionServiceImpl</span> <span class="keyword">implements</span> <span class="title">PermissionService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">queryPermissionsByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">"user:query"</span>, <span class="string">"user:add"</span>, <span class="string">"user:export"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RoleServiceImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">queryRolesByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">"role1"</span>, <span class="string">"role2"</span>, <span class="string">"role3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>出于安全着想，我们对用户的密码可以使用某种算法进行加密，加密后的密文存储在数据库中，用户通过输入明文，由后端进行散列加密后，与数据库中的密文进行匹配，如果匹配成功则认证成功。在Shiro中，有几种常见的加密算法：Md2、Md5、Sha1、Sha256等，它们都是可以加入散列值和增加散列次数使密文更难破解。创建一个子项目shiro_05_Authorization_md5：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String source = <span class="string">"123456"</span>;</span><br><span class="line">        Md5Hash hash = <span class="keyword">new</span> Md5Hash(source);</span><br><span class="line">        System.out.println(<span class="string">"使用Md5加密后的结果:"</span>+hash.toString());</span><br><span class="line"></span><br><span class="line">        Md5Hash hash1 = <span class="keyword">new</span> Md5Hash(source, <span class="string">"北京武汉"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Md5加密并散列后的结果："</span> + hash1.toString());</span><br><span class="line"></span><br><span class="line">        Md5Hash hash2 = <span class="keyword">new</span> Md5Hash(source, <span class="string">"我最帅"</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"Md5加密并散列2次后的结果:"</span>+hash2.toString());</span><br><span class="line">        <span class="comment">//登录后的明文进行加密，然后和数据库加密的密文进行匹配，如果匹配成功则认证成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *用Md5算法进行加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 明文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> salt 散列值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashIterations 散列次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">md5</span><span class="params">(String source, Object salt, Integer hashIterations)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Md5Hash(source, salt, hashIterations).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *用Sha1算法进行加密</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 明文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> salt 散列值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hashIterations 散列次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sha1</span><span class="params">(String source, Object salt, Integer hashIterations)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sha1Hash(source, salt, hashIterations).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在认证和授权中集成加密</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    <span class="keyword">private</span> RoleService roleService = <span class="keyword">new</span> RoleServiceImpl();</span><br><span class="line">    <span class="keyword">private</span> PermissionService permissionService = <span class="keyword">new</span> PermissionServiceImpl();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置加密规则</span></span><br><span class="line">        HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">        <span class="comment">//指定加密算法</span></span><br><span class="line">        credentialsMatcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">        <span class="comment">//指定散列次数</span></span><br><span class="line">        credentialsMatcher.setHashIterations(<span class="number">2</span>);</span><br><span class="line">        setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证，当使用login时会调用此逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AuthenticationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//token传入的用户名</span></span><br><span class="line">        String username = token.getPrincipal().toString();</span><br><span class="line">        <span class="comment">//token传入的密码</span></span><br><span class="line">        Object credentials = token.getCredentials();</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(credentials);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * shiro是根据用户名把用户对象查询出来。在来做密码的匹配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        User user = userService.queryUserByName(username);</span><br><span class="line">        <span class="comment">//如果查询到用户，则进行认证逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            List&lt;String&gt; roles = roleService.queryRolesByName(username);</span><br><span class="line">            List&lt;String&gt; permissions = permissionService.queryPermissionsByName(username);</span><br><span class="line">            ActiveUser activeUser = <span class="keyword">new</span> ActiveUser(user, roles, permissions);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *进行密码匹配，并将认证后的结果返回</span></span><br><span class="line"><span class="comment">             * 参数说明：</span></span><br><span class="line"><span class="comment">             * 参数1：可以传入任意对象，一般为用户名或用户对象</span></span><br><span class="line"><span class="comment">             * 参数2：从数据库中查询出来的密码</span></span><br><span class="line"><span class="comment">             * 参数3：当前的类名</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line"><span class="comment">//            SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(activeUser, user.getPwd(), this.getName());</span></span><br><span class="line">            ByteSource credentialsSalt = ByteSource.Util.bytes(<span class="string">"我最帅"</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *进行密码匹配，并将认证后的结果返回</span></span><br><span class="line"><span class="comment">             * 参数说明：</span></span><br><span class="line"><span class="comment">             * 参数1：可以传入任意对象，一般为用户名或用户对象</span></span><br><span class="line"><span class="comment">             * 参数2：从数据库中查询出来的密码</span></span><br><span class="line"><span class="comment">             * 参数3：散列值</span></span><br><span class="line"><span class="comment">             * 参数4：当前的类名</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            SimpleAuthenticationInfo info = <span class="keyword">new</span> SimpleAuthenticationInfo(activeUser, user.getPwd(), credentialsSalt, <span class="keyword">this</span>.getName());</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当返回null，即代表用户不存在时，shiro会抛出UnknowAccountException异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权，即给用户添加权限或角色的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> principals</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">        <span class="comment">//添加权限</span></span><br><span class="line"><span class="comment">//        info.addStringPermission("user:query");</span></span><br><span class="line"><span class="comment">//        Collection&lt;String&gt; permissions = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Collections.addAll(permissions, "user:add", "user:export");</span></span><br><span class="line">        ActiveUser activeUser = (ActiveUser) principals.getPrimaryPrincipal();</span><br><span class="line">        List&lt;String&gt; permissions = activeUser.getPermissions();</span><br><span class="line">        <span class="keyword">if</span> (permissions.size()&gt;<span class="number">0</span>)</span><br><span class="line">            info.addStringPermissions(permissions);</span><br><span class="line">        <span class="comment">//添加角色</span></span><br><span class="line"><span class="comment">//        info.addRole("role1");</span></span><br><span class="line"><span class="comment">//        Collection&lt;String&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        Collections.addAll(list,  "role2", "role3");</span></span><br><span class="line">        List&lt;String&gt; roles = activeUser.getRoles();</span><br><span class="line">        <span class="keyword">if</span> (roles.size()&gt;<span class="number">0</span>)</span><br><span class="line">            info.addRoles(roles);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在UserRealm的构造器中设置了加密算法和散列次数，而散列值是在<code>SimpleAuthenticationInfo</code>中的credentialsSalt添加的，一般散列值都会存在数据库中，而加密的规则会在后端代码中设置，这里有三种设置方式：1、如上在构造器中</p>
<ol start="2">
<li>在主函数中设置加密规则</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">UserRealm userRealm = <span class="keyword">new</span> UserRealm();</span><br><span class="line">HashedCredentialsMatcher credentialsMatcher = <span class="keyword">new</span> HashedCredentialsMatcher();</span><br><span class="line">credentialsMatcher.setHashAlgorithmName(<span class="string">"md5"</span>);</span><br><span class="line">credentialsMatcher.setHashIterations(<span class="number">2</span>);</span><br><span class="line">userRealm.setCredentialsMatcher(credentialsMatcher);</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>在ini文件中设置规则，即把加密规则保存在数据库中。</li>
</ol>
<hr>
<p>参考网址：<a href="https://www.jianshu.com/p/5a35d0100a71" target="_blank" rel="noopener">简书</a></p>
]]></content>
      <categories>
        <category>-Shiro</category>
      </categories>
      <tags>
        <tag>-Shiro -Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记3——反转控制与依赖注入、Spring工厂创建复杂对象3种方式</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E6%8E%A7%E5%88%B6%E4%B8%8E%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%81Spring%E5%B7%A5%E5%8E%82%E5%88%9B%E5%BB%BA%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A13%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Spring5-x学习笔记3——反转控制与依赖注入、Spring工厂创建复杂对象3种方式"><a href="#Spring5-x学习笔记3——反转控制与依赖注入、Spring工厂创建复杂对象3种方式" class="headerlink" title="Spring5.x学习笔记3——反转控制与依赖注入、Spring工厂创建复杂对象3种方式"></a>Spring5.x学习笔记3——反转控制与依赖注入、Spring工厂创建复杂对象3种方式</h2><h3 id="反转控制-与-依赖注入"><a href="#反转控制-与-依赖注入" class="headerlink" title="反转控制 与 依赖注入"></a>反转控制 与 依赖注入</h3><h4 id="反转控制（IOC-Inverse-of-Control）"><a href="#反转控制（IOC-Inverse-of-Control）" class="headerlink" title="反转控制（IOC Inverse of Control）"></a>反转控制（IOC Inverse of Control）</h4><p><strong>反转控制</strong>（IOC Inverse of Control)，也称为 <strong>转移控制</strong>。</p>
<ul>
<li>控制：对于成员变量赋值的控制权；</li>
<li>反转控制：把对于成员变量赋值的控制权，从代码中转移（反转）到 Spring ⼯⼚和配置⽂件中完成。</li>
<li>好处：解耦合；</li>
<li>底层实现：工厂设计模式；<br><img src="https://img-blog.csdnimg.cn/20200522225729692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h4 id="依赖注入-Dependency-Injection-DI"><a href="#依赖注入-Dependency-Injection-DI" class="headerlink" title="依赖注入 (Dependency Injection - DI)"></a>依赖注入 (Dependency Injection - DI)</h4><ul>
<li>注入：通过 Spring 的工厂及配置⽂件，为对象（bean，组件）的成员变量赋值；</li>
<li>依赖注⼊：当⼀个类需要另⼀个类时，就意味着依赖，⼀旦出现依赖，就可以把另⼀个类作为本类的成员变量，最终通过 Spring 配置⽂件进⾏注⼊（赋值）。</li>
<li>好处：解耦合；<br><img src="https://img-blog.csdnimg.cn/20200522230211347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h3 id="Spring工厂创建复杂对象（3种方式）"><a href="#Spring工厂创建复杂对象（3种方式）" class="headerlink" title="Spring工厂创建复杂对象（3种方式）"></a>Spring工厂创建复杂对象（3种方式）</h3><h4 id="什么是复杂对象"><a href="#什么是复杂对象" class="headerlink" title="什么是复杂对象"></a>什么是复杂对象</h4><p><img src="https://img-blog.csdnimg.cn/20200522231012678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>简单对象</strong>：可以直接通过 new 构造方法创建的对象；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">UserService</span><br><span class="line">UserDAO</span><br><span class="line">Customer</span><br><span class="line">Person</span><br><span class="line">......</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure></div>

<p><strong>复杂对象</strong>：不能直接通过 new 构造方法创建的对象。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Connection</span><br><span class="line">SqlSessionFactory</span><br><span class="line">......</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<h4 id="FactoryBean-接口"><a href="#FactoryBean-接口" class="headerlink" title="FactoryBean 接口"></a>FactoryBean 接口</h4><ul>
<li><p>实现 <code>FactoryBean</code> 接口</p>
<p>：实现三个方法：</p>
<ul>
<li><code>getObject()</code>：用于书写创建复杂对象时的代码。</li>
<li><code>getObjectType()</code>：返回创建的复杂对象的类型。</li>
<li><code>isSingleton</code>：用于决定是否单例。</li>
</ul>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Connection</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 用于书写创建复杂对象时的代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/spring"</span>, <span class="string">"root"</span>, <span class="string">"1234"</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回创建的复杂对象的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;Connection&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Connection<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否单例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 每一次都创建新的复杂对象</span></span><br><span class="line">        <span class="comment">// return true; // 只创建一次这种类型的复杂对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>Spring 配置文件的配置</strong>：如果 class 中指定的类型是 <code>FactoryBean</code> 接⼝的实现类，那么通过 id 值获得的是这个类所创建的复杂对象。<br>比如下面 class 指定的是 <code>ConnectionFactoryBean</code>，获得的是 <code>Connection</code> 对象。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--class 指定了 ConnectionFactoryBean, 获得的是该类创建的复杂对象 Connection --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conn"</span> <span class="attr">class</span>=<span class="string">"com.yusael.factorybean.ConnectionFactoryBean"</span>/&gt;</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure></div>

<h4 id="FactoryBean-细节"><a href="#FactoryBean-细节" class="headerlink" title="FactoryBean 细节"></a>FactoryBean 细节</h4><p>如果就想获得 <code>FactoryBean</code> 类型的对象，加个 <code>&amp;</code>，<code>ctx.getBean(&quot;&amp;conn&quot;)</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">ConnectionFactoryBean cfb = (ConnectionFactoryBean) ctx.getBean(<span class="string">"&amp;conn"</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p><code>isSingleton</code> 方法返回 true 只会创建⼀个复杂对象，返回 false 每⼀次都会创建新的对象；<br>需要根据这个对象的特点 ，决定是返回 true（<code>SqlSessionFactory</code>） 还是 false（<code>Connection</code>）；</p>
<hr>
<p>mysql ⾼版本连接创建时，需要制定 SSL 证书，否则会警告；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">Sat May 23 23:18:04 CST 2020 WARN: Establishing SSL connection without server<span class="string">'s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn'</span>t <span class="built_in">set</span>. For compliance with existing applications not using SSL the verifyServerCertificate property is <span class="built_in">set</span> to <span class="string">'false'</span>. You need either to explicitly <span class="built_in">disable</span> SSL by setting useSSL=<span class="literal">false</span>, or <span class="built_in">set</span> useSSL=<span class="literal">true</span> and provide truststore <span class="keyword">for</span> server certificate verification.</span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<p>解决方案：url = <code>jdbc:mysql://localhost:3306/spring?useSSL=false</code></p>
<hr>
<p>依赖注入（DI）：把 <code>ConnectionFactoryBean</code> 中依赖的 4 个字符串信息 ，通过配置⽂件进行注⼊。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span><span class="meta">@Setter</span> <span class="comment">// 提供 get set 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Connection</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">// 将依赖的字符串信息变为成员变量, 利用配置文件进行注入。</span></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(driverClassName);</span><br><span class="line">        Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;Connection&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Connection<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br><span class="line">&lt;!--体会依赖注入, 好处: 解耦合, 今后要修改连接数据库的信息只需要修改配置文件, 无需改动代码--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"conn"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.factorybean.ConnectionFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"driverClassName"</span> value=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:mysql://localhost:3306/spring?useSSL=false"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"username"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"password"</span> value=<span class="string">"1234"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></div>

<h3 id="FactoryBean-实现原理-简易版"><a href="#FactoryBean-实现原理-简易版" class="headerlink" title="FactoryBean 实现原理[简易版]"></a>FactoryBean 实现原理[简易版]</h3><p>原理：<strong>接口回调</strong>。</p>
<p>问题：</p>
<ol>
<li>为什么 Spring 规定 <code>FactoryBean</code> 接⼝实现 <code>getObject()</code>？</li>
<li>为什么 <code>ctx.getBean(&quot;conn&quot;)</code> 获得的是复杂对象 <code>Connection</code> ⽽非 <code>ConnectionFactoryBean</code>？</li>
</ol>
<p>Spring 内部运行流程：</p>
<ol>
<li>配置文件中通过 id <code>conn</code> 获得 <code>ConnectionFactoryBean</code> 类的对象 ，进而通过 <code>instanceof</code> 判断出是 <code>FactoryBean</code> 接⼝的实现类；</li>
<li>Spring 按照规定 <code>getObject()</code> —&gt; <code>Connection</code>；</li>
<li>返回 <code>Connection</code>；</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200523002252481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>FactoryBean 总结</strong>：Spring 中用于创建复杂对象的，也是 Spring 提供的，后续 Spring 整合其他框架时会大量应用FactoryBean 方式。</p>
<h3 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h3><ol>
<li>避免 Spring 框架的侵入；</li>
<li>整合遗留系统；</li>
</ol>
<p>[开发步骤]：</p>
<ul>
<li>ConnectionFactory 类</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/spring?useSSL=false"</span>, <span class="string">"root"</span>, <span class="string">"1234"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>配置文件：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--实例工厂--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 先创建出工厂实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connFactory"</span> <span class="attr">class</span>=<span class="string">"com.yusael.factorybean.ConnectionFactory"</span>/&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 通过工厂实例里的方法创建复杂对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conn"</span> <span class="attr">factory-bean</span>=<span class="string">"connFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getConnection"</span>/&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<h3 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h3><p>[开发步骤]：</p>
<ul>
<li>StaticConnectionFactory 类</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFactoryBean</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/spring?useSSL=false"</span>, <span class="string">"root"</span>, <span class="string">"1234"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>配置文件：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--静态工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conn"</span> <span class="attr">class</span>=<span class="string">"com.yusael.factorybean.StaticFactoryBean"</span> <span class="attr">factory-method</span>=<span class="string">"getConnection"</span>/&gt;</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure></div>

<h3 id="Spring工厂创建对象的总结"><a href="#Spring工厂创建对象的总结" class="headerlink" title="Spring工厂创建对象的总结"></a>Spring工厂创建对象的总结</h3><p><img src="https://img-blog.csdnimg.cn/20200523232339418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200523232417498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="控制-Spring-工厂创建对象的次数"><a href="#控制-Spring-工厂创建对象的次数" class="headerlink" title="控制 Spring 工厂创建对象的次数"></a>控制 Spring 工厂创建对象的次数</h3><h4 id="控制简单对象的创建次数"><a href="#控制简单对象的创建次数" class="headerlink" title="控制简单对象的创建次数"></a>控制简单对象的创建次数</h4><p>配置文件中进行配置：<br><code>sigleton</code>：只会创建一次简单对象，默认值；<br><code>prototype</code>：每一次都会创建新的对象；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--控制简单对象创建次数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"scope"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">class</span>=<span class="string">"com.yusael.scope.Scope"</span>/&gt;</span></span><br><span class="line">12</span><br></pre></td></tr></table></figure></div>

<h4 id="控制复杂对象的创建次数"><a href="#控制复杂对象的创建次数" class="headerlink" title="控制复杂对象的创建次数"></a>控制复杂对象的创建次数</h4><p>如果是 <code>FactoryBean</code> 方式创建的复杂对象：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xxxFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 只会创建⼀次</span></span><br><span class="line">		<span class="comment">// return false; // 每⼀次都会创建新的</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略其余实现方法......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></div>

<p>如果是实例工厂或者静态工厂，没有 <code>isSingleton</code> 方法，与简单对象一样通过 <code>scope</code> 控制。</p>
<h4 id="为什么要控制对象的创建次数？"><a href="#为什么要控制对象的创建次数？" class="headerlink" title="为什么要控制对象的创建次数？"></a>为什么要控制对象的创建次数？</h4><p>好处：节省不必要的内存浪费。</p>
<p>什么样的对象只创建一次？</p>
<ul>
<li>重量级的、可以被共用的、线程安全的…</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory</span><br><span class="line">DAO</span><br><span class="line">Service</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure></div>

<p>什么样的对象每次都要创建新的？</p>
<ul>
<li>不能被共用的，线程不安全的…</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">Connection</span><br><span class="line">SqlSession | Session</span><br><span class="line">Struts2 - Action</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记1——工厂</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<h2 id="Spring5-x学习笔记1——工厂"><a href="#Spring5-x学习笔记1——工厂" class="headerlink" title="Spring5.x学习笔记1——工厂"></a>Spring5.x学习笔记1——工厂</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><h4 id="EJB（Enterprise-Java-Bean）存在的问题"><a href="#EJB（Enterprise-Java-Bean）存在的问题" class="headerlink" title="EJB（Enterprise Java Bean）存在的问题"></a>EJB（Enterprise Java Bean）存在的问题</h4><ol>
<li>运行环境苛刻</li>
<li>代码移植性差</li>
</ol>
<p>总结：EJB 是重量级的框架。</p>
<h4 id="什么是-Spring"><a href="#什么是-Spring" class="headerlink" title="什么是 Spring"></a>什么是 Spring</h4><p>Spring是⼀个<strong>轻量级</strong>的 JavaEE 解决⽅案，整合众多优秀的设计模式。</p>
<p><strong>什么是轻量级?</strong></p>
<ol>
<li>对于运⾏环境是没有额外要求的；<br>开源：tomcat、resion、jetty<br>收费：weblogic、websphere</li>
<li>代码移植性⾼：不需要实现额外接⼝。</li>
</ol>
<p><strong>JavaEE 的解决方案</strong>：<br><img src="https://img-blog.csdnimg.cn/20200520004505899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>整合设计模式：</p>
<ol>
<li>工厂</li>
<li>代理</li>
<li>模板</li>
<li>策略</li>
</ol>
<h4 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h4><p><strong>设计模式</strong></p>
<ul>
<li>广义概念：面向对象设计中，解决特定问题的经典代码。</li>
<li>狭义概念：23种设计模式：工厂、适配器、装饰器、迭代器、代理、模板…</li>
</ul>
<p><strong>什么是工厂设计模式？</strong></p>
<ol>
<li>概念：通过工厂类，创建对象；</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">UserDAO userDAO = <span class="keyword">new</span> UserDAOImpl();</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>好处：<strong>解耦合</strong>。</li>
</ol>
<ul>
<li>耦合：指定是代码间的强关联关系，一个类的改变会影响到另另一个类；<br>问题：不利于代码维护；<br>简单：把接⼝的实现类，硬编码在程序中；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br></pre></td></tr></table></figure></div>

<p><strong>简单的工厂设计</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baizhiedu.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第一步 获得IO输入流</span></span><br><span class="line">            InputStream inputStream = BeanFactory.class.getResourceAsStream("/applicationContext.properties");</span><br><span class="line">            <span class="comment">//第二步 文件内容 封装 Properties集合中 key = userService value = com.baizhixx.UserServiceImpl</span></span><br><span class="line">            env.load(inputStream);</span><br><span class="line"></span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	   对象的创建方式：</span></span><br><span class="line"><span class="comment">	       1. 直接调用构造方法 创建对象  UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="comment">	       2. 通过反射的形式 创建对象 解耦合</span></span><br><span class="line"><span class="comment">	       Class clazz = Class.forName("com.baizhiedu.basic.UserServiceImpl");</span></span><br><span class="line"><span class="comment">	       UserService userService = (UserService)clazz.newInstance();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">getUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//com.baizhiedu.basic.UserServiceImpl</span></span><br><span class="line">            Class clazz = Class.forName(env.getProperty(<span class="string">"userService"</span>));</span><br><span class="line">            userService = (UserService) clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserDAO <span class="title">getUserDAO</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDAO userDAO = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(env.getProperty(<span class="string">"userDAO"</span>));</span><br><span class="line">            userDAO = (UserDAO) clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userDAO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>配置文件applicationContext.properties：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Properties 集合 存储 Properties文件的内容</span></span><br><span class="line"><span class="comment"># 特殊Map key=String value=String</span></span><br><span class="line"><span class="comment"># Properties [userService = com.baizhiedu.xxx.UserServiceImpl]</span></span><br><span class="line"><span class="comment"># Properties.getProperty("userService")</span></span><br><span class="line"></span><br><span class="line"><span class="attr">userService</span> = <span class="string">com.baizhiedu.basic.UserServiceImpl</span></span><br><span class="line"><span class="attr">userDAO</span> = <span class="string">com.baizhiedu.basic.UserDAOImpl</span></span><br></pre></td></tr></table></figure></div>

<p><strong>通用的工厂设计</strong></p>
<p>问题：简单工厂会存在大量的代码冗余。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baizhiedu.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Properties env = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//第一步 获得IO输入流</span></span><br><span class="line">            InputStream inputStream = BeanFactory.class.getResourceAsStream("/applicationContext.properties");</span><br><span class="line">            <span class="comment">//第二步 文件内容 封装 Properties集合中 key = userService value = com.baizhixx.UserServiceImpl</span></span><br><span class="line">            env.load(inputStream);</span><br><span class="line"></span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      key 小配置文件中的key [userDAO,userService]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">         Object ret = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Class clazz = Class.forName(env.getProperty(key));</span><br><span class="line">             ret = clazz.newInstance();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> ret;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用方式：</p>
<ol>
<li>定义类型 (类)</li>
<li>通过配置文件的配置告知工厂<br><code>applicationContext.properties</code> 中 <code>key = value</code>；</li>
<li>通过工厂获得类的对象<br><code>Object ret = BeanFactory.getBean(&quot;key&quot;);</code></li>
</ol>
<h3 id="第一个Spring程序"><a href="#第一个Spring程序" class="headerlink" title="第一个Spring程序"></a>第一个Spring程序</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>依赖查询网站：<a href="https://mvnrepository.com/；" target="_blank" rel="noopener">https://mvnrepository.com/；</a></p>
<p><strong>配置 Spring 的 jar 包：</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>Spring的配置文件</strong></p>
<ol>
<li>配置文件的放置位置：任意位置，没有硬性要求；</li>
<li>配置文件的命名 ：没有硬性要求，建议：<strong>applicationContext.xml</strong>；</li>
</ol>
<h4 id="Spring核心API"><a href="#Spring核心API" class="headerlink" title="Spring核心API"></a>Spring核心API</h4><p><strong>ApplicationContext</strong></p>
<ul>
<li>作用：Spring 提供的 <code>ApplicationContext</code> 这个工厂，用于对象的创建；<br>好处：解耦合</li>
<li><code>ApplicationContext</code> 是接⼝类型；<br>接⼝：屏蔽实现的差异<br>非web环境 (main junit) ：<code>ClassPathXmlApplicationContext</code><br>web环境 ：<code>XmlWebApplicationContext</code><br><img src="https://img-blog.csdnimg.cn/2020052001130596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>重量级资源：<br><code>ApplicationContext</code> 工厂的对象占JVM大量内存。<br>不会频繁的创建对象 ，一个应用只会创建一个工厂对象。<br><code>ApplicationContext</code> 是一个重量级的共享资源，即是线程安全的(多线程并发访问)。</li>
</ul>
<h4 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h4><ol>
<li>创建类型：Person.java</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>配置文件的配置</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.yusael.basic.Person"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>通过工厂类，获得对象</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于测试Spring的第一个程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、获取spring的工厂</span></span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"/applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">// 2、通过工厂类获得对象</span></span><br><span class="line">    Person person = (Person)ctx.getBean(<span class="string">"person"</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h4><p>名词解释：Spring ⼯⼚创建的对象，叫做 bean 或者 组件(componet)；</p>
<p><strong>Spring 工厂的相关的方法</strong></p>
<ol>
<li><code>getBean</code>：传入 id值 和 类名 获取对象，不需要强制类型转换。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过这种⽅式获得对象，就不需要强制类型转换</span></span><br><span class="line">Person person = ctx.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(<span class="string">"person = "</span> + person);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><code>getBean</code>：只指定类名，Spring 的配置文件中只能有一个 bean 是这个类型。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用这种方式的话, 当前Spring的配置文件中 只能有一个bean class是Person类型</span></span><br><span class="line">Person person = ctx.getBean(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(<span class="string">"person = "</span> + person);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><code>getBeanDefinitionNames</code>：获取 Spring 配置文件中所有的 bean 标签的 id 值。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取的是Spring工厂配置文件中所有bean标签的id值  person person1</span></span><br><span class="line">String[] beanDefinitionNames = ctx.getBeanDefinitionNames();</span><br><span class="line"><span class="keyword">for</span> (String beanDefinitionName : beanDefinitionNames) &#123;</span><br><span class="line">	System.out.println(<span class="string">"beanDefinitionName = "</span> + beanDefinitionName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><code>getBeanNamesForType</code>：根据类型获得 Spring 配置文件中对应的 id 值。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据类型获得Spring配置文件中对应的id值</span></span><br><span class="line">String[] beanNamesForType = ctx.getBeanNamesForType(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String id : beanNamesForType) &#123;</span><br><span class="line">	System.out.println(<span class="string">"id = "</span> + id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure></div>

<ol start="5">
<li><code>containsBeanDefinition</code>：用于判断是否存在指定 id 值的 bean，<strong>不能判断 name 值</strong>。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于判断是否存在指定id值的bean,不能判断name值</span></span><br><span class="line"><span class="keyword">if</span> (ctx.containsBeanDefinition(<span class="string">"person"</span>)) &#123;</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></div>

<ol start="6">
<li><code>containsBean</code>：用于判断是否存在指定 id 值的 bean，<strong>也可以判断 name 值</strong>。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于判断是否存在指定id值的bean,也可以判断name值</span></span><br><span class="line"><span class="keyword">if</span> (ctx.containsBean(<span class="string">"p"</span>)) &#123;</span><br><span class="line">	System.out.println(<span class="keyword">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	System.out.println(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></div>

<h3 id="配置文件中的细节"><a href="#配置文件中的细节" class="headerlink" title="配置文件中的细节"></a>配置文件中的细节</h3><p>如果 bean 只配置 class 属性：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.yusael.basic.Person"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<ul>
<li>会自动生成一个 id，<code>com.yusael.basic.Person#1</code><br>可以使用 <code>getBeanNamesForType</code> 验证。</li>
<li>应⽤场景：<br>如果这个 bean <strong>只需要使⽤⼀次</strong>，那么就可以省略 id 值；<br>如果这个 bean 会使⽤多次，或者被其他 bean 引⽤则需要设置 id 值；</li>
</ul>
<p>name 属性：</p>
<ul>
<li>作⽤：⽤于在 Spring 的配置⽂件中，为 bean 对象定义别名（小名）</li>
<li>name 与 id 的相同点：<ul>
<li><code>ctx.getBean(&quot;id&quot;)</code> 或 <code>ctx.getBean(&quot;name&quot;)</code> 都可以创建对象；、</li>
<li><code>&lt;bean id=&quot;person&quot; class=&quot;Person&quot;/&gt;</code> 与 <code>&lt;bean name=&quot;person&quot; class=&quot;Person&quot;/&gt;</code> 等效；</li>
</ul>
</li>
<li>name 与 id 的区别：<ul>
<li>别名可以定义多个,但是 id 属性只能有⼀个值；</li>
<li>XML 的 id 属性的值，命名要求：必须以字⺟开头，可以包含 字⺟、数字、下划线、连字符；不能以特殊字符开头 <code>/person</code>；<br>XML 的 name 属性的值，命名没有要求，<code>/person</code> 可以。<br>但其实 XML 发展到了今天：ID属性的限制已经不存在，<code>/person</code>也可以。</li>
</ul>
</li>
</ul>
<h3 id="Spring工厂的底层实现原理-简易版"><a href="#Spring工厂的底层实现原理-简易版" class="headerlink" title="Spring工厂的底层实现原理(简易版)"></a>Spring工厂的底层实现原理(简易版)</h3><p><img src="https://img-blog.csdnimg.cn/20200521002624493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>问题：未来在开发过程中，是不是所有的对象，都会交给 Spring ⼯⼚来创建呢？</p>
<p>回答：理论上是的，但是有特例 ：<strong>实体对象(entity)</strong> 是不会交给Spring创建，它由持久层框架进⾏创建。</p>
<h2 id="Spring5-x与日志框架的整合"><a href="#Spring5-x与日志框架的整合" class="headerlink" title="Spring5.x与日志框架的整合"></a>Spring5.x与日志框架的整合</h2><p>Spring 与日志框架进行整合，日志框架就可以在控制台中，输出Spring框架运行过程中的某些重要的信息。<br>好处：便于了解Spring框架的运⾏过程，利于程序的调试。</p>
<blockquote>
<p>默认日志框架<br>Spring 1.x、2.x、3.x 早期都是基于commonslogging.jar<br>Spring 5.x 默认整合的⽇志框架 logback、log4j2</p>
</blockquote>
<p>Spring 如何整合日志框架？<br>Spring5.x 整合 log4j：</p>
<ol>
<li>引进 <code>log4j.jar</code> 包；</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>引进<code>log4.properties</code> 配置文件；</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># resources文件夹根目录下</span></span><br><span class="line"><span class="comment">### 配置根</span></span><br><span class="line"><span class="string">log4j.rootLogger</span> <span class="string">=</span> <span class="string">debug,console</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 日志输出到控制台显示</span></span><br><span class="line"><span class="string">log4j.appender.console=org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="string">log4j.appender.console.Target=System.out</span></span><br><span class="line"><span class="string">log4j.appender.console.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="string">log4j.appender.console.layout.ConversionPattern=%d&#123;yyyy-MM-dd</span> <span class="string">HH:mm:ss&#125;</span> <span class="string">%-5p</span> <span class="string">%c&#123;1&#125;:%L</span> <span class="bullet">-</span> <span class="string">%m%n</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV185411477k?p=63" target="_blank" rel="noopener">B站孙帅</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记5——AOP 底层实现原理</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94AOP-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h3><p>POP (Producer Oriented Programing）</p>
<ul>
<li><strong>面向过程（方法、函数）编程</strong> —— C</li>
<li>以<strong>过程</strong>为基本单位的程序开发，通过过程间的彼此协同，相互调用，完成程序的构建。</li>
</ul>
<p>OOP (Object Oritened Programing)</p>
<ul>
<li><strong>面向对象编程</strong> —— Java</li>
<li>以<strong>对象</strong>为基本单位的程序开发，通过对象间的彼此协同，相互调用，完成程序的构建。</li>
</ul>
<p>AOP (Aspect Oriented Programing)</p>
<ul>
<li><strong>面向切面编程</strong> = Spring动态代理开发</li>
<li>以<strong>切面</strong>为基本单位的程序开发，通过切面间的彼此协同，相互调用，完成程序的构建。</li>
<li>切面 = 切入点 + 额外功能</li>
</ul>
<hr>
<p><strong>AOP 的概念：</strong></p>
<ul>
<li>本质就是 Spring 的动态代理开发，通过代理类为原始类增加额外功能。</li>
<li>好处：利于原始类的维护</li>
<li>注意：AOP 编程不可能取代 OOP，AOP 是 OOP 编程的补充。</li>
</ul>
<h3 id="AOP-编程的开发步骤"><a href="#AOP-编程的开发步骤" class="headerlink" title="AOP 编程的开发步骤"></a>AOP 编程的开发步骤</h3><ol>
<li>原始对象</li>
<li>额外功能 (<code>MethodInterceptor</code>)</li>
<li>切入点</li>
<li>组装切面 (额外功能+切入点)</li>
</ol>
<h3 id="切面的名词解释"><a href="#切面的名词解释" class="headerlink" title="切面的名词解释"></a>切面的名词解释</h3><p>切面 = 切入点 + 额外功能<br>几何学：面 = 点 + 相同的性质<br><img src="https://img-blog.csdnimg.cn/20200530224940730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="AOP-的底层实现原理"><a href="#AOP-的底层实现原理" class="headerlink" title="AOP 的底层实现原理"></a>AOP 的底层实现原理</h3><p>核心问题：</p>
<ol>
<li>AOP 如何创建动态代理类？<br><strong>动态字节码技术</strong></li>
<li>Spring 工厂如何加工创建代理对象？<br><strong>通过原始对象的 id 值，获得的是代理对象</strong></li>
</ol>
<h3 id="动态代理类的创建"><a href="#动态代理类的创建" class="headerlink" title="动态代理类的创建"></a>动态代理类的创建</h3><h4 id="JDK-的动态代理（原理-编码）"><a href="#JDK-的动态代理（原理-编码）" class="headerlink" title="JDK 的动态代理（原理 + 编码）"></a>JDK 的动态代理（原理 + 编码）</h4><ul>
<li><code>Proxy.newPorxyInstance</code> 方法参数详解<br><img src="https://img-blog.csdnimg.cn/20200530231452777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/202005302319274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>编码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class="line"><span class="comment">     2. JDK8.x 前必须加 final</span></span><br><span class="line"><span class="comment">     final UserService userService = new UserServiceImpl();</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建原始对象</span></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. JDK 动态代理</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"---- proxy log ----"</span>);</span><br><span class="line">                <span class="comment">// 原始方法运行</span></span><br><span class="line">                Object ret = method.invoke(userService, args);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.</span><br><span class="line">                newProxyInstance(TestJDKProxy<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line"><span class="class">                                <span class="title">userService</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(),</span></span><br><span class="line"><span class="class">                                <span class="title">handler</span>)</span>;</span><br><span class="line">        userServiceProxy.login(<span class="string">"zhenyu"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        userServiceProxy.register(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure></div>

<h4 id="CGlib-的动态代理"><a href="#CGlib-的动态代理" class="headerlink" title="CGlib 的动态代理"></a>CGlib 的动态代理</h4><p>CGlib 创建动态代理的原理：通过<strong>父子继承关系</strong>创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）。<br><img src="https://img-blog.csdnimg.cn/20200530234244268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>CGlib 编码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCglib</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建原始对象</span></span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class="line"><span class="comment">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         Enhancer.setClassLoader()</span></span><br><span class="line"><span class="comment">         Enhancer.setSuperClass()</span></span><br><span class="line"><span class="comment">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class="line"><span class="comment">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">        enhancer.setClassLoader(TestCglib<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        enhancer.setSuperclass(userService.getClass());</span><br><span class="line"></span><br><span class="line">        MethodInterceptor interceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"--- cglib log ----"</span>);</span><br><span class="line">                Object ret = method.invoke(userService, args); <span class="comment">// 执行原始方法</span></span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        enhancer.setCallback(interceptor);</span><br><span class="line">        UserService userServiceProxy = (UserService) enhancer.create();</span><br><span class="line">        userServiceProxy.login(<span class="string">"zhenyu"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        userServiceProxy.register(<span class="keyword">new</span> User());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p>总结</p>
<ol>
<li>JDK 动态代理<br><code>Proxy.newProxyInstance</code>：通过接口创建代理的实现类</li>
<li>Cglib 动态代理<br><code>Enhancer</code>：通过继承⽗类创建的代理类</li>
</ol>
<h3 id="Spring-工厂如何加工原始对象"><a href="#Spring-工厂如何加工原始对象" class="headerlink" title="Spring 工厂如何加工原始对象"></a>Spring 工厂如何加工原始对象</h3><ul>
<li>思路分析：主要通过 <code>BeanPostProcessor</code> 将原始对象加工为代理对象</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200531001904521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>编码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"--- new log ---"</span>);</span><br><span class="line">                Object ret = method.invoke(bean, args);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(ProxyBeanPostProcessor<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">bean</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(), <span class="title">handler</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br><span class="line">&lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.factory.UserServiceImpl"</span>/&gt;</span><br><span class="line">&lt;!--<span class="number">1</span>. 实现 BeanPostProcessor 进行加工--&gt;</span><br><span class="line">&lt;!--<span class="number">2</span>. 配置文件中对 BeanPostProcessor 进行配置--&gt;</span><br><span class="line">&lt;bean id=<span class="string">"proxyBeanPostProcessor"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.factory.ProxyBeanPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记4——对象的生命周期、配置文件参数化、自定义类型转换器、后置处理Bean</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0%E5%8C%96%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%99%A8%E3%80%81%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86Bean/</url>
    <content><![CDATA[<h3 id="对象的生命周期"><a href="#对象的生命周期" class="headerlink" title="对象的生命周期"></a>对象的生命周期</h3><p>什么是对象的生命周期？</p>
<ul>
<li>⼀个对象 <strong>创建、存活、消亡</strong> 的三个完整过程。</li>
</ul>
<p>为什么要学习对象的生命周期？</p>
<ul>
<li>由 Spring 负责对象的 <strong>创建、存活、销毁</strong>，了解⽣命周期，有利于我们使用好 Spring 为我们创建的对象。</li>
</ul>
<p>生命周期的 3 个阶段：</p>
<ul>
<li>创建阶段 —&gt; 初始化阶段 —&gt; 销毁阶段</li>
</ul>
<h4 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h4><p>Spring 工厂何时创建对象？</p>
<ul>
<li><code>scope=&quot;prototype&quot;</code>：Spring 工厂在获取对象 <code>ctx.getBean(&quot;xxx&quot;)</code> 的同时，创建对象。</li>
<li><code>scope=&quot;singleton&quot;</code>：Spring 工厂创建的同时，创建对象。<br>通过配置 <code>&lt;bean lazy-init=&quot;true&quot;/&gt;</code> 也可以实现工厂获取对象的同时，创建对象。</li>
</ul>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>什么时候？Spring 工厂在创建完对象后，调用对象的初始化方法，完成对应的初始化操作。<br>初始化方法提供：程序员根据需求，提供初始化方法，最终完成初始化操作。<br>初始化方法调用：Spring 工厂进行调用。</p>
<p>提供初始化方法的两种方式：</p>
<ul>
<li><code>InitializingBean</code> 接口：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">	<span class="comment">//程序员根据需求实现的方法, 完成初始化操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.afterPropertiesSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>对象中提供一个普通的初始化方法，配置文件种配置 <code>init-method</code>：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.myInit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line">&lt;bean id=<span class="string">"product"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.life.Product"</span> init-method=<span class="string">"myInit"</span>/&gt;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p>初始化操作的细节分析：</p>
<ol>
<li>如果⼀个对象既实现 <code>InitializingBean</code> 同时⼜提供的 普通的初始化方法，执行顺序?<br>先执行 <code>InitializingBean</code>，再执行 普通初始化方法。</li>
<li>注入⼀定发⽣在初始化操作的前面。</li>
<li>初始化操作到底是什么？<br>资源的初始化：数据库、IO、网络、…</li>
</ol>
<h4 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h4><p>Spring 销毁对象前，会调用对象的销毁方法，完成销毁操作。<br>Spring 什么时候销毁所创建的对象？<code>ctx.close();</code><br>销毁方法提供：程序员根据业务需求，定义销毁方法，完成销毁操作<br>销毁方法调用：Spring 工厂进行调用。</p>
<p>开发流程与初始化操作一样，提供销毁方法的两种方式：</p>
<ul>
<li><code>DisposableBean</code> 接口：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 程序员根据⾃⼰的需求, 定义销毁方法, 完成销毁操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>对象中提供一个普通的销毁方法，配置文件种配置 <code>destroy-method</code>：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 程序员根据⾃⼰的需求, 定义销毁方法, 完成销毁操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.myDestory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br><span class="line">&lt;bean id=<span class="string">"product"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.life.Product"</span> destroy-method=<span class="string">"myDestory"</span>/&gt;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>销毁阶段细节分析</strong>：</p>
<ol>
<li>销毁方法的操作只适用于 <code>scope=&quot;singleton&quot;</code>，初始化操作都适用。</li>
<li>销毁操作到底是什么？<br>资源的释放：<code>io.close()</code>、<code>connection.close()</code>、…</li>
</ol>
<h4 id="对象的生命周期总结"><a href="#对象的生命周期总结" class="headerlink" title="对象的生命周期总结"></a>对象的生命周期总结</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.setName"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Product() &#123; <span class="comment">// 创建</span></span><br><span class="line">        System.out.println(<span class="string">"Product.Product"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序员根据需求实现的方法, 完成初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.myInit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序员根据需求实现的方法, 完成初始化操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.afterPropertiesSet"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myDestory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.myDestory"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序员根据⾃⼰的需求, 定义销毁方法, 完成销毁操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Product.destroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334353637</span></span><br><span class="line">&lt;bean id=<span class="string">"product"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.life.Product"</span> init-method=<span class="string">"myInit"</span> destroy-method=<span class="string">"myDestory"</span>&gt;</span><br><span class="line">	&lt;property name=<span class="string">"name"</span> value=<span class="string">"yusael"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<p><img src="https://img-blog.csdnimg.cn/20200524010228627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="配置文件参数化"><a href="#配置文件参数化" class="headerlink" title="配置文件参数化"></a>配置文件参数化</h3><p><strong>配置文件参数化</strong>：把 Spring 配置文件中需要经常修改的字符串信息，转移到⼀个更小的配置文件中。</p>
<ol>
<li>Spring 的配置文件中是否存在需要经常修改的字符串？<br>存在：以数据库连接相关的参数…</li>
<li>经常变化字符串，在 Spring 的配置文件中，直接修改不利于项目维护（修改）</li>
<li>转移到⼀个小的配置文件（.properties）利于维护（修改）</li>
</ol>
<p>优点：利于 Spring 配置文件的维护（修改）</p>
<h4 id="配置文件参数的开发步骤"><a href="#配置文件参数的开发步骤" class="headerlink" title="配置文件参数的开发步骤"></a>配置文件参数的开发步骤</h4><ul>
<li>提供⼀个小的配置文件（.properities）<br>名字：没有要求<br>放置位置：没有要求</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line">jdbc.driverClassName = com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url = jdbc:mysql://localhost:3306/spring?useSSL=<span class="literal">false</span></span><br><span class="line">jdbc.username = root</span><br><span class="line">jdbc.password = 1234</span><br><span class="line">1234</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Spring 的配置文件与小配置文件进行整合：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring的配置文件与⼩配置文件进行整合--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--resources 下的文件在整个程序编译完后会被放到 classpath 目录下，src.main.java中的文件也是--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/db.properties"</span>/&gt;</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure></div>

<p>在 Spring 配置文件中通过 <code>${key}</code> 获取小配置文件中对应的值：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conn"</span> <span class="attr">class</span>=<span class="string">"com.yusael.factorybean.ConnectionFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">123456</span><br></pre></td></tr></table></figure></div>

<h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><h4 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h4><p>作用：Spring 通过 类型转换器 把 配置文件 中 字符串 类型的数据，转换成了对象中成员变量对应类型的数据，进而完成了注入。<br><img src="https://img-blog.csdnimg.cn/20200524232431470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="自定义类型转换器-1"><a href="#自定义类型转换器-1" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h4><p>产生原因：当 Spring 内部没有提供特定类型转换器时，而程序员在应用的过程中还需要使用，那么<br>就需要程序员⾃⼰定义类型转换器。</p>
<p><strong>[开发步骤]</strong>：</p>
<ul>
<li>类 implements Converter 接口</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     convert方法作用: String ---&gt; Date</span></span><br><span class="line"><span class="comment">     SimpleDateFormat sdf = new SimpleDateFormat();</span></span><br><span class="line"><span class="comment">     sdf.parset(String) ---&gt; Date</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     参数:</span></span><br><span class="line"><span class="comment">     source : 代表的是配置文件中, 日期字符串 &lt;value&gt;2020-10-11&lt;/value&gt;</span></span><br><span class="line"><span class="comment">     return : 当把转换好的 Date 作为 convert 方法的返回值后,</span></span><br><span class="line"><span class="comment">             Spring ⾃动的为birthday属性进行注入（赋值）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            date = sdf.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在 Spring 的配置文件中进行配置；<br>先创建 <code>MyDateConverter</code> 对象，再注册类型转换器；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建 MyDateConverter 对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDateConverter"</span> <span class="attr">class</span>=<span class="string">"com.yusael.converter.MyDateConverter"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用于注册类型转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"good"</span> <span class="attr">class</span>=<span class="string">"com.yusael.converter.Good"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhenyu"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">value</span>=<span class="string">"2012-12-12"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure></div>

<h4 id="自定义类型转换器细节"><a href="#自定义类型转换器细节" class="headerlink" title="自定义类型转换器细节"></a>自定义类型转换器细节</h4><ul>
<li><code>MyDateConverter</code> 中的<strong>日期的格式</strong>，通过 <strong>依赖注入</strong> 的方式，由配置文件完成赋值。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String pattern;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(pattern);</span><br><span class="line">            date = sdf.parse(source);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPattern</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br><span class="line">&lt;!-- 配置文件完成对日期格式的赋值 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"myDateConverter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.converter.MyDateConverter"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"pattern"</span> value=<span class="string">"yyyy-MM-dd"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>ConversionSeviceFactoryBean</code> 定义 id属性，值必须是 <code>conversionService</code>；</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Spring 框架其实内置了日期类型的转换器：日期格式必须是 <code>2020/05/01</code>。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"good"</span> <span class="attr">class</span>=<span class="string">"com.yusael.converter.Good"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"zhenyu"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">value</span>=<span class="string">"2012/12/12"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure></div>

<h3 id="后置处理-Bean"><a href="#后置处理-Bean" class="headerlink" title="后置处理 Bean"></a>后置处理 Bean</h3><p>BeanPostProcessor 作用：对 Spring 工厂所创建的对象，进行再加工。（AOP 的底层实现）</p>
<h4 id="后置处理-Bean-原理分析"><a href="#后置处理-Bean-原理分析" class="headerlink" title="后置处理 Bean 原理分析"></a>后置处理 Bean 原理分析</h4><p><img src="https://img-blog.csdnimg.cn/2020052517103049.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>程序员实现 <code>BeanPostProcessor</code> 接口中规定的两个方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<p>作用：Spring <strong>创建完对象，并进行注入后</strong>，可以运行 <code>Before</code> ⽅法进行加工；</p>
<ul>
<li>通过方法的参数获得 Spring 创建好的对象，最终通过返回值交给 Spring 框架。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<p>作⽤：Spring <strong>执行完对象的初始化操作后</strong>，可以运行 <code>After</code> ⽅法进行加工；</p>
<ul>
<li>通过方法的参数获得 Spring 创建好的对象，最终通过返回值交给 Spring 框架。</li>
</ul>
<p>实战中：很少处理 Spring 的初始化操作，没有必要区分 <code>Before</code>，<code>After</code>。只需要实现其中一个，建议是 <code>After</code> 方法即可。</p>
<h4 id="BeanPostProcessor-开发步骤"><a href="#BeanPostProcessor-开发步骤" class="headerlink" title="BeanPostProcessor 开发步骤"></a>BeanPostProcessor 开发步骤</h4><ol>
<li>类 实现 <code>BeanPostProcessor</code> 接口</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Category category = (Category) bean;</span><br><span class="line">        category.setName(<span class="string">"yusael"</span>);</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>Spring 配置文件中进行配置</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myBeanPostProcessor"</span> <span class="attr">class</span>=<span class="string">"com.yusael.beanpost.MyBeanPostProcessor"</span>/&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<p><strong>细节</strong>：BeanPostProcessor 会对 Spring 工厂创建的<strong>所有对象</strong>进行加工。如果工厂创建了多个不同的对象，要注意区别传入的对象：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span>  Category) &#123;</span><br><span class="line">        Category category = (Category) bean;</span><br><span class="line">        category.setName(<span class="string">"yusael"</span>);</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV185411477k?p=63" target="_blank" rel="noopener">B站孙帅</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记6——基于注解的 AOP 编程</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84-AOP-%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol>
<li>原始功能</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String name, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl.register 业务运算 + DAO"</span>);</span><br><span class="line">        <span class="comment">// throw new RuntimeException("测试异常");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Log</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl.login 业务运算 + DAO"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>额外功能</li>
<li>切入点</li>
<li>组装切面</li>
</ol>
<p>2、3、4 都放在了 <code>MyAspect</code> 类中完成：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 额外功能</span></span><br><span class="line"><span class="comment">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class="line"><span class="comment">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class="line"><span class="comment">                Object ret = invocation.invoke();</span></span><br><span class="line"><span class="comment">                return ret;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        &lt;bean id="around" class="com.yusael.dynamic.Around"/&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    2. 切入点</span></span><br><span class="line"><span class="comment">        &lt;aop:config&gt;</span></span><br><span class="line"><span class="comment">            &lt;aop:pointcut id="pc" expression="execution(* login(..)))"/&gt;</span></span><br><span class="line"><span class="comment">            &lt;aop:advisor advice-ref="around" pointcut-ref="pc"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/aop:config&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* login(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- aspect log ----"</span>);</span><br><span class="line">        Object ret = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"userService"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.aspect.UserServiceImpl"</span>/&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        切面:</span><br><span class="line">            <span class="number">1</span>. 额外功能</span><br><span class="line">            <span class="number">2</span>. 切入点啊</span><br><span class="line">            <span class="number">3</span>. 组装切面</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"around"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.yusael.aspect.MyAspect"</span>/&gt;</span><br><span class="line">    &lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure></div>

<h3 id="切入点复用"><a href="#切入点复用" class="headerlink" title="切入点复用"></a>切入点复用</h3><p>切入点复用：在切面类中定义⼀个函数，上面用 <code>@Pointcut</code> 注解。<br>通过这种方式定义切入点表达式，后续更加有利于切入点复用。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* login(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPoincut</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"myPoincut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- aspect log ----"</span>);</span><br><span class="line">        Object ret = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"myPoincut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around1</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---- aspect transaction ----"</span>);</span><br><span class="line">        Object ret = joinPoint.proceed();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure></div>

<h3 id="切换动态代理的创建方式（JDK、Cglib）"><a href="#切换动态代理的创建方式（JDK、Cglib）" class="headerlink" title="切换动态代理的创建方式（JDK、Cglib）"></a>切换动态代理的创建方式（JDK、Cglib）</h3><p>AOP 底层实现 2 种代理创建方式：</p>
<ol>
<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>
<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>
</ol>
<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong>。</p>
<p>基于注解的 AOP 开发 中切换为 Cglib：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<p>传统的 AOP 开发 中切换为 Cglib：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure></div>

<h3 id="AOP-开发中的一个坑（业务方法互相调用）"><a href="#AOP-开发中的一个坑（业务方法互相调用）" class="headerlink" title="AOP 开发中的一个坑（业务方法互相调用）"></a>AOP 开发中的一个坑（业务方法互相调用）</h3><p><strong>坑！</strong>：在同⼀个业务类中，进⾏业务方法间的相互调用，只有最外层的方法，才是加入了额外功能(内部的方法，通过普通的方式调用，都调用的是原始方法)。如果想让内层的方法也调用代理对象的方法，就要实现 <code>AppicationContextAware</code> 获得⼯厂，进而获得代理对象。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        ctx = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl.register 业务运算 + DAO"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this.login("zhenyu", "123456"); // 这么写调用的是本类的 login 方法, 即原始对象的 login 方法</span></span><br><span class="line">        <span class="comment">// 为什么不在这里创建一个工厂获取代理对象呢？</span></span><br><span class="line">        <span class="comment">// Spring的工厂是重量级资源, 一个应用中应该只创建一个工厂.</span></span><br><span class="line">        <span class="comment">// 因此我们必须通过 ApplicationContextAware 拿到已经创建好的工厂</span></span><br><span class="line">        UserService userService = (UserService) ctx.getBean(<span class="string">"userService"</span>);</span><br><span class="line">        userService.login(<span class="string">"yusael"</span>, <span class="string">"123456"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserServiceImpl.login 业务运算 + DAO"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure></div>

<h3 id="AOP-知识总结"><a href="#AOP-知识总结" class="headerlink" title="AOP 知识总结"></a>AOP 知识总结</h3><p><img src="https://img-blog.csdnimg.cn/20200531153411611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记8——Spring 事务开发、事务属性详解</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08%E2%80%94%E2%80%94Spring-%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%8F%91%E3%80%81%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="事务回顾"><a href="#事务回顾" class="headerlink" title="事务回顾"></a>事务回顾</h3><p><strong>什么是事务？</strong></p>
<ul>
<li>事务时保证业务操作完整性的一种<strong>数据库机制</strong>。</li>
</ul>
<p>事务的 4 大特点： <code>A</code>、<code>C</code>、<code>I</code>、<code>D</code></p>
<ul>
<li><code>A</code> 原子性</li>
<li><code>C</code> 一致性</li>
<li><code>I</code> 隔离性</li>
<li><code>D</code> 持久性</li>
</ul>
<p><strong>如何控制事务?</strong>（JDBC、Mybatis）<br>JDBC</p>
<ul>
<li><code>Connection.setAutoCommit(false);</code></li>
<li><code>Connection.commit();</code></li>
<li><code>Connection.rollback();</code></li>
</ul>
<p>Mybatis</p>
<ul>
<li>Mybatis 自动开启事务</li>
<li><code>sqlSession.commit();</code>，底层还是调用的 <code>Connection</code></li>
<li><code>sqlSession.rollback();</code>，底层还是调用的 <code>Connection</code></li>
</ul>
<p>结论：控制事务的底层，都是通过 <code>Connection</code> 对象完成的。</p>
<h3 id="Spring-控制事务的开发"><a href="#Spring-控制事务的开发" class="headerlink" title="Spring 控制事务的开发"></a>Spring 控制事务的开发</h3><ul>
<li>搭建开发环境 <code>pom.xml</code></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<ul>
<li>编码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span> <span class="attr">ref</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDAO userDAO;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>细节<br>进行动态代理底层实现的切换，默认 <code>false</code> 是 JDK，<code>true</code> 是 Cglib。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure></div>

<h3 id="Spring-中的事务属性（Transaction-Attribute）"><a href="#Spring-中的事务属性（Transaction-Attribute）" class="headerlink" title="Spring 中的事务属性（Transaction Attribute）"></a>Spring 中的事务属性（Transaction Attribute）</h3><p><strong>什么是事务属性</strong>？</p>
<p><strong>属性</strong>：描述物体特征的一系列值（性别、身高、体重）</p>
<p><strong>事务属性</strong>：描述事务特征的一系列值</p>
<ol>
<li>隔离属性</li>
<li>传播属性</li>
<li>只读属性</li>
<li>超时属性</li>
<li>异常属性</li>
</ol>
<p><strong>如何添加事务属性？</strong></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(isolation=, propagation=, readOnly=,timeout=,rollbackFor,noRollbackFor=,)</span><br></pre></td></tr></table></figure></div>

<h4 id="隔离属性（ISLOATION）"><a href="#隔离属性（ISLOATION）" class="headerlink" title="隔离属性（ISLOATION）"></a>隔离属性（ISLOATION）</h4><p>概念：<strong>描述了事务解决并发问题的特征</strong>。</p>
<ol>
<li><strong>什么是并发？</strong><br>多个事务（用户）在同一时间，访问操作了相同的数据。<br>同一时间：0.000 几秒左右</li>
<li>并发会产生那些问题？<ul>
<li>脏读</li>
<li>不可重复读</li>
<li>幻影读</li>
</ul>
</li>
<li><strong>并发问题如何解决？</strong><br>通过隔离属性解决，隔离属性中设置不同过的值，解决并发处理的过程中的问题。</li>
</ol>
<hr>
<p><strong>事务并发产生的问题：</strong></p>
<ul>
<li><strong>脏读</strong><br>一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象<br>解决方案：<code>@Transaction(isolation=Isolation.READ_COMMITTED)</code></li>
<li><strong>不可重复读</strong><br>一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象<br>注意：1.不是脏读 2.在一个事务中<br>解决方案：<code>@Transaction(isolation=Isolation.REPEATABLE_READ)</code><br>本质：一把行锁（对数据库表的某一行加锁）</li>
<li><strong>幻影读</strong><br>一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题<br>解决方案：<code>@Transaction(isolation=Isolation.SERIALIZABLE)</code><br>本质：表锁（对数据库某个表加锁）</li>
</ul>
<hr>
<p><strong>安全与效率对比：</strong></p>
<ul>
<li>并发安全：<code>SERIALIZABLE</code> &gt; <code>READ_ONLY</code> &gt; <code>READ_COMMITTED</code></li>
<li>运行效率：<code>READ_COMMITTED</code> &gt; <code>READ_ONLY</code> &gt; <code>SERIALIZABLE</code></li>
</ul>
<hr>
<p><strong>数据库对隔离属性的支持：</strong></p>
<table>
<thead>
<tr>
<th>隔离属性的值</th>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody><tr>
<td><code>ISOLATION_READ_COMMITTED</code></td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><code>ISOLATION_REPEATABLE_READ</code></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><code>ISOLATION_SERIALIZABLE</code></td>
<td>支持</td>
<td>支持hi</td>
</tr>
</tbody></table>
<ul>
<li>Oracle 不支持 <code>REPEATABLE_READ</code>，那该如何解决不可重复读？<br>采用 <strong>多版本比对</strong> 的方式解决不可重复读问题。</li>
</ul>
<hr>
<p><strong>默认的隔离属性</strong>：</p>
<ul>
<li>Spring 会指定为 <code>ISOLATION_DEFAULT</code>，调用不同数据库所设置的默认隔离属性<br>MySQL：<code>REPEATABLE_READ</code><br>Oracle：<code>READ_COMMITTED</code></li>
<li>查看数据库的默认隔离属性：<br>MySQL：<code>SELECT @@tx_isolation;</code><br>Oracle：较麻烦，建议百度。</li>
</ul>
<hr>
<p><strong>隔离属性在实验中的建议</strong>：</p>
<ul>
<li>推荐使用 Spring 默认指定的 <code>ISOLATION_DEFAULT</code></li>
<li>未来的实战中，遇到并发访问的情况，很少见</li>
<li>如果真的遇到并发问题，解决方案：<strong>乐观锁</strong><br>Hibernate(JPA)：version<br>MyBatis：通过拦截器自定义开发</li>
</ul>
<h4 id="传播属性（PROPAGATION）"><a href="#传播属性（PROPAGATION）" class="headerlink" title="传播属性（PROPAGATION）"></a>传播属性（PROPAGATION）</h4><p>概念：描述了事务解决 <strong>嵌套 问题</strong> 的特征。</p>
<p><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。</p>
<p><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性。</p>
<p>传播属性的值及其用法：</p>
<table>
<thead>
<tr>
<th>传播属性的值</th>
<th>外部不存在事务</th>
<th>外部存在事务</th>
<th>用法</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>开启新的事务</td>
<td>融合到外部事务中</td>
<td><code>@Transactional(propagation = Propagation.REQUIRED)</code></td>
<td>增、删、改方法</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>不开启事务</td>
<td>融合到外部事务中</td>
<td><code>@Transactional(propagation = Propagation.SUPPORTS)</code></td>
<td>查询方法</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>开启新的事务</td>
<td>挂起外部事务，创建新的事务</td>
<td><code>@Transactional(propagation = Propagation.REQUIRES_NEW)</code></td>
<td>日志记录方法中</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不开启事务</td>
<td>挂起外部事务</td>
<td><code>@Transactional(propagation = Propagation.NOT_SUPPORTED)</code></td>
<td>极其不常用</td>
</tr>
<tr>
<td>NEVER</td>
<td>不开启事务</td>
<td>抛出异常</td>
<td><code>@Transactional(propagation = Propagation.NEVER)</code></td>
<td>极其不常用</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>抛出异常</td>
<td>融合到外部事物中</td>
<td><code>@Transactional(propagation = Propagation.MANDATORY)</code></td>
<td>极其不常用</td>
</tr>
</tbody></table>
<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>
<p>推荐传播属性的使用方式：</p>
<ul>
<li>增删改 方法：使用默认值 REQUIRED</li>
<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>
</ul>
<h4 id="只读属性（readOnly）"><a href="#只读属性（readOnly）" class="headerlink" title="只读属性（readOnly）"></a>只读属性（readOnly）</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：<code>false</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<h4 id="超时属性（timeout）"><a href="#超时属性（timeout）" class="headerlink" title="超时属性（timeout）"></a>超时属性（timeout）</h4><p>指定了事务等待的最长时间。</p>
<ol>
<li>为什么事务会进行等待？<br>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</li>
<li>等待时间，单位是 <strong>秒</strong></li>
<li>如何使用：<code>@Transactional(timeout = 2)</code></li>
<li>超时属性的默认值：-1<br>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</li>
</ol>
<h4 id="异常属性"><a href="#异常属性" class="headerlink" title="异常属性"></a>异常属性</h4><p>Spring 事务处理过程中：</p>
<ul>
<li>默认对于 <code>RuntimeException</code> 及其子类，采用 <strong>回滚</strong> 的策略。</li>
<li>默认对于 <code>Exception</code> 及其子类，采用 <strong>提交</strong> 的策略。</li>
</ul>
<p>使用方法：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(rollbackFor = java.lang.Exception<span class="class">.<span class="keyword">class</span>, <span class="title">xxx</span>, <span class="title">xxx</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">Transactional</span>(<span class="title">noRollbackFor</span> </span>= java.lang.RuntimeException, xxx, xxx)</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<p>建议：实战中使用 <code>RuntimeException</code> 及其子类，使用事务异常属性的默认值。</p>
<h3 id="事务属性常见配置总结"><a href="#事务属性常见配置总结" class="headerlink" title="事务属性常见配置总结"></a>事务属性常见配置总结</h3><ol>
<li>隔离属性 默认值</li>
<li>传播属性 Required（默认值）增删改、Supports 查询操作</li>
<li>只读属性 readOnly=false 增删改，true 查询操作</li>
<li>超时属性 默认值 -1</li>
<li>异常属性 默认值</li>
</ol>
<p>增删改操作：<code>@Transactional</code><br>查询操作：<code>@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)</code></p>
<h3 id="基于标签的事务配置方式"><a href="#基于标签的事务配置方式" class="headerlink" title="基于标签的事务配置方式"></a>基于标签的事务配置方式</h3><p>基于注解 <code>@Transaction</code> 的事务配置回顾：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.yusael.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span> <span class="attr">ref</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    private UserDAO userDAO;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>/&gt;</span></span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure></div>

<p>基于标签的事务配置：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pc"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.yusael.service.UserServiceImpl.register(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure></div>

<p>基于标签的事务配置在 <strong>实战</strong> 中的应用方式：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"register"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"modify*"</span>/&gt;</span></span><br><span class="line">        编程时候, service中负责进行增删改操作的方法 都以 modify 开头</span><br><span class="line">        						  查询操作 命名无所谓</span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pc"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.yusael.service..*.*(..))"</span>/&gt;</span></span><br><span class="line">   	应用的过程中, 将 service 都放到 service 包下</span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pc"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记7——Spring与Mybatis 整合</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07%E2%80%94%E2%80%94Spring%E4%B8%8EMybatis-%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h3 id="持久层整合总述"><a href="#持久层整合总述" class="headerlink" title="持久层整合总述"></a>持久层整合总述</h3><p>1、Spring 框架为什么要与持久层技术进行整合？</p>
<ul>
<li>JavaEE开发需要持久层进行数据库的访问操作</li>
<li>JDBC、Hibernate、MyBatis 进行持久开发过程存在大量的代码冗余</li>
<li>Spring 基于模板设计模式对于上述的持久层技术进行了封装</li>
</ul>
<p>2、Spring 可以与哪些持久层技术进行整合？</p>
<ul>
<li>JDBC —— <code>JDBCTemplate</code></li>
<li>Hibernate（JPA）—— <code>HibernateTemplate</code></li>
<li><strong>MyBatis</strong> —— <code>SqlSessionFactoryBean</code>、<code>MapperScannerConfigure</code></li>
</ul>
<h3 id="Mybatis-开发步骤回顾"><a href="#Mybatis-开发步骤回顾" class="headerlink" title="Mybatis 开发步骤回顾"></a>Mybatis 开发步骤回顾</h3><ol>
<li>实体类 <code>User</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer id, String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>实体别名 <code>mybatis-config.xml</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Confi 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.yusael.mybatis.User"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/yus?useSSL=false"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"1234"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">123456789101112131415161718192021</span><br></pre></td></tr></table></figure></div>

<ol>
<li>表 t_users</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_users <span class="keyword">values</span> (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">12</span>),</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">12</span>)</span><br><span class="line">);</span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<ol>
<li>创建 DAO 接口：<code>UserDAO</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>实现Mapper文件：<code>UserDAOMapper.xml</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.yusael.mybatis.UserDAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"save"</span> <span class="attr">parameterType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">        insert into t_users(name, password) values (#&#123;name&#125;, #&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">123456789</span><br></pre></td></tr></table></figure></div>

<ol>
<li>注册 Mapper 文件 <code>mybatis-config.xml</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"UserDAOMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure></div>

<ol>
<li>MybatisAPI 调用</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        UserDAO userDAO = session.getMapper(UserDAO<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"yusael"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        userDAO.save(user);</span><br><span class="line"></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Mybatis-开发中存在的问题"><a href="#Mybatis-开发中存在的问题" class="headerlink" title="Mybatis 开发中存在的问题"></a>Mybatis 开发中存在的问题</h3><p>问题：配置繁琐、代码冗余</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 实体</span><br><span class="line"><span class="number">2.</span> 实体别名					配置繁琐</span><br><span class="line"><span class="number">3.</span> 表</span><br><span class="line"><span class="number">4.</span> 创建 DAO 接口</span><br><span class="line"><span class="number">5.</span> 实现 Mapper 文件</span><br><span class="line"><span class="number">6.</span> 注册 Mapper 文件			配置繁琐</span><br><span class="line"><span class="number">7.</span> Mybatis API 调用			代码冗余</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Spring-与-Mybatis-整合思路"><a href="#Spring-与-Mybatis-整合思路" class="headerlink" title="Spring 与 Mybatis 整合思路"></a>Spring 与 Mybatis 整合思路</h3><p><img src="https://img-blog.csdnimg.cn/20200601233746981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200601233815685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzczNDA5NQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="Spring-与-Mybatis-整合的开发步骤"><a href="#Spring-与-Mybatis-整合的开发步骤" class="headerlink" title="Spring 与 Mybatis 整合的开发步骤"></a>Spring 与 Mybatis 整合的开发步骤</h3><ul>
<li>配置文件（ApplicationContext.xml）进行相关配置（<strong>只需要配置一次</strong>）</li>
<li>编码<br>1.实体类<br>2.表<br>3.创建DAO接口<br>4.Mapper文件配置</li>
</ul>
<h3 id="Spring-与-Mybatis-整合的编码"><a href="#Spring-与-Mybatis-整合的编码" class="headerlink" title="Spring 与 Mybatis 整合的编码"></a>Spring 与 Mybatis 整合的编码</h3><h4 id="搭建开发环境-pom-xml"><a href="#搭建开发环境-pom-xml" class="headerlink" title="搭建开发环境 pom.xml"></a>搭建开发环境 pom.xml</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="Spring-配置文件的配置"><a href="#Spring-配置文件的配置" class="headerlink" title="Spring 配置文件的配置"></a>Spring 配置文件的配置</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/yus?useSSL=false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"1234"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 指定实体类所在的包 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.yusael.entity"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定配置文件（映射文件）的路径，还有通用配置--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"scanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactoryBean"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定DAO接口放置的包--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.yusael.dao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ol>
<li>实体 <code>com.yusael.entity.User</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>表 <code>t_user</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_users <span class="keyword">values</span> (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">12</span>),</span><br><span class="line">	<span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">12</span>)</span><br><span class="line">);</span><br><span class="line">12345</span><br></pre></td></tr></table></figure></div>

<ol>
<li>DAO接口 <code>com.yusael.dao.UserDAO</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>Mapper文件配置 <code>resources/applicationContext.xml</code></li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/yus?useSSL=false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"1234"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.yusael.entity"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"scanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactoryBean"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.yusael.dao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">123456789101112131415161718192021222324252627282930</span><br></pre></td></tr></table></figure></div>

<ol>
<li>测试</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于测试: Spring 与 Mybatis 的整合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"/applicationContext.xml"</span>);</span><br><span class="line">    UserDAO userDAO = (UserDAO) ctx.getBean(<span class="string">"userDAO"</span>);</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"xiaojr"</span>);</span><br><span class="line">    user.setPassword(<span class="string">"999999"</span>);</span><br><span class="line"></span><br><span class="line">    userDAO.save(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Spring-与-Mybatis-整合细节"><a href="#Spring-与-Mybatis-整合细节" class="headerlink" title="Spring 与 Mybatis 整合细节"></a>Spring 与 Mybatis 整合细节</h2><p>问题：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>
<ol>
<li>Mybatis 提供的连接池对象 —&gt; 创建 <code>Connection</code><br><code>Connection.setAutoCommit(false)</code> 手工的控制了事务，操作完成后，需要手工提交。</li>
<li>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 <code>Connection</code><br><code>Connection.setAutoCommit(true)</code> 默认值为 <code>true</code>，保持自动控制事务，一条 sql 自动提交。</li>
</ol>
<p>答案：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制<code>Connection.setAutoCommit(true)</code>，不需要手工进行事务的操作，也能进行事务的提交。</p>
<p>注意：实战中，还是会手工控制事务（多条SQL一起成功，一起失败），后续 Spring 通过 <strong>事务控制</strong> 解决这个问题。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——MongoDb</title>
    <url>/2020/07/10/SpringBoot%E2%80%94%E2%80%94MongoDb/</url>
    <content><![CDATA[<h2 id="SpringBoot——MongoDB"><a href="#SpringBoot——MongoDB" class="headerlink" title="SpringBoot——MongoDB"></a>SpringBoot——MongoDB</h2><h3 id="Maven依赖及配置MongoDB的uri"><a href="#Maven依赖及配置MongoDB的uri" class="headerlink" title="Maven依赖及配置MongoDB的uri"></a>Maven依赖及配置MongoDB的uri</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.data.mongodb.uri</span>=<span class="string">mongodb://springbucks:springbucks@localhost:27017/springbucks</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Spring对MongDB的支持"><a href="#Spring对MongDB的支持" class="headerlink" title="Spring对MongDB的支持"></a>Spring对MongDB的支持</h3><ul>
<li><p>Spring Data MongoDB</p>
<ul>
<li><p>MongoTemple</p>
</li>
<li><p>Repository支持</p>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-Data-MongoDB的实体类注解"><a href="#Spring-Data-MongoDB的实体类注解" class="headerlink" title="Spring Data MongoDB的实体类注解"></a>Spring Data MongoDB的实体类注解</h3><ul>
<li>@Document</li>
<li>@Id</li>
</ul>
<h3 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h3><ul>
<li><p>MongoTemplate常用方法</p>
<ol>
<li><code>mongoTemplate.findAll(Student.class)</code>: 查询Student文档的全部数据</li>
<li><code>mongoTemplate.findById(, Student.class)</code>: 查询Student文档id为id的数据</li>
<li><code>mongoTemplate.find(query, Student.class);</code>: 根据query内的查询条件查询</li>
<li><code>mongoTemplate.upsert(query, update, Student.class)</code>: 修改</li>
<li><code>mongoTemplate.remove(query, Student.class)</code>: 删除</li>
<li><code>mongoTemplate.insert(student)</code>: 新增</li>
</ol>
</li>
<li><p>Query对象和Criteria对象</p>
<ol>
<li>创建一个query对象（用来封装所有条件对象)，再创建一个criteria对象（用来构建条件）</li>
<li>精准条件：Query.query(Criteria.where(<key>).is(<condition>))</condition></key></li>
<li>模糊条件：Query.query(Criteria.and(<key>).regex(<condition>))</condition></key></li>
<li>封装条件：query.addCriteria(criteria)</li>
<li>大于（创建新的criteria）：Criteria gt = Criteria.where(<key>).gt（<condition>）</condition></key></li>
<li>小于（创建新的criteria）：Criteria lt = Criteria.where(<key>).it（<condition>）</condition></key></li>
<li>Query.addCriteria(new Criteria().andOperator(gt,lt));</li>
<li>一个query中只能有一个andOperator()。其参数也可以是Criteria数组。</li>
<li>排序  ：query.with（new Sort(Sort.Direction.ASC, “age”). and(new Sort(Sort.Direction.DESC, “date”)))</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line">        Coffee espresso = Coffee.builder().</span><br><span class="line">                name(<span class="string">"espresso"</span>)</span><br><span class="line">                .price(Money.of(CurrencyUnit.of(<span class="string">"CNY"</span>), <span class="number">20.0</span>))</span><br><span class="line">                .createTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .updateTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .build();</span><br><span class="line">        Coffee saved = mongoTemplate.save(espresso);</span><br><span class="line">        log.info(<span class="string">"Coffee:&#123;&#125;"</span>, saved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找</span></span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        Criteria where = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"espresso"</span>);</span><br><span class="line">        query.addCriteria(where);</span><br><span class="line">        Coffee coffee = mongoTemplate.findOne(</span><br><span class="line">                query, Coffee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//在这里可以写成这种形式</span></span><br><span class="line"><span class="comment">//        Coffee coffee1 = mongoTemplate.findOne(</span></span><br><span class="line"><span class="comment">//                Query.query(Criteria.where("name").is("espresso")), Coffee.class);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        log.info("Find &#123;&#125; Coffee", list.size());</span></span><br><span class="line">        log.info(<span class="string">"FindOne:&#123;&#125;"</span>, coffee);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        UpdateResult result = mongoTemplate.updateFirst(Query.query(Criteria.where(<span class="string">"name"</span>).is(<span class="string">"espresso"</span>)),</span><br><span class="line">                <span class="keyword">new</span> Update().set(<span class="string">"price"</span>, Money.ofMajor(CurrencyUnit.of(<span class="string">"CNY"</span>), <span class="number">30</span>))</span><br><span class="line">                        .currentDate(<span class="string">"updateTime"</span>), Coffee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        log.info(<span class="string">"Update Result:&#123;&#125;"</span>, result.getModifiedCount());</span><br><span class="line">        Coffee updateOne = mongoTemplate.findById(coffee.getId(), Coffee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        log.info(<span class="string">"Update Result:&#123;&#125;"</span>, updateOne);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line"><span class="comment">//        mongoTemplate.remove(updateOne);</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Spring-Data-Mongo的Repository"><a href="#Spring-Data-Mongo的Repository" class="headerlink" title="Spring Data Mongo的Repository"></a>Spring Data Mongo的Repository</h3><ul>
<li>@EnableMongoRepositories：在项目的Application入口添加该注解，让应用可以自动识别MongoDB的Repository，Mongo有以下的Repository：这些Repository的操作跟JpaRepository一样<ol>
<li>MongRepository&lt;T, ID&gt;</li>
<li>PagingAndSortingRepository&lt;T, ID&gt;</li>
<li>CrudRepository&lt;T, ID&gt;</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-SpringBoot -MongoDb</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——Controller</title>
    <url>/2020/07/17/SpringBoot%E2%80%94%E2%80%94Controller/</url>
    <content><![CDATA[<h3 id="Controller中相关的注解"><a href="#Controller中相关的注解" class="headerlink" title="Controller中相关的注解"></a>Controller中相关的注解</h3><ul>
<li><p><code>@Controller</code>：表示一个类为Controller，return时会被视图处理器识别成静态文件的路径。默认为templates文件夹下。如<code>return &quot;test/hello&quot;</code>表示的是默认路径下的test文件夹中的名叫hello的文件，带上后缀名.html或btl等也可以识别。</p>
</li>
<li><p><code>@ResponseBody</code>：可以标注方法也可以标注类，当标注方法时表示该方法的返回值会被解析成json（字符串会不会被转换），直接写入HTTP Response Body中，视图处理器将不会将return的参数识别成路径。当它标注类时，类中所有方法的返回值都将直接返回值到页面，相当于给所有的方法都加上@ResponseBody注解。</p>
</li>
<li><p><code>@RestController</code>：@RestController是@Controller和@ResponseBody的结合体，只能注解类，return返回的值将被转换成json，字符串除外，直接写入HTTP相应体返回到页面中。</p>
</li>
<li><p><code>@RequestMapping</code>：它可以注解类也可以注解方法，注解类时标注请求的路径，标注方法时表示将特定的URL映射到指定的方法。@RequestMapping中有多个属性来进一步匹配HTTP请求到方法，例如下面代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/coffee"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CoffeeService coffeeService;</span><br><span class="line">    <span class="comment">//GetMapping是RequestMapping+Get请求的结合体</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(path=<span class="string">"/"</span>, params = <span class="string">"!name"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Coffee&gt; <span class="title">getAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffeeService.getAllCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>RequestMapping的一些参数：<ol>
<li>value：指定请求的实际地址，指定的地址可以是URI Template 模式；</li>
<li>path：和value一样</li>
<li>method：指定请求的method类型， GET、POST、PUT、DELETE等</li>
<li>params：指定request中必须包含某些参数值时，才让该方法处理。</li>
<li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li>
<li>consumes：指定处理请求的提交内容类型（Content-Type）</li>
<li>produces：指定返回的内容类型（Accept）</li>
</ol>
</li>
</ul>
</li>
<li><p><code>@PathVariable</code>：用于获取URL中的参数：一般{ }中的变量名与方法中的形参名一致(可以不加@PathVariable注解)，如下面代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Coffee&gt; <span class="title">getById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">    Coffee coffee = coffeeService.getCoffee(id);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">        .cacheControl(CacheControl.maxAge(<span class="number">10</span>, TimeUnit.SECONDS))</span><br><span class="line">        .body(coffee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>@RquestParam</code>：用来获取URL中查询参数的值：params中的变量名与方法中的形参名一致，如下面代码：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(params = &#123;<span class="string">"name"</span>&#125;)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Coffee <span class="title">getByName</span><span class="params">(@RequestParam String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> coffeeService.getCoffee(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>@ResponseStatus</code>：用于设置返回响应的状态码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/"</span>, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">//返回201CREATED状态码</span></span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Coffee <span class="title">addCoffee</span><span class="params">(@Valid NewCoffeeRequest newCoffee, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">        log.warn(<span class="string">"errors:&#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FormValidationException(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>@Get/Post/Put/DeleteMapping</code>：主要用来匹配RestfulApi的请求，其实就是RequestMapping+一些请求Method</p>
</li>
</ul>
<h2 id="处理响应的两种方式"><a href="#处理响应的两种方式" class="headerlink" title="处理响应的两种方式"></a>处理响应的两种方式</h2><ul>
<li>使用默认返回的方式</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/"</span>, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Coffee <span class="title">addCoffee</span><span class="params">(@Valid NewCoffeeRequest newCoffee, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">        log.warn(<span class="string">"errors:&#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FormValidationException(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>使用ResponseEntity</p>
<p>使用ResponseEntity有两种写法：</p>
<ol>
<li>构造ResponseEntity，可以在构造器中传入响应体<code>body</code>、响应头<code>headers</code>、状态码<code>status</code>。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Coffee&gt; <span class="title">addJsonCoffee</span><span class="params">(@RequestBody @Valid NewCoffeeRequest newCoffee, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">        log.warn(<span class="string">"errors:&#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationException(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    Coffee coffee = coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());</span><br><span class="line">    <span class="comment">//设置响应头参数</span></span><br><span class="line">    HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    responseHeaders.set(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(coffee, responseHeaders, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>采用链式调用，这里可以使用HeaderBuilder和BodyBuilder设置一些关于Header和Body的一些熟悉，例如：缓存相关的cacheControl、ETag、LastModify等、响应体相关的ContentType、ContentLength、路由相关的Location、Allow等。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Coffee&gt; <span class="title">getById</span><span class="params">(@PathVariable Long id)</span></span>&#123;</span><br><span class="line">    Coffee coffee = coffeeService.getCoffee(id);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok()</span><br><span class="line">        .cacheControl(CacheControl.maxAge(<span class="number">10</span>, TimeUnit.SECONDS))</span><br><span class="line">        .body(coffee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



</li>
</ul>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——AOP</title>
    <url>/2020/07/18/SpringBoot%E2%80%94%E2%80%94AOP/</url>
    <content><![CDATA[<h3 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h3><p>​        SpringBoot动态代理分为两种，一种是JDK的动态代理，另一种是cglib的动态代。Spring Boot默认使用JDK的动态代理，当类没有实现接口时才使用cglib的动态代理。</p>
<ol>
<li>JDK的动态代理，在这个例子里，被代理类实现了UserService接口，而代理类通过实现与被代理类实现的相同接口UserService，并在内部把被代理类进行注入，就可以实现对被代理类的逻辑增强。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printUserInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserInfo print"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"========Before Print========"</span>);</span><br><span class="line">        userService.printUserInfo();</span><br><span class="line">        System.out.println(<span class="string">"========After Print========"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        userService.printUserInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>cglib动态代理，通过自定义拦截器并实现MethodInterceptor 接口来对被代理类进行拦截，并对逻辑进行增强。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIntercepter</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//增强逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"代理前，增强逻辑"</span>);</span><br><span class="line">        methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="comment">//增强逻辑</span></span><br><span class="line">        System.out.println(<span class="string">"代理后，增强逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="AOP的介绍"><a href="#AOP的介绍" class="headerlink" title="AOP的介绍"></a>AOP的介绍</h3><p>​        AOP（Aspect Oriented Programing）：面向切面编程，将通用的逻辑从业务逻辑中分离出来。AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的四周，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<h3 id="AOP的相关概念"><a href="#AOP的相关概念" class="headerlink" title="AOP的相关概念"></a>AOP的相关概念</h3><table>
<thead>
<tr>
<th align="center">关键词</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Joinpoint连接点</td>
<td align="center">表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等</td>
</tr>
<tr>
<td align="center">Pointcut切入点</td>
<td align="center">选择一组相关连接点的模式，即可以认为连接点的集合，即符合某种条件的切入点的集合</td>
</tr>
<tr>
<td align="center">Advice通知</td>
<td align="center">在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice）。</td>
</tr>
<tr>
<td align="center">Introduction引入</td>
<td align="center">也称为内部类型声明，为已有的类添加额外新的字段或方法。</td>
</tr>
<tr>
<td align="center">Aspect切面</td>
<td align="center">横切关注点的模块化，比如日志组件。可以认为是通知、引入和切入点的组合。</td>
</tr>
<tr>
<td align="center">AOP Proxy</td>
<td align="center">AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</td>
</tr>
<tr>
<td align="center">Weaving织入</td>
<td align="center">织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。</td>
</tr>
</tbody></table>
<h3 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h3><ul>
<li><p>@Aspect：表示一个类是一个切面，一个切面包含了通知、切入点等。</p>
</li>
<li><p>@Poincut：表示切入的点，即程序中通用的逻辑业务，这里是请求的路径</p>
</li>
<li><p>@Before：表示在方法开始执行前执行</p>
</li>
<li><p>@After：表示在方法执行后执行</p>
</li>
<li><p>@AfterReturning： 表示在方法返回后执行</p>
</li>
<li><p>@AfterThrowing： 表示在抛出异常时执行</p>
</li>
<li><p>@Around：在方法执行前和执行后都会执行</p>
</li>
</ul>
<h3 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h3><ul>
<li>简单的使用</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformanceAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"repositoryOps()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">repoLogPerformance</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        String name = <span class="string">"-"</span>;</span><br><span class="line">        String result = <span class="string">"Y"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            name = pjp.getSignature().toShortString();</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            result = <span class="string">"N"</span>;</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;;&#123;&#125;;&#123;&#125;ms"</span>, name, result, endTime - startTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"serviceOps()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceLogPerformance</span><span class="params">(JoinPoint jp)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">"================================================"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.muchlab.chapter82.repository.CoffeeRepository.findOne(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repositoryOps</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.muchlab.chapter82.service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceOps</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//execution 表达式的主体</span></span><br><span class="line"><span class="comment">//第一个* 代表任意的返回值</span></span><br><span class="line"><span class="comment">//com.aop所横切的包名</span></span><br><span class="line"><span class="comment">//第二个* 表示类名，代表所有类</span></span><br><span class="line"><span class="comment">//.*(..) 表示任何方法,括号代表参数 .. 表示任意参数</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>不同的切入点</li>
</ul>
<table>
<thead>
<tr>
<th align="center">切入对象</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">匹配注解 @target</td>
<td align="center">限制连接点匹配特定的执行对象，这些对象对应的类要有具体指定类型的注解</td>
</tr>
<tr>
<td align="center">匹配注解 @args</td>
<td align="center">限制连接点匹配参数为指定注解类型的执行方法</td>
</tr>
<tr>
<td align="center">匹配注解 @within</td>
<td align="center">限制连接点匹配指定注解所标注的类型</td>
</tr>
<tr>
<td align="center">匹配注解 @annotation</td>
<td align="center">限制连接点匹配方法上的注解</td>
</tr>
<tr>
<td align="center">匹配包或类型 within</td>
<td align="center">限制连接点匹配指定的表或类</td>
</tr>
<tr>
<td align="center">匹配对象 this</td>
<td align="center">限制连接点匹配AOP代理的bean引用为指定类型的类</td>
</tr>
<tr>
<td align="center">匹配对象 bean</td>
<td align="center">限制连接点匹配一个指定的bean，需要指出bean的名字</td>
</tr>
<tr>
<td align="center">匹配对象 target</td>
<td align="center">限制连接点匹配目标对象为指定类型的类</td>
</tr>
<tr>
<td align="center">匹配参数 args</td>
<td align="center">限制连接点匹配参数为指定类型的执行方法</td>
</tr>
<tr>
<td align="center">匹配方法 execution()</td>
<td align="center">匹配连接点的执行方法</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——MyBatis的配置</title>
    <url>/2020/07/10/SpringBoot%E2%80%94%E2%80%94MyBatis%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">#mapperXml文件的路径</span><br><span class="line">mybatis.mapper-locations&#x3D;classpath*:mapper&#x2F;**&#x2F;*.xml</span><br><span class="line">#mapperXml文件对应的xxMapper.java的包名</span><br><span class="line">mybatis.type-aliases-package&#x3D;类型别名的包名</span><br><span class="line">#指定Handler的包名</span><br><span class="line">mybatis.type-handlers-package&#x3D;TypeHandler扫描包名</span><br><span class="line">#</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case&#x3D;true</span><br></pre></td></tr></table></figure></div>

<h3 id="Mapper的定义与扫描"><a href="#Mapper的定义与扫描" class="headerlink" title="Mapper的定义与扫描"></a>Mapper的定义与扫描</h3><ul>
<li>@MapperScan配置扫描位置</li>
<li>@Mapper定义接口</li>
<li>映射的定义——XML与注解</li>
</ul>
<h3 id="使用TypeHandler来解决数据库类型与实体类型不匹配"><a href="#使用TypeHandler来解决数据库类型与实体类型不匹配" class="headerlink" title="使用TypeHandler来解决数据库类型与实体类型不匹配"></a>使用TypeHandler来解决数据库类型与实体类型不匹配</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">Money</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="keyword">int</span> i, Money money, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//插入数据时，把Money类型转换成Long，精确到分</span></span><br><span class="line">        preparedStatement.setLong(i, money.getAmountMinorLong());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseMoney(resultSet.getLong(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Money <span class="title">parseMoney</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Money.of(CurrencyUnit.of(<span class="string">"CNY"</span>), value/<span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//获取数据时，把Long转换成Money</span></span><br><span class="line">        <span class="keyword">return</span> parseMoney(resultSet.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parseMoney(callableStatement.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>需要在配置文件中添加<code>mybatis.type-handlers-package=TypeHandler的包名</code></p>
<h3 id="Mapper-Result"><a href="#Mapper-Result" class="headerlink" title="Mapper/Result"></a>Mapper/Result</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标识这是一个Mapper组件</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into t_coffee(name, price, create_time, update_time)"</span> +</span><br><span class="line">            <span class="string">"values(#&#123;name&#125;, #&#123;price&#125;, now(), now())"</span>)</span><br><span class="line">    <span class="comment">//这里的Options的useGeneratedKeys设置为true表示采用主键自增的策略</span></span><br><span class="line">    <span class="comment">//keyProperty表示将数据库的主键id值赋给传入的参数</span></span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyProperty = <span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">save</span><span class="params">(Coffee coffee)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from t_coffee where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="comment">//使用@Results注解来映射查询结果集到实体类属性</span></span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(id = <span class="keyword">true</span>, column = <span class="string">"id"</span>, property = <span class="string">"id"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(column = <span class="string">"create_time"</span>, property = <span class="string">"createTime"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">Coffee <span class="title">findById</span><span class="params">(@Param(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(integer id)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"myClass"</span>, javaType=MyClass<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">      <span class="title">one</span></span>=<span class="meta">@One</span>(select=<span class="string">"com.example.demo.mapper.MyClassMapper.selectById"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndClassMsg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="meta">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"gradeList"</span>, javaType=List<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">many</span></span>=<span class="meta">@Many</span>(select=<span class="string">"com.example.demo.mapper.GradeMapper.selectByStudentId"</span>))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndGrade</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>传递多个参数进行One和Many的加载。首先我们给这张表增加age（年龄）和gender（性别）两个参数。当我们需要根据age和gender查询学生的午餐，这时需要改写column属性的格式。等号左侧的age和gender对应java接口的参数，右侧的对应数据库字段名。即将查到的my_student表中age和gender字段的值，分别赋给getLunchByAgeAndGender方法中的age和gender参数，去查询对应的name（午餐名）。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select</span>(<span class="string">"select id, name, age, gender from my_student"</span>)</span><br><span class="line"><span class="meta">@Results</span>(&#123;</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=<span class="keyword">true</span>),</span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"class_id"</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line">    <span class="comment">//调用getLunchByAgeAndGender并把查询出的age和gender传进去，把查询的字符串加载到lunch上</span></span><br><span class="line">    <span class="meta">@Result</span>(column=<span class="string">"&#123;age=age,gender=gender&#125;"</span>, property=<span class="string">"lunch"</span>,  one=<span class="meta">@One</span>(select=<span class="string">"com.example.demo.mapper.StudentMapper.getLunchByAgeAndGender"</span>)),</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectAllAndLunch</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Select</span>(<span class="string">"select name from lunch where student_age = #&#123;age&#125; and student_gender = #&#123;gender&#125;"</span>)</span><br><span class="line"><span class="function">String <span class="title">getLunchByAgeAndGender</span><span class="params">(@Param(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age, @<span class="title">Param</span><span class="params">(<span class="string">"gender"</span>)</span> <span class="keyword">int</span> gender)</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置MyBatisGenerator"><a href="#配置MyBatisGenerator" class="headerlink" title="配置MyBatisGenerator"></a>配置MyBatisGenerator</h3>]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-SpringBoot -MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring各种上下文的关系详解</title>
    <url>/2020/07/16/Spring%E5%90%84%E7%A7%8D%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Spring各种上下文的关系详解"><a href="#Spring各种上下文的关系详解" class="headerlink" title="Spring各种上下文的关系详解"></a>Spring各种上下文的关系详解</h2><p>Spring的启动过程：</p>
<p>   首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；</p>
<p>   其次，在web.xml中会提供有contextLoaderListener。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；</p>
<p>   再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例，这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文，用以持有spring mvc相关的bean。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文。有了这个parent上下文之后，再初始化自己持有的上下文。这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等。这个servlet自己持有的上下文默认实现类也是xmlWebApplicationContext。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换，具体可自行查看源码)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文(第2步中初始化的上下文)定义的那些bean。</p>
<p><img src="https://images2018.cnblogs.com/blog/1034836/201712/1034836-20171226001504322-505751152.png" alt="img"></p>
<p>总结：</p>
<p>ServletContext:  tomcat启动会创建一个ServletContext，作为全局上下文以及spring容器的宿主环境，可以理解为web容器（Servlet容器）<br>WebApplicationContext：即初始化根上下文（即IOC容器）<br>DispatcherServlet：WebApplicationContext设置为当前DispatcherServlet的父上下文。并且也把DispatcherServlet上下文存在ServletContext中<br>通过init方法创建的dispatcherServlet上下文可以访问通过ServletContextListener中创建的WebApplicationContext上下文中的bean，反之则不行。因为WebApplicationContext是dispatcherServlet上下文的父容器。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5.x学习笔记9——注解编程</title>
    <url>/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Spring5-x学习笔记9——注解编程"><a href="#Spring5-x学习笔记9——注解编程" class="headerlink" title="Spring5.x学习笔记9——注解编程"></a>Spring5.x学习笔记9——注解编程</h2><hr>
<h4 id="第一章、注解基础概念"><a href="#第一章、注解基础概念" class="headerlink" title="第一章、注解基础概念"></a>第一章、注解基础概念</h4><h5 id="1-什么是注解编程"><a href="#1-什么是注解编程" class="headerlink" title="1. 什么是注解编程"></a>1. 什么是注解编程</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">指的是在类或者方法上加入特定的注解（<span class="meta">@XXX</span>),完成特定功能的开发。</span><br><span class="line">  </span><br><span class="line">	<span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXX</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="2-为什么要讲解注解编程"><a href="#2-为什么要讲解注解编程" class="headerlink" title="2. 为什么要讲解注解编程"></a>2. 为什么要讲解注解编程</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>注解开发方便</span><br><span class="line"><span class="code">     代码简洁 开发速度大大提高</span></span><br><span class="line"><span class="bullet">2. </span>Spring开发潮流</span><br><span class="line"><span class="code">     Spring2.x引入注解  Spring3.x完善注解 SpringBoot普及 推广注解编程</span></span><br></pre></td></tr></table></figure></div>

<h5 id="3-注解的作用"><a href="#3-注解的作用" class="headerlink" title="3. 注解的作用"></a>3. 注解的作用</h5><ul>
<li><p>替换XML这种配置形式，简化配置</p>
<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200527164703807.png" alt="image-20200527164703807"></p>
</li>
<li><p>替换接口，实现调用双方的契约性 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">通过注解的方式，在功能调用者和功能提供者之间达成约定，进而进行功能的调用。因为注解应用更为方便灵活，所以在现在的开发中，更推荐通过注解的形式，完成</span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200527171704953.png" alt="image-20200527171704953"></p>
</li>
</ul>
<h5 id="4-Spring注解的发展历程"><a href="#4-Spring注解的发展历程" class="headerlink" title="4. Spring注解的发展历程"></a>4. Spring注解的发展历程</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>Spring2.x开始支持注解编程 @Component @Service @Scope..</span><br><span class="line"><span class="code">     目的：提供的这些注解只是为了在某些情况下简化XML的配置,作为XML开发的有益补充。</span></span><br><span class="line"><span class="bullet">2. </span>Spring3.x @Configuration @Bean..</span><br><span class="line"><span class="code">     目的：彻底替换XML，基于纯注解编程</span></span><br><span class="line"><span class="bullet">3. </span>Spring4.x SpringBoot </span><br><span class="line"><span class="code">     提倡使用注解常见开发</span></span><br></pre></td></tr></table></figure></div>

<h5 id="5-Spring注解开发的一个问题"><a href="#5-Spring注解开发的一个问题" class="headerlink" title="5. Spring注解开发的一个问题"></a>5. Spring注解开发的一个问题</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">Spring基于注解进行配置后，还能否解耦合呢？</span><br><span class="line"></span><br><span class="line">在Spring框架应用注解时，如果对注解配置的内容不满意，可以通过Spring配置文件进行覆盖的。</span><br></pre></td></tr></table></figure></div>

<h4 id="第二章、Spring的基础注解（Spring2-x）"><a href="#第二章、Spring的基础注解（Spring2-x）" class="headerlink" title="第二章、Spring的基础注解（Spring2.x）"></a>第二章、Spring的基础注解（Spring2.x）</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">这个阶段的注解，仅仅是简化XML的配置，并不能完全替代XML</span><br></pre></td></tr></table></figure></div>

<h5 id="1-对象创建相关注解"><a href="#1-对象创建相关注解" class="headerlink" title="1. 对象创建相关注解"></a>1. 对象创建相关注解</h5><ul>
<li><p>搭建开发环境</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">作用：让Spring框架在设置包及其子包中扫描对应的注解，使其生效。</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对象创建相关注解</p>
<ul>
<li><p>@Component</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">作用：替换原有spring配置文件中的<span class="xml"><span class="tag">&lt;<span class="name">bean标签</span> </span></span></span><br><span class="line"><span class="xml">注意：</span></span><br><span class="line"><span class="xml">    id属性 component注解 提供了默认的设置方式  首单词首字母小写</span></span><br><span class="line"><span class="xml">    class属性 通过反射获得class内容</span></span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200528112232356.png" alt="image-20200528112232356"></p>
</li>
<li><p>@Component 细节</p>
<ul>
<li><p>如何显示指定工厂创建对象的id值</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"u"</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Spring配置文件覆盖注解配置内容</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">applicationContext.xml</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"u"</span> <span class="attr">class</span>=<span class="string">"com.baizhiedu.bean.User"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">id值 class的值 要和 注解中的设置保持一值</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p>@Component的衍生注解</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Repository  ---&gt;  XXXDAO</span><br><span class="line">  @Repository</span><br><span class="line">  public class UserDAO&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">@Service</span><br><span class="line">  @Service</span><br><span class="line">  public class UserService&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">@Controller </span><br><span class="line">  @Controller </span><br><span class="line">  public class RegAction&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">注意：本质上这些衍生注解就是@Component </span><br><span class="line"><span class="code">     作用 &lt;bean  </span></span><br><span class="line"><span class="code">     细节 @Service("s")</span></span><br><span class="line"></span><br><span class="line">目的：更加准确的表达一个类型的作用</span><br><span class="line"></span><br><span class="line">注意：Spring整合Mybatis开发过程中 不使用@Repository @Component</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p>@Scope注解</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">作用：控制简单对象创建次数</span><br><span class="line">注意：不添加@Scope Spring提供默认值 singleton</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">scope</span>=<span class="string">"singleton|prototype"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>@Lazy注解</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">作用：延迟创建单实例对象</span><br><span class="line">注意：一旦使用了@Lazy注解后，Spring会在使用这个对象时候，进行这个对象的创建</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">lazy</span>=<span class="string">"false"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>生命周期方法相关注解</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>初始化相关方法 @PostConstruct</span><br><span class="line">   InitializingBean</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">init-method</span>=<span class="string">""</span>/&gt;</span></span></span><br><span class="line"><span class="bullet">2. </span>销毁方法 @PreDestroy</span><br><span class="line">   DisposableBean</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">destory-method</span>=<span class="string">""</span>/&gt;</span></span></span><br><span class="line">注意：1. 上述的2个注解并不是Spring提供的，JSR(JavaEE规范)520</span><br><span class="line"><span class="bullet">     2. </span>再一次的验证，通过注解实现了接口的契约性</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h5 id="2-注入相关注解"><a href="#2-注入相关注解" class="headerlink" title="2. 注入相关注解"></a>2. 注入相关注解</h5><ul>
<li><p>用户自定义类型 @Autowired</p>
<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200601114751016.png" alt="image-20200601114751016"></p>
</li>
</ul>
  <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Autowired细节</span><br><span class="line"><span class="bullet">1. </span>Autowired注解基于类型进行注入 [推荐]</span><br><span class="line">   基于类型的注入：注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>Autowired Qualifier 基于名字进行注入 [了解]</span><br><span class="line">   基于名字的注入：注入对象的id值，必须与Qualifier注解中设置的名字相同</span><br><span class="line"></span><br><span class="line"><span class="bullet">3. </span>Autowired注解放置位置 </span><br><span class="line"><span class="code">    a) 放置在对应成员变量的set方法上 </span></span><br><span class="line"><span class="code">    b) 直接把这个注解放置在成员变量之上，Spring通过反射直接对成员变量进行注入（赋值）[推荐]</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>JavaEE规范中类似功能的注解</span><br><span class="line"><span class="code">    JSR250 @Resouce(name="userDAOImpl") 基于名字进行注入</span></span><br><span class="line"><span class="code">           @Autowired()</span></span><br><span class="line"><span class="code">           @Qualifier("userDAOImpl")</span></span><br><span class="line"><span class="code">           注意：如果在应用Resource注解时，名字没有配对成功，那么他会继续按照类型进行注入。</span></span><br><span class="line"><span class="code">    JSR330 @Inject 作用 @Autowired完全一致 基于类型进行注入 ---》 EJB3.0</span></span><br><span class="line"><span class="code">          &lt;dependency&gt;</span></span><br><span class="line"><span class="code">            &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span></span><br><span class="line"><span class="code">            &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span></span><br><span class="line"><span class="code">            &lt;version&gt;1&lt;/version&gt;</span></span><br><span class="line"><span class="code">          &lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>JDK类型 </p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Value注解完成</span><br><span class="line"><span class="bullet">1. </span>设置xxx.properties </span><br><span class="line">   id = 10</span><br><span class="line">   name = suns</span><br><span class="line"><span class="bullet">2. </span>Spring的工厂读取这个配置文件 </span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">""</span>/&gt;</span></span></span><br><span class="line"><span class="bullet">3. </span>代码 </span><br><span class="line">   属性 @Value("$&#123;key&#125;")</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>@PropertySource</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>作用：用于替换Spring配置文件中的<span class="xml"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">""</span>/&gt;</span></span>标签</span><br><span class="line"><span class="bullet">2. </span>开发步骤 </span><br><span class="line"><span class="bullet">    1. </span>设置xxx.properties </span><br><span class="line"><span class="code">       id = 10</span></span><br><span class="line"><span class="code">       name = suns</span></span><br><span class="line"><span class="bullet">    2. </span>应用@PropertySource</span><br><span class="line"><span class="bullet">    3. </span>代码</span><br><span class="line"><span class="code">       属性 @Value()</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>@Value注解使用细节</p>
<ul>
<li><p>@Value注解不能应用在静态成员变量上</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">如果应用，赋值（注入）失败</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>@Value注解+Properties这种方式，不能注入集合类型</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">Spring提供新的配置形式 YAML YML (SpringBoot)</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-注解扫描详解"><a href="#3-注解扫描详解" class="headerlink" title="3. 注解扫描详解"></a>3. 注解扫描详解</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span>/&gt;</span></span></span><br><span class="line">当前包 及其 子包</span><br></pre></td></tr></table></figure></div>

<h6 id="1-排除方式"><a href="#1-排除方式" class="headerlink" title="1. 排除方式"></a>1. 排除方式</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span>&gt;</span></span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span></span><br><span class="line">   type:assignable:排除特定的类型 不进行扫描</span><br><span class="line"><span class="code">        annotation:排除特定的注解 不进行扫描</span></span><br><span class="line"><span class="code">        aspectj:切入点表达式</span></span><br><span class="line"><span class="code">                包切入点： com.baizhiedu.bean..*</span></span><br><span class="line"><span class="code">                类切入点： *..User</span></span><br><span class="line"><span class="code">        regex:正则表达式 </span></span><br><span class="line"><span class="code">        custom：自定义排除策略框架底层开发</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">排除策略可以叠加使用 </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"assignable"</span> <span class="attr">expression</span>=<span class="string">"com.baizhiedu.bean.User"</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"aspectj"</span> <span class="attr">expression</span>=<span class="string">"com.baizhiedu.injection..*"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h6 id="2-包含方式"><a href="#2-包含方式" class="headerlink" title="2. 包含方式"></a>2. 包含方式</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">1. use-default-filters="false"</span><br><span class="line">   作用：让Spring默认的注解扫描方式 失效。</span><br><span class="line">2. <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">   作用：指定扫描那些注解 </span><br><span class="line">   type:assignable:排除特定的类型 不进行扫描</span><br><span class="line">        annotation:排除特定的注解 不进行扫描</span><br><span class="line">        aspectj:切入点表达式</span><br><span class="line">                包切入点： com.baizhiedu.bean..*</span><br><span class="line">                类切入点： *..User</span><br><span class="line">        regex:正则表达式 </span><br><span class="line">        custom：自定义排除策略框架底层开发</span><br><span class="line"></span><br><span class="line">包含的方式支持叠加</span><br><span class="line"> <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Repository"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Service"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h5 id="4-对于注解开发的思考"><a href="#4-对于注解开发的思考" class="headerlink" title="4. 对于注解开发的思考"></a>4. 对于注解开发的思考</h5><ul>
<li><p>配置互通</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">Spring注解配置 配置文件的配置 互通</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class UserDAOImpl&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserServiceImpl&#123;</span><br><span class="line">   private UserDAO userDAO;</span><br><span class="line">   set get</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.baizhiedu.UserServiceImpl"</span>&gt;</span></span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span> <span class="attr">ref</span>=<span class="string">"userDAOImpl"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>什么情况下使用注解 什么情况下使用配置文件</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Component 替换 <span class="xml"><span class="tag">&lt;<span class="name">bean</span> </span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">基础注解（@Component @Autowired @Value) 程序员开发类型的配置</span></span><br><span class="line"></span><br><span class="line"><span class="xml">1. 在程序员开发的类型上 可以加入对应注解 进行对象的创建 </span></span><br><span class="line"><span class="xml">   User  UserService  UserDAO  UserAction </span></span><br><span class="line"></span><br><span class="line"><span class="xml">2. 应用其他非程序员开发的类型时，还是需要使用<span class="tag">&lt;<span class="name">bean</span> 进行配置的</span></span></span><br><span class="line"><span class="xml">   SqlSessionFactoryBean  MapperScannerConfigure</span></span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h5 id="5-SSM整合开发（半注解开发）"><a href="#5-SSM整合开发（半注解开发）" class="headerlink" title="5.  SSM整合开发（半注解开发）"></a>5.  SSM整合开发（半注解开发）</h5><ul>
<li><p>搭建开发环境</p>
<ul>
<li>引入相关jar 【SSM POM】</li>
<li>引入相关配置文件<ul>
<li>applicationContext.xml</li>
<li>struts.xml</li>
<li>log4.properties</li>
<li>XXXMapper.xml</li>
</ul>
</li>
<li>初始化配置<ul>
<li>Web.xml Spring  (ContextLoaderListener)</li>
<li>Web.xml Struts Filter </li>
</ul>
</li>
</ul>
</li>
<li><p>编码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">""</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>DAO (Spring+Mybatis)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>配置文件的配置</span><br><span class="line"><span class="bullet">   1. </span>DataSource</span><br><span class="line"><span class="bullet">   2. </span>SqlSessionFactory ----&gt; SqlSessionFactoryBean</span><br><span class="line"><span class="bullet">      1. </span>dataSource</span><br><span class="line"><span class="bullet">      2. </span>typeAliasesPackage</span><br><span class="line"><span class="bullet">      3. </span>mapperLocations </span><br><span class="line"><span class="bullet">   3. </span>MapperScannerConfigur ---&gt; DAO接口实现类</span><br><span class="line"><span class="bullet">2. </span>编码</span><br><span class="line"><span class="bullet">   1. </span>entity </span><br><span class="line"><span class="bullet">   2. </span>table</span><br><span class="line"><span class="bullet">   3. </span>DAO接口</span><br><span class="line"><span class="bullet">   4. </span>实现Mapper文件</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Service</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>原始对象 ---》 注入DAO</span><br><span class="line">   @Service ---&gt; @Autowired</span><br><span class="line"></span><br><span class="line"><span class="bullet">2. </span>额外功能 ---》 DataSourceTransactionManager ---&gt; dataSource</span><br><span class="line"><span class="bullet">3. </span>切入点 + 事务属性</span><br><span class="line">   @Transactional(propagation,readOnly...)</span><br><span class="line"><span class="bullet">4. </span>组装切面</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">tx:annotation-driven</span></span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Controller (Spring+Struts2)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>@Controller</span><br><span class="line">   @Scope("prototype")</span><br><span class="line">   public class RegAction implements Action&#123;</span><br><span class="line"><span class="code">      @Autowired</span></span><br><span class="line"><span class="code">      private UserService userServiceImpl;</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line"><span class="bullet">2. </span>struts.xml</span><br><span class="line"><span class="code">    &lt;action class="spring配置文件中action对应的id值"/&gt;</span></span><br></pre></td></tr></table></figure></div>

</li>
</ul>
</li>
</ul>
<h4 id="第三章、Spring的高级注解（Spring3-x-及以上"><a href="#第三章、Spring的高级注解（Spring3-x-及以上" class="headerlink" title="第三章、Spring的高级注解（Spring3.x 及以上)"></a>第三章、Spring的高级注解（Spring3.x 及以上)</h4><h5 id="1-配置Bean"><a href="#1-配置Bean" class="headerlink" title="1. 配置Bean"></a>1. 配置Bean</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">Spring在<span class="number">3</span>.x提供的新的注解，用于替换XML配置文件。</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>配置Bean在应用的过程中 替换了XML具体什么内容呢？</p>
<p>![image-20200703100033265](../../../Users/sunshuai/Spring课程/线上课程笔记/百知教育 — Spring系列课程 — 注解编程.assets/image-20200703100033265.png)</p>
</li>
<li><p>AnnotationConfigApplicationContext</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>创建工厂代码</span><br><span class="line">   ApplicationContext ctx = new AnnotationConfigApplicationContext();</span><br><span class="line"><span class="bullet">2. </span>指定配置文件 </span><br><span class="line"><span class="bullet">   1. </span>指定配置bean的Class</span><br><span class="line"><span class="code">       ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span></span><br><span class="line"><span class="bullet">   2. </span>指定配置bean所在的路径 </span><br><span class="line"><span class="code">       ApplicationContext ctx = new AnnotationConfigApplicationContext("com.baizhiedu");</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<ul>
<li><p>配置Bean开发的细节分析</p>
<ul>
<li><p>基于注解开发使用日志</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">不能集成Log4j</span><br><span class="line">集成logback</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>引入相关jar</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.logback-extensions<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-ext-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>引入logback配置文件 (logback.xml)</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p>@Configuration注解的本质</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">本质：也是@Component注解的衍生注解</span><br><span class="line"></span><br><span class="line">可以应用<span class="xml"><span class="tag">&lt;<span class="name">context:component-scan进行扫描</span></span></span></span><br></pre></td></tr></table></figure></div>

</li>
</ul>
</li>
</ul>
<h5 id="2-Bean注解"><a href="#2-Bean注解" class="headerlink" title="2. @Bean注解"></a>2. @Bean注解</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Bean注解在配置bean中进行使用，等同于XML配置文件中的<span class="xml"><span class="tag">&lt;<span class="name">bean标签</span></span></span></span><br></pre></td></tr></table></figure></div>

<h6 id="1-Bean注解的基本使用"><a href="#1-Bean注解的基本使用" class="headerlink" title="1. @Bean注解的基本使用"></a>1. @Bean注解的基本使用</h6><ul>
<li><p>对象的创建</p>
<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200703150632630.png" alt="image-20200703150632630"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>简单对象</span><br><span class="line">   直接能够通过new方式创建的对象 </span><br><span class="line">   User  UserService   UserDAO </span><br><span class="line"><span class="bullet">2. </span>复杂对象</span><br><span class="line">   不能通过new的方式直接创建的对象</span><br><span class="line">   Connection SqlSessionFactory</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>@Bean注解创建复杂对象的注意事项</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">遗留系统整合 </span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">conn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Connection conn = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ConnectionFactoryBean factoryBean = <span class="keyword">new</span> ConnectionFactoryBean();</span><br><span class="line">    conn = factoryBean.getObject();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p>自定义id值</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Bean("id")</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>控制对象创建次数</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton|prototype"</span>) 默认值 singleton</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h6 id="2-Bean注解的注入"><a href="#2-Bean注解的注入" class="headerlink" title="2. @Bean注解的注入"></a>2. @Bean注解的注入</h6><ul>
<li><p>用户自定义类型</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDAO <span class="title">userDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> UserDAOImpl();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">(UserDAO userDAO)</span> </span>&#123;</span><br><span class="line">  UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">  userService.setUserDAO(userDAO);</span><br><span class="line">  <span class="keyword">return</span> userService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化写法</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">  userService.setUserDAO(userDAO());</span><br><span class="line">  <span class="keyword">return</span> userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>JDK类型的注入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Customer <span class="title">customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">  customer.setId(<span class="number">1</span>);</span><br><span class="line">  customer.setName(<span class="string">"xiaohei"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> customer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>JDK类型注入的细节分析</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">如果直接在代码中进行set方法的调用，会存在耦合的问题 </span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/init.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">        customer.setId(id);</span><br><span class="line">        customer.setName(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> customer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
</li>
</ul>
<h5 id="3-ComponentScan注解"><a href="#3-ComponentScan注解" class="headerlink" title="3. @ComponentScan注解"></a>3. @ComponentScan注解</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@ComponentScan注解在配置bean中进行使用，等同于XML配置文件中的<span class="xml"><span class="tag">&lt;<span class="name">context:component-scan</span>&gt;</span></span>标签</span><br><span class="line"></span><br><span class="line">目的：进行相关注解的扫描 （@Component @Value ...@Autowired)</span><br></pre></td></tr></table></figure></div>

<h6 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.baizhiedu.scan"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">""</span>/&gt;</span><br></pre></td></tr></table></figure></div>

<h6 id="2-排除、包含的使用"><a href="#2-排除、包含的使用" class="headerlink" title="2. 排除、包含的使用"></a>2. 排除、包含的使用</h6><ul>
<li><p>排除</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"assignable"</span> <span class="attr">expression</span>=<span class="string">"com.baizhiedu.bean.User"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages = "com.baizhiedu.scan",</span><br><span class="line">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION,value=&#123;Service.class&#125;),</span><br><span class="line">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ,pattern = "*..User1")&#125;)</span><br><span class="line"></span><br><span class="line">type = FilterType.ANNOTATION          value</span><br><span class="line">                 .ASSIGNABLE_TYPE     value</span><br><span class="line">                 .ASPECTJ             pattern   </span><br><span class="line">                 .REGEX               pattern</span><br><span class="line">                 .CUSTOM              value</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>包含</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.baizhiedu"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">expression</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">@ComponentScan(basePackages = "com.baizhiedu.scan",</span><br><span class="line">               useDefaultFilters = false,</span><br><span class="line">               includeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION,value=&#123;Service.class&#125;)&#125;)</span><br><span class="line"></span><br><span class="line">type = FilterType.ANNOTATION          value</span><br><span class="line">                 .ASSIGNABLE_TYPE     value</span><br><span class="line">                 .ASPECTJ             pattern   </span><br><span class="line">                 .REGEX               pattern</span><br><span class="line">                 .CUSTOM              value</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h5 id="4-Spring工厂创建对象的多种配置方式"><a href="#4-Spring工厂创建对象的多种配置方式" class="headerlink" title="4. Spring工厂创建对象的多种配置方式"></a>4. Spring工厂创建对象的多种配置方式</h5><h6 id="1-多种配置方式的应用场景"><a href="#1-多种配置方式的应用场景" class="headerlink" title="1. 多种配置方式的应用场景"></a>1. 多种配置方式的应用场景</h6><p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200706174301418.png" alt="image-20200706174301418"></p>
<h6 id="2-配置优先级"><a href="#2-配置优先级" class="headerlink" title="2. 配置优先级"></a>2. 配置优先级</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">@Component及其衍生注解 <span class="xml"><span class="tag">&lt; @<span class="attr">Bean</span> &lt; 配置文件<span class="attr">bean</span>标签</span></span></span><br><span class="line"><span class="xml">优先级高的配置 覆盖优先级低配置 </span></span><br><span class="line"></span><br><span class="line"><span class="xml">@Component</span></span><br><span class="line"><span class="xml">public class User&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">@Bean</span></span><br><span class="line"><span class="xml">public User user()&#123;</span></span><br><span class="line"><span class="xml">  return new User();</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"xxx.User"</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">配置覆盖：id值 保持一致</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>解决基于注解进行配置的耦合问题</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@ImportResource("applicationContext.xml")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDAO <span class="title">userDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDAOImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig5</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applicationContext.xml</span><br><span class="line">&lt;bean id=<span class="string">"userDAO"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.baizhiedu.injection.UserDAOImplNew"</span>/&gt;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h5 id="5-整合多个配置信息"><a href="#5-整合多个配置信息" class="headerlink" title="5. 整合多个配置信息"></a>5. 整合多个配置信息</h5><ul>
<li>为什么会有多个配置信息</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">拆分多个配置bean的开发，是一种模块化开发的形式，也体现了面向对象各司其职的设计思想</span><br></pre></td></tr></table></figure></div>

<ul>
<li>多配置信息整合的方式<ul>
<li>多个配置Bean的整合</li>
<li>配置Bean与@Component相关注解的整合</li>
<li>配置Bean与SpringXML配置文件的整合</li>
</ul>
</li>
<li>整合多种配置需要关注那些要点<ul>
<li>如何使多配置的信息 汇总成一个整体</li>
<li>如何实现跨配置的注入</li>
</ul>
</li>
</ul>
<h6 id="1-多个配置Bean的整合"><a href="#1-多个配置Bean的整合" class="headerlink" title="1. 多个配置Bean的整合"></a>1. 多个配置Bean的整合</h6><ul>
<li><p>多配置的信息汇总</p>
<ul>
<li><p>base-package进行多个配置Bean的整合</p>
<p>![image-20200707170421669](../../../Users/sunshuai/Spring课程/线上课程笔记/百知教育 — Spring系列课程 — 注解编程.assets/image-20200707170421669.png)</p>
</li>
<li><p>@Import</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>可以创建对象</span><br><span class="line"><span class="bullet">2. </span>多配置bean的整合</span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200707170745814.png" alt="image-20200707170745814"></p>
</li>
<li><p>在工厂创建时，指定多个配置Bean的Class对象 【了解】</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig1<span class="class">.<span class="keyword">class</span>,<span class="title">AppConfig2</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p>跨配置进行注入</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">在应用配置Bean的过程中，不管使用哪种方式进行配置信息的汇总，其操作方式都是通过成员变量加入<span class="meta">@Autowired</span>注解完成。</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(AppConfig2<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AppConfig1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDAO(userDAO);</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDAO <span class="title">userDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserDAOImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h6 id="2-配置Bean与-Component相关注解的整合"><a href="#2-配置Bean与-Component相关注解的整合" class="headerlink" title="2. 配置Bean与@Component相关注解的整合"></a>2. 配置Bean与@Component相关注解的整合</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="meta">@Repository</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig3</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDAO(userDAO);</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig3<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<h6 id="3-配置Bean与配置文件整合"><a href="#3-配置Bean与配置文件整合" class="headerlink" title="3. 配置Bean与配置文件整合"></a>3. 配置Bean与配置文件整合</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 遗留系统的整合 <span class="number">2</span>. 配置覆盖</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">&lt;bean id=<span class="string">"userDAO"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.baizhiedu.injection.UserDAOImpl"</span>/&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig4</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserServiceImpl userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDAO(userDAO);</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig4<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure></div>

<h5 id="6-配置Bean底层实现原理"><a href="#6-配置Bean底层实现原理" class="headerlink" title="6. 配置Bean底层实现原理"></a>6. 配置Bean底层实现原理</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">Spring在配置Bean中加入了@Configuration注解后，底层就会通过Cglib的代理方式，来进行对象相关的配置、处理</span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/08/28/Spring5-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%E7%BC%96%E7%A8%8B/image-20200709114200371.png" alt="image-20200709114200371"></p>
<h5 id="7-四维一体的开发思想"><a href="#7-四维一体的开发思想" class="headerlink" title="7. 四维一体的开发思想"></a>7. 四维一体的开发思想</h5><h6 id="1-什么是四维一体"><a href="#1-什么是四维一体" class="headerlink" title="1. 什么是四维一体"></a>1. 什么是四维一体</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">Spring开发一个功能的4种形式，虽然开发方式不同，但是最终效果是一样的。</span><br><span class="line"><span class="bullet">1. </span>基于schema</span><br><span class="line"><span class="bullet">2. </span>基于特定功能注解</span><br><span class="line"><span class="bullet">3. </span>基于原始<span class="xml"><span class="tag">&lt;<span class="name">bean</span></span></span></span><br><span class="line"><span class="xml">4. 基于@Bean注解</span></span><br></pre></td></tr></table></figure></div>

<h6 id="2-四维一体的开发案例"><a href="#2-四维一体的开发案例" class="headerlink" title="2. 四维一体的开发案例"></a>2. 四维一体的开发案例</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. &lt;context:property-placehoder</span><br><span class="line"><span class="number">2</span>. <span class="meta">@PropertySource</span>  【推荐】</span><br><span class="line"><span class="number">3</span>. &lt;bean id=<span class="string">""</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"PropertySourcePlaceholderConfigure"</span>/&gt;</span><br><span class="line"><span class="number">4</span>. <span class="meta">@Bean</span>            【推荐】</span><br></pre></td></tr></table></figure></div>

<h5 id="8-纯注解版AOP编程"><a href="#8-纯注解版AOP编程" class="headerlink" title="8. 纯注解版AOP编程"></a>8. 纯注解版AOP编程</h5><h6 id="1-搭建环境"><a href="#1-搭建环境" class="headerlink" title="1. 搭建环境"></a>1. 搭建环境</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>应用配置Bean </span><br><span class="line"><span class="bullet">2. </span>注解扫描</span><br></pre></td></tr></table></figure></div>

<h6 id="2-开发步骤"><a href="#2-开发步骤" class="headerlink" title="2. 开发步骤"></a>2. 开发步骤</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 原始对象</span><br><span class="line">   <span class="meta">@Service</span>(<span class="meta">@Component</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line"><span class="number">2</span>. 创建切面类 （额外功能 切入点 组装切面）</span><br><span class="line">    <span class="meta">@Aspect</span></span><br><span class="line">    <span class="meta">@Component</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Around</span>(<span class="string">"execution(* login(..))"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">arround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"----aspect log ------"</span>);</span><br><span class="line"></span><br><span class="line">            Object ret = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3</span>. Spring的配置文件中</span><br><span class="line">   &lt;aop:aspectj-autoproxy /&gt;</span><br><span class="line">   <span class="meta">@EnableAspectjAutoProxy</span> ---&gt; 配置Bean</span><br></pre></td></tr></table></figure></div>

<h6 id="3-注解AOP细节分析"><a href="#3-注解AOP细节分析" class="headerlink" title="3. 注解AOP细节分析"></a>3. 注解AOP细节分析</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 代理创建方式的切换 JDK Cglib </span><br><span class="line">   &lt;aop:aspectj-autoproxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="keyword">true</span>|<span class="keyword">false</span> /&gt;</span><br><span class="line">   <span class="meta">@EnableAspectjAutoProxy</span>(proxyTargetClass)</span><br><span class="line"><span class="number">2</span>. SpringBoot AOP的开发方式</span><br><span class="line">     <span class="meta">@EnableAspectjAutoProxy</span> 已经设置好了 </span><br><span class="line">     </span><br><span class="line">    <span class="number">1</span>. 原始对象</span><br><span class="line">     <span class="meta">@Service</span>(<span class="meta">@Component</span>)</span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">    <span class="number">2</span>. 创建切面类 （额外功能 切入点 组装切面）</span><br><span class="line">      <span class="meta">@Aspect</span></span><br><span class="line">      <span class="meta">@Component</span></span><br><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Around</span>(<span class="string">"execution(* login(..))"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">arround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">          System.out.println(<span class="string">"----aspect log ------"</span>);</span><br><span class="line"></span><br><span class="line">          Object ret = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    Spring AOP 代理默认实现 JDK  SpringBOOT AOP 代理默认实现 Cglib</span><br></pre></td></tr></table></figure></div>

<h5 id="9-纯注解版Spring-MyBatis整合"><a href="#9-纯注解版Spring-MyBatis整合" class="headerlink" title="9. 纯注解版Spring+MyBatis整合"></a>9. 纯注解版Spring+MyBatis整合</h5><ul>
<li><p>基础配置 （配置Bean）</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">1. 连接池</span><br><span class="line">  <span class="comment">&lt;!--连接池--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/suns?useSSL=false"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   @Bean</span><br><span class="line">   public DataSource dataSource()&#123;</span><br><span class="line">      DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">      dataSource.setDriverClassName("");</span><br><span class="line">      dataSource.setUrl();</span><br><span class="line">      ...</span><br><span class="line">      return dataSource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2. SqlSessionFactoryBean</span><br><span class="line">    <span class="comment">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.baizhiedu.entity"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com.baizhiedu.mapper/*Mapper.xml<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">         SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();</span><br><span class="line">         sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">         sqlSessionFactoryBean.setTypeAliasesPackage("");</span><br><span class="line">         ...</span><br><span class="line">         return sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3. MapperScannerConfigure </span><br><span class="line">   <span class="comment">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"scanner"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactoryBean"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.baizhiedu.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  @MapperScan(basePackages=&#123;"com.baizhiedu.dao"&#125;) ---&gt; 配置bean完成</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>实体</span><br><span class="line"><span class="bullet">2. </span>表</span><br><span class="line"><span class="bullet">3. </span>DAO接口</span><br><span class="line"><span class="bullet">4. </span>Mapper文件</span><br></pre></td></tr></table></figure></div>

<h6 id="1-MapperLocations编码时通配的写法"><a href="#1-MapperLocations编码时通配的写法" class="headerlink" title="1. MapperLocations编码时通配的写法"></a>1. MapperLocations编码时通配的写法</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置Mapper文件的路径</span></span><br><span class="line">sqlSessionFactoryBean.setMapperLocations(Resource..);</span><br><span class="line">Resource resouce = <span class="keyword">new</span> ClassPathResouce(<span class="string">"UserDAOMapper.xml"</span>)</span><br><span class="line">  </span><br><span class="line">sqlSessionFactoryBean.setMapperLocations(<span class="keyword">new</span> ClassPathResource(<span class="string">"UserDAOMapper.xml"</span>));</span><br><span class="line"></span><br><span class="line">&lt;property name=<span class="string">"mapperLocations"</span>&gt;</span><br><span class="line">   &lt;list&gt;</span><br><span class="line">     &lt;value&gt;classpath:com.baizhiedu.mapper<span class="comment">/*Mapper.xml&lt;/value&gt;</span></span><br><span class="line"><span class="comment">   &lt;/list&gt;</span></span><br><span class="line"><span class="comment">&lt;/property&gt;</span></span><br><span class="line"><span class="comment">一组Mapper文件 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();</span></span><br><span class="line"><span class="comment">Resource[] resources = resolver.getResources("com.baizhi.mapper/*Mapper.xml");</span></span><br><span class="line"><span class="comment">sqlSessionFactoryBean.setMapperLocations(resources)</span></span><br></pre></td></tr></table></figure></div>

<h6 id="2-配置Bean数据耦合的问题"><a href="#2-配置Bean数据耦合的问题" class="headerlink" title="2. 配置Bean数据耦合的问题"></a>2. 配置Bean数据耦合的问题</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">mybatis.driverClassName = com.mysql.jdbc.Driver</span><br><span class="line">mybatis.url = jdbc:mysql:<span class="comment">//localhost:3306/suns?useSSL=false</span></span><br><span class="line">mybatis.username = root</span><br><span class="line">mybatis.password = <span class="number">123456</span></span><br><span class="line">mybatis.typeAliasesPackages = com.baizhiedu.mybatis</span><br><span class="line">mybatis.mapperLocations = com.baizhiedu.mapper<span class="comment">/*Mapper.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">@Component</span></span><br><span class="line"><span class="comment">@PropertySource("classpath:mybatis.properties")</span></span><br><span class="line"><span class="comment">public class MybatisProperties &#123;</span></span><br><span class="line"><span class="comment">    @Value("$&#123;mybatis.driverClassName&#125;")</span></span><br><span class="line"><span class="comment">    private String driverClassName;</span></span><br><span class="line"><span class="comment">    @Value("$&#123;mybatis.url&#125;")</span></span><br><span class="line"><span class="comment">    private String url;</span></span><br><span class="line"><span class="comment">    @Value("$&#123;mybatis.username&#125;")</span></span><br><span class="line"><span class="comment">    private String username;</span></span><br><span class="line"><span class="comment">    @Value("$&#123;mybatis.password&#125;")</span></span><br><span class="line"><span class="comment">    private String password;</span></span><br><span class="line"><span class="comment">    @Value("$&#123;mybatis.typeAliasesPackages&#125;")</span></span><br><span class="line"><span class="comment">    private String typeAliasesPackages;</span></span><br><span class="line"><span class="comment">    @Value("$&#123;mybatis.mapperLocations&#125;")</span></span><br><span class="line"><span class="comment">    private String mapperLocations;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public class MyBatisAutoConfiguration &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Autowired</span></span><br><span class="line"><span class="comment">    private MybatisProperties mybatisProperties;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public DataSource dataSource() &#123;</span></span><br><span class="line"><span class="comment">        DruidDataSource dataSource = new DruidDataSource();</span></span><br><span class="line"><span class="comment">        dataSource.setDriverClassName(mybatisProperties.getDriverClassName());</span></span><br><span class="line"><span class="comment">        dataSource.setUrl(mybatisProperties.getUrl());</span></span><br><span class="line"><span class="comment">        dataSource.setUsername(mybatisProperties.getUsername());</span></span><br><span class="line"><span class="comment">        dataSource.setPassword(mybatisProperties.getPassword());</span></span><br><span class="line"><span class="comment">        return dataSource;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Bean</span></span><br><span class="line"><span class="comment">    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource) &#123;</span></span><br><span class="line"><span class="comment">        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();</span></span><br><span class="line"><span class="comment">        sqlSessionFactoryBean.setDataSource(dataSource);</span></span><br><span class="line"><span class="comment">        sqlSessionFactoryBean.setTypeAliasesPackage(mybatisProperties.getTypeAliasesPackages());</span></span><br><span class="line"><span class="comment">        //sqlSessionFactoryBean.setMapperLocations(new ClassPathResource("UserDAOMapper.xml"));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        try &#123;</span></span><br><span class="line"><span class="comment">            ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();</span></span><br><span class="line"><span class="comment">            Resource[] resources = resolver.getResources(mybatisProperties.getMapperLocations());</span></span><br><span class="line"><span class="comment">            sqlSessionFactoryBean.setMapperLocations(resources);</span></span><br><span class="line"><span class="comment">        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">            e.printStackTrace();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        return sqlSessionFactoryBean;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h5 id="10-纯注解版事务编程"><a href="#10-纯注解版事务编程" class="headerlink" title="10. 纯注解版事务编程"></a>10. 纯注解版事务编程</h5><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">1. 原始对象 XXXService</span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"com.baizhiedu.service.UserServiceImpl"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDAO"</span> <span class="attr">ref</span>=<span class="string">"userDAO"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   @Service</span><br><span class="line">   public class UserServiceImpl implements UserService&#123;</span><br><span class="line">         @Autowired</span><br><span class="line">         private UserDAO userDAO;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">2. 额外功能</span><br><span class="line">   <span class="comment">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    @Bean</span><br><span class="line">    public DataSourceTransactionManager dataSourceTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">          DataSourceTransactionManager dstm = new DataSourceTransactionManager();</span><br><span class="line">          dstm.setDataSource(dataSource);</span><br><span class="line">          return dstm </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3. 事务属性</span><br><span class="line">    @Transactional</span><br><span class="line">    @Service</span><br><span class="line">    public class UserServiceImpl implements UserService &#123;</span><br><span class="line">        @Autowired</span><br><span class="line">        private UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">4. 基于Schema的事务配置 </span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>/&gt;</span></span><br><span class="line">   @EnableTransactionManager ---&gt; 配置Bean</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>ApplicationContext ctx = new AnnotationConfigApplicationContext("com.baizhiedu.mybatis");</span><br><span class="line">   SpringBoot 实现思想</span><br><span class="line"><span class="bullet">2. </span>注解版MVC整合，SpringMVC中进行详细讲解</span><br><span class="line">   SpringMyBatis ---&gt;DAO  事务基于注解 --&gt; Service   Controller </span><br><span class="line">   org.springframework.web.context.ContextLoaderListener ---&gt; XML工厂 无法提供 new AnnotationConfigApplicationContext</span><br></pre></td></tr></table></figure></div>

<h5 id="11-Spring框架中YML的使用"><a href="#11-Spring框架中YML的使用" class="headerlink" title="11. Spring框架中YML的使用"></a>11. Spring框架中YML的使用</h5><h6 id="1-什么是YML"><a href="#1-什么是YML" class="headerlink" title="1. 什么是YML"></a>1. 什么是YML</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line">YML(YAML)是一种新形式的配置文件，比XML更简单，比Properties更强大。</span><br><span class="line"></span><br><span class="line">YAML is a nice human-readable format for configuration, and it has some useful hierarchical properties. It's more or less a superset of JSON, so it has a lot of similar features.</span><br></pre></td></tr></table></figure></div>

<h6 id="2-Properties进行配置问题"><a href="#2-Properties进行配置问题" class="headerlink" title="2. Properties进行配置问题"></a>2. Properties进行配置问题</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>Properties表达过于繁琐,无法表达数据的内在联系. </span><br><span class="line"><span class="bullet">2. </span>Properties无法表达对象 集合类型</span><br></pre></td></tr></table></figure></div>

<h6 id="3-YML语法简介"><a href="#3-YML语法简介" class="headerlink" title="3. YML语法简介"></a>3. YML语法简介</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="YAML"><figure class="iseeu highlight /yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.</span> <span class="string">定义yml文件</span> </span><br><span class="line">   <span class="string">xxx.yml</span> <span class="string">xxx.yaml</span></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">语法</span></span><br><span class="line">   <span class="number">1</span><span class="string">.</span> <span class="string">基本语法</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">suns</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">   <span class="number">2</span><span class="string">.</span> <span class="string">对象概念</span> </span><br><span class="line">      <span class="attr">account:</span> </span><br><span class="line">         <span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">         <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">   <span class="number">3</span><span class="string">.</span> <span class="string">定义集合</span> </span><br><span class="line">      <span class="attr">service:</span> </span><br><span class="line">         <span class="bullet">-</span> <span class="number">11111</span></span><br><span class="line">         <span class="bullet">-</span> <span class="number">22222</span></span><br></pre></td></tr></table></figure></div>

<h6 id="4-Spring与YML集成思路的分析"><a href="#4-Spring与YML集成思路的分析" class="headerlink" title="4. Spring与YML集成思路的分析"></a>4. Spring与YML集成思路的分析</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>准备yml配置文件 </span><br><span class="line">   init.yml</span><br><span class="line">   name: suns</span><br><span class="line">   password: 123456</span><br><span class="line"><span class="bullet">2. </span>读取yml 转换成 Properties</span><br><span class="line">   YamlPropertiesFactoryBean.setResources( yml配置文件的路径 ) new ClassPathResource();</span><br><span class="line">   YamlPropertiesFactoryBean.getObject() ---&gt; Properties </span><br><span class="line"><span class="bullet">3. </span>应用PropertySourcesPlaceholderConfigurer</span><br><span class="line">   PropertySourcesPlaceholderConfigurer.setProperties();</span><br><span class="line"><span class="bullet">4. </span>类中 @Value注解 注入</span><br></pre></td></tr></table></figure></div>

<h6 id="5-Spring与YML集成编码"><a href="#5-Spring与YML集成编码" class="headerlink" title="5. Spring与YML集成编码"></a>5. Spring与YML集成编码</h6><ul>
<li><p>环境搭建</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">最低版本 1.18</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编码</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 准备yml配置文件</span><br><span class="line"><span class="number">2</span>. 配置Bean中操作 完成YAML读取 与 PropertySourcePlaceholderConfigure的创建 </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertySourcesPlaceholderConfigurer <span class="title">configurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        YamlPropertiesFactoryBean yamlPropertiesFactoryBean = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">        yamlPropertiesFactoryBean.setResources(<span class="keyword">new</span> ClassPathResource(<span class="string">"init.yml"</span>));</span><br><span class="line">        Properties properties = yamlPropertiesFactoryBean.getObject();</span><br><span class="line"></span><br><span class="line">        PropertySourcesPlaceholderConfigurer configurer = <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">        configurer.setProperties(properties);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3</span>. 类 加入 <span class="meta">@Value</span>注解</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h6 id="6-Spring与YML集成的问题"><a href="#6-Spring与YML集成的问题" class="headerlink" title="6. Spring与YML集成的问题"></a>6. Spring与YML集成的问题</h6><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="MARKDOWN"><figure class="iseeu highlight /markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>集合处理的问题</span><br><span class="line">   SpringEL表达式解决</span><br><span class="line">   @Value("#&#123;'$&#123;list&#125;'.split(',')&#125;")</span><br><span class="line"><span class="bullet">2. </span>对象类型的YAML进行配置时 过于繁琐 </span><br><span class="line">   @Value("$&#123;account.name&#125;")</span><br><span class="line">   </span><br><span class="line">SpringBoot  @ConfigurationProperties</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot校验和全局异常处理</title>
    <url>/2020/07/16/SpringBoot%E6%A0%A1%E9%AA%8C%E5%92%8C%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="SpringBoot校验和全局异常处理"><a href="#SpringBoot校验和全局异常处理" class="headerlink" title="SpringBoot校验和全局异常处理"></a>SpringBoot校验和全局异常处理</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><ul>
<li>在使用校验机制时，需要引入如下依赖</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--!</span> 在这里必须使用<span class="attr">6.0</span>以下的版本<span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.18.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="约束性注解说明"><a href="#约束性注解说明" class="headerlink" title="约束性注解说明"></a>约束性注解说明</h2><ul>
<li>关于实体类或参数的一些注解</li>
</ul>
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>@NotNull</td>
<td>不能为null</td>
</tr>
<tr>
<td>@Null</td>
<td>必须为null</td>
</tr>
<tr>
<td>@NotBlank</td>
<td>字符串不能为null,字符串trim()后也不能等于“”</td>
</tr>
<tr>
<td>@NotEmpty</td>
<td>不能为null，集合、数组、map等size()不能为0；字符串trim()后可以等于“”</td>
</tr>
<tr>
<td>@Max</td>
<td>最大不能超过</td>
</tr>
<tr>
<td>@Min</td>
<td>最小不能超过</td>
</tr>
<tr>
<td>@Digits(integer = x, fraction = y)</td>
<td>设置必须是数字且数字整数的位数不超过x和小数的位数不超过y</td>
</tr>
<tr>
<td>@Length</td>
<td>字符串长度必须在指定范围内</td>
</tr>
<tr>
<td>@Past</td>
<td>日期必须在当前日期的过去</td>
</tr>
<tr>
<td>@Future</td>
<td>日期必须在当前日期的未来</td>
</tr>
<tr>
<td>@DecimalMax</td>
<td>设置不能超过最大值</td>
</tr>
<tr>
<td>@DecimalMin</td>
<td>设置不能超过最小值</td>
</tr>
<tr>
<td>@AssertFalse</td>
<td>可以为null,如果不为null的话必须为false</td>
</tr>
<tr>
<td>@AssertTrue</td>
<td>可以为null,如果不为null的话必须为true</td>
</tr>
<tr>
<td>@Range</td>
<td>值必须在指定范围内</td>
</tr>
<tr>
<td>@Size</td>
<td>集合、数组、map等的size()值必须在指定范围内</td>
</tr>
<tr>
<td>@Email</td>
<td>必须是email格式</td>
</tr>
<tr>
<td>@Pattern</td>
<td>必须满足指定的正则表达式</td>
</tr>
<tr>
<td>@URL</td>
<td>必须是一个URL</td>
</tr>
</tbody></table>
<ul>
<li>实体类使用约束性注解：其中的message为校验失败的提示消息</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewCoffeeRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"咖啡名称不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"咖啡价格不能为null"</span>)</span><br><span class="line">    <span class="keyword">private</span> Money price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Money <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(Money price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Valid和-Validated"><a href="#Valid和-Validated" class="headerlink" title="@Valid和@Validated"></a>@Valid和@Validated</h3><ul>
<li><p>注解的使用：</p>
<p>在参数的前面添加注解，代表该参数需要被校验，校验的内容就是约束性注解定义的内容</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/"</span>, consumes = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="comment">//在这里对Post请求提交的参数进行校验，并把校验的结果写入BindingResult参数中，BindingResult参数必须紧跟在被校验参数的后面</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Coffee <span class="title">addJsonCoffee</span><span class="params">(@RequestBody @Valid NewCoffeeRequest newCoffee, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果校验不通过则会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">        log.warn(<span class="string">"errors:&#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ValidationException(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>两者的区别：</p>
<ol>
<li><p>@Valid是使用Hibernate validation的时候使用</p>
<p>@Validated是只用Spring Validator校验机制使用</p>
</li>
<li><p>注解位置：</p>
<p>@Validated：用在类型、方法和方法参数上。但不能用于成员属性（field）</p>
<p>@Valid：可以用在方法、构造函数、方法参数和成员属性（field）上</p>
</li>
<li><p>@Validated提供了分组的功能，可以在参数验证时，根据不同的分组采用不同的验证机制，而@Valid没有分组的功能。对一个参数需要多种验证方式时，可通过分配不同的组达到目的，具体的做法：</p>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义分组接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGroupA</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGroupB</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后在@Validated注解中添加接口的类</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"stu"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStu</span><span class="params">(@Validated(&#123;IGroupA.class&#125;)</span> @RequestBody StudentBean studentBean)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"add student success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>嵌套校验</p>
<p>一个待校验的实体类，如果其中还包含了待校验的对象，就需要在待校验的对象上加上@Valid注解，才能校验包含的对象，注意，这里不能使用@Validated。</p>
</li>
</ul>
<h3 id="SpringBoot中的异常处理"><a href="#SpringBoot中的异常处理" class="headerlink" title="SpringBoot中的异常处理"></a>SpringBoot中的异常处理</h3><ul>
<li><strong>@ControllerAdvice</strong>：用于捕获 <code>Controller</code> 层抛出的异常，如果添加 <code>@ResponseBody</code> 返回信息则为<code>JSON</code>格式，它将捕获@Controller层抛出的异常，使业务逻辑与异常处理剥离开。</li>
<li><strong>@RestControllerAdvice</strong> ：相当于 <code>@ControllerAdvice</code> 与 <code>@ResponseBody</code> 的结合体，它将捕获<code>@Controller</code>和<code>@RestController</code>层抛出的异常。</li>
<li><strong>@ExceptionHandler</strong>：用于同于处理一种异常，减少重复性代码。</li>
</ul>
<h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.BAD_REQUEST)</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="comment">//FormValidationException继承了运行时的异常类，表示它是一个runtime的异常类，该类在抛出之后，会被系统捕获，并返回400状态码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormValidationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BindingResult result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="meta">@PostMapping</span>(path = <span class="string">"/"</span>, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Coffee <span class="title">addCoffee</span><span class="params">(@Valid NewCoffeeRequest newCoffee, BindingResult result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">        log.warn(<span class="string">"errors:&#123;&#125;"</span>, result);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FormValidationException(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="自定义一个全局异常处理"><a href="#自定义一个全局异常处理" class="headerlink" title="自定义一个全局异常处理"></a>自定义一个全局异常处理</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.validation.ValidationException;</span><br><span class="line"><span class="comment">//当ValidationException异常抛出时，GlobalControllerAdvice将会捕获ValidationException异常，并执行Handler方法体，并返回400</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalControllerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ValidationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">BAD_REQUEST</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; <span class="title">validationExceptionHandler</span>(<span class="title">ValidationException</span> <span class="title">exception</span>)</span>&#123;</span><br><span class="line">        Map&lt;String, String &gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"message"</span>, exception.getMessage());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>-SpringBoot -Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC--整合ssm</title>
    <url>/2020/07/10/SpringMVC-%E6%95%B4%E5%90%88ssm/</url>
    <content><![CDATA[<h2 id="一、整合前的准备"><a href="#一、整合前的准备" class="headerlink" title="一、整合前的准备"></a>一、整合前的准备</h2><h3 id="1）导入依赖和Maven静态资源过滤"><a href="#1）导入依赖和Maven静态资源过滤" class="headerlink" title="1）导入依赖和Maven静态资源过滤"></a>1）导入依赖和Maven静态资源过滤</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    依赖：junit，数据库驱动，连接池，servlet，jsp，mybatis，mybatis-spring，spring...--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        junit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        spring--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        servlet-api--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        jsp--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        jstl--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        mysql数据库驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        mybatis-spring--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        spring-jdbc--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2）创建数据库"><a href="#2）创建数据库" class="headerlink" title="2）创建数据库"></a>2）创建数据库</h3><h3 id="3）在idea中连接数据库"><a href="#3）在idea中连接数据库" class="headerlink" title="3）在idea中连接数据库"></a>3）在idea中连接数据库</h3><h3 id="4）在项目下创建下列几个包"><a href="#4）在项目下创建下列几个包" class="headerlink" title="4）在项目下创建下列几个包"></a>4）在项目下创建下列几个包</h3><ol>
<li>controller</li>
<li>dao</li>
<li>pojo</li>
<li>service</li>
</ol>
<h2 id="二、Mybatis部分"><a href="#二、Mybatis部分" class="headerlink" title="二、Mybatis部分"></a>二、Mybatis部分</h2><h3 id="1）在res文件夹中创建mybatis-config-xml和database-properties文件，mybatis-config-xml为mybatis的核心配置文件，database-properties为数据库连接信息配置文件"><a href="#1）在res文件夹中创建mybatis-config-xml和database-properties文件，mybatis-config-xml为mybatis的核心配置文件，database-properties为数据库连接信息配置文件" class="headerlink" title="1）在res文件夹中创建mybatis-config.xml和database.properties文件，mybatis-config.xml为mybatis的核心配置文件，database.properties为数据库连接信息配置文件"></a>1）在res文件夹中创建mybatis-config.xml和database.properties文件，mybatis-config.xml为mybatis的核心配置文件，database.properties为数据库连接信息配置文件</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">mybatis-config</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--匹配数据源交给spring去做--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--类型别名:用于扫描com.muchlab.pojo包下所有的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.muchlab.pojo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-在pojo创建实体类Books"><a href="#2-在pojo创建实体类Books" class="headerlink" title="2) 在pojo创建实体类Books"></a>2) 在pojo创建实体类Books</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Books</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookID;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookCounts;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Books</span><span class="params">(<span class="keyword">int</span> bookID, String bookName, <span class="keyword">int</span> bookCounts, String detail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookID = bookID;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">        <span class="keyword">this</span>.bookCounts = bookCounts;</span><br><span class="line">        <span class="keyword">this</span>.detail = detail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-在dao包创建BookMapper接口-该接口可在mybatis中形成多个方法和sql查询语句的映射关系。dao层一般都是外层调用数据库的接口，一般都是一些原子性操作，比如简单的增删改查。"><a href="#3-在dao包创建BookMapper接口-该接口可在mybatis中形成多个方法和sql查询语句的映射关系。dao层一般都是外层调用数据库的接口，一般都是一些原子性操作，比如简单的增删改查。" class="headerlink" title="3)在dao包创建BookMapper接口,该接口可在mybatis中形成多个方法和sql查询语句的映射关系。dao层一般都是外层调用数据库的接口，一般都是一些原子性操作，比如简单的增删改查。"></a>3)在dao包创建BookMapper接口,该接口可在mybatis中形成多个方法和sql查询语句的映射关系。dao层一般都是外层调用数据库的接口，一般都是一些原子性操作，比如简单的增删改查。</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.muchlab.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.muchlab.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//add</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line">    <span class="comment">//delete</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(@Param(<span class="string">"bookID"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//update</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line">    <span class="comment">//queryitem</span></span><br><span class="line">    <span class="function">Books <span class="title">queryBookById</span><span class="params">(@Param(<span class="string">"bookID"</span>)</span> <span class="keyword">int</span> id)</span>;</span><br><span class="line">    <span class="comment">//queryall</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//queryBookByName</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryBookByName</span><span class="params">(@Param(<span class="string">"bookName"</span>)</span>String bookName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="4）在dao包创建BookMapper-xml，该文件为mybatis的映射文件。"><a href="#4）在dao包创建BookMapper-xml，该文件为mybatis的映射文件。" class="headerlink" title="4）在dao包创建BookMapper.xml，该文件为mybatis的映射文件。"></a>4）在dao包创建BookMapper.xml，该文件为mybatis的映射文件。</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace指明了该mapper文件所映射的接口类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.muchlab.dao.BookMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id为接口中的方法名，parameterType为方法的参数类型，resultType为方法的返回类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addBook"</span> <span class="attr">parameterType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        insert into ssmbuild.books (bookName, bookCounts, detail) values</span><br><span class="line">        (#&#123;bookName&#125;, #&#123;bookCounts&#125;, #&#123;detail&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteBookById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from  ssmbuild.books where bookID = #&#123;bookID&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBook"</span> <span class="attr">parameterType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        update ssmbuild.books set bookName=#&#123;bookName&#125;, bookCounts=#&#123;bookCounts&#125;, detail=#&#123;detail&#125; where bookID=#&#123;bookID&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBookById"</span> <span class="attr">resultType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books where bookID = #&#123;bookID&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAllBook"</span> <span class="attr">resultType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBookByName"</span> <span class="attr">resultType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        select * from ssmbuild.books where bookName like "%"#&#123;bookName&#125;"%";</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="5）在service包创建BookService接口，该接口为具体业务的接口，再创建一个BookServiceImpl实现BookService接口。业务层一般用来调用dao层，通过较复杂的逻辑来满足用户的需求"><a href="#5）在service包创建BookService接口，该接口为具体业务的接口，再创建一个BookServiceImpl实现BookService接口。业务层一般用来调用dao层，通过较复杂的逻辑来满足用户的需求" class="headerlink" title="5）在service包创建BookService接口，该接口为具体业务的接口，再创建一个BookServiceImpl实现BookService接口。业务层一般用来调用dao层，通过较复杂的逻辑来满足用户的需求"></a>5）在service包创建BookService接口，该接口为具体业务的接口，再创建一个BookServiceImpl实现BookService接口。业务层一般用来调用dao层，通过较复杂的逻辑来满足用户的需求</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">BookService</span><br><span class="line"><span class="keyword">package</span> com.muchlab.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.muchlab.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//add</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line">    <span class="comment">//delete</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">( <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//update</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line">    <span class="comment">//queryitem</span></span><br><span class="line">    <span class="function">Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">//queryall</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//queryBookByName</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryBookByName</span><span class="params">(String bookName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">BookServiceImpl</span><br><span class="line"><span class="keyword">package</span> com.muchlab.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.muchlab.dao.BookMapper;</span><br><span class="line"><span class="keyword">import</span> com.muchlab.pojo.Books;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line">    <span class="comment">//后面将在spring的业务配置文件中使用依赖注入的方式实现bookMapper接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookMapper</span><span class="params">(BookMapper bookMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookMapper = bookMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.addBook(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.deleteBookById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.updateBook(books);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryBookById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryAllBook();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Books&gt; <span class="title">queryBookByName</span><span class="params">(String bookName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryBookByName(bookName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="三、Spring部分"><a href="#三、Spring部分" class="headerlink" title="三、Spring部分"></a>三、Spring部分</h2><h3 id="1）在res文件夹下创建applicationContext-xml、spring-dao-xml、spring-service-xml文件，这三个文件分别为整个项目、dao和service的配置文件，并将这三个文件添加到同一个SpringApplicationContext中"><a href="#1）在res文件夹下创建applicationContext-xml、spring-dao-xml、spring-service-xml文件，这三个文件分别为整个项目、dao和service的配置文件，并将这三个文件添加到同一个SpringApplicationContext中" class="headerlink" title="1）在res文件夹下创建applicationContext.xml、spring-dao.xml、spring-service.xml文件，这三个文件分别为整个项目、dao和service的配置文件，并将这三个文件添加到同一个SpringApplicationContext中"></a>1）在res文件夹下创建applicationContext.xml、spring-dao.xml、spring-service.xml文件，这三个文件分别为整个项目、dao和service的配置文件，并将这三个文件添加到同一个SpringApplicationContext中</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line">applicationContext.xml</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"springmvc-servlet.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring-service.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring-dao.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img src="/2020/07/10/SpringMVC-%E6%95%B4%E5%90%88ssm/C:%5CUsers%5C14276%5CPictures%5Cssm%E6%95%B4%E5%90%88%5Capplicationcontext.PNG" alt="该窗口在项目结构中可打开"></p>
<h3 id="2-spring-dao-xml-用于连接数据源和实现Dao接口，并将他们注入到spring容器中，由spring统一管理"><a href="#2-spring-dao-xml-用于连接数据源和实现Dao接口，并将他们注入到spring容器中，由spring统一管理" class="headerlink" title="2)spring-dao.xml,用于连接数据源和实现Dao接口，并将他们注入到spring容器中，由spring统一管理"></a>2)spring-dao.xml,用于连接数据源和实现Dao接口，并将他们注入到spring容器中，由spring统一管理</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    1关联数据库配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:database.properties"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    2导入c3p0连接池</span></span><br><span class="line"><span class="comment">        dbcp:半自动化操作，不能自动连接</span></span><br><span class="line"><span class="comment">        c3p0:自动化操作（自动化的加载配置文件，并且可以自动设置到对象中）</span></span><br><span class="line"><span class="comment">        druid:</span></span><br><span class="line"><span class="comment">        hikari:--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    3sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        关联数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--绑定mybatis配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置dao接口扫描包，动态实现Dao接口并注入到spring容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        注入sqlSessionFactory--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        要扫描的dao包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.muchlab.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-spring-service-xml-用于将所有的服务类实现，并注入到spring容器中，在该文件中可以添加spring为我们提供好的服务，比如事务管理、日志服务、身份认证等等，都是以aop的方式进行横向切入的。"><a href="#3-spring-service-xml-用于将所有的服务类实现，并注入到spring容器中，在该文件中可以添加spring为我们提供好的服务，比如事务管理、日志服务、身份认证等等，都是以aop的方式进行横向切入的。" class="headerlink" title="3)spring-service.xml,用于将所有的服务类实现，并注入到spring容器中，在该文件中可以添加spring为我们提供好的服务，比如事务管理、日志服务、身份认证等等，都是以aop的方式进行横向切入的。"></a>3)spring-service.xml,用于将所有的服务类实现，并注入到spring容器中，在该文件中可以添加spring为我们提供好的服务，比如事务管理、日志服务、身份认证等等，都是以aop的方式进行横向切入的。</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    1扫描service下的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.muchlab.service"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    2将所有的服务类实现，并注入到spring容器中，也可以通过注解实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.muchlab.service.BookServiceImpl"</span> <span class="attr">id</span>=<span class="string">"bookServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookMapper"</span> <span class="attr">ref</span>=<span class="string">"bookMapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    3声明事务管理，自动管理增删改查，比如自动提交事务等--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    4aop事务支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="四、SpringMvc部分"><a href="#四、SpringMvc部分" class="headerlink" title="四、SpringMvc部分"></a>四、SpringMvc部分</h2><h3 id="1）为项目添加web支持"><a href="#1）为项目添加web支持" class="headerlink" title="1）为项目添加web支持"></a>1）为项目添加web支持</h3><h3 id="2-配置web-xml"><a href="#2-配置web-xml" class="headerlink" title="2)配置web.xml"></a>2)配置web.xml</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    DispatcherServlet，用于拦截匹配的请求，Servlet拦截匹配规则要自己定义，把拦截下来的请求，依据相应的规则分发到目标Controller来处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--初始化参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--绑定spring配置文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--表示匹配根路径下的全部请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    乱码过滤，该过滤为spring提供的，用于解决乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    Session时限15分钟--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="3-在res下创建springmvc-servlet-xml"><a href="#3-在res下创建springmvc-servlet-xml" class="headerlink" title="3)在res下创建springmvc-servlet.xml"></a>3)在res下创建springmvc-servlet.xml</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    1注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    2静态资源过滤--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    3扫描包：controller--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.muchlab.controller"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    4视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--    后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="4）注意，在启动项目前必须在项目结构中添加所依赖的jar包，不然服务器会找不到资源从而报错"><a href="#4）注意，在启动项目前必须在项目结构中添加所依赖的jar包，不然服务器会找不到资源从而报错" class="headerlink" title="4）注意，在启动项目前必须在项目结构中添加所依赖的jar包，不然服务器会找不到资源从而报错"></a>4）注意，在启动项目前必须在项目结构中添加所依赖的jar包，不然服务器会找不到资源从而报错</h3><h2 id="至此，SpringMvc，Spring和Mybatis的整合就结束了。"><a href="#至此，SpringMvc，Spring和Mybatis的整合就结束了。" class="headerlink" title="至此，SpringMvc，Spring和Mybatis的整合就结束了。"></a>至此，SpringMvc，Spring和Mybatis的整合就结束了。</h2>]]></content>
      <categories>
        <category>-SpringMVC</category>
      </categories>
      <tags>
        <tag>-SpringMVC -MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot——配置文件</title>
    <url>/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<ul>
<li>配置文件的作用：修改SpringBoot自动配置的默认值，SpringBoot在底层都给我们自动配置好了</li>
</ul>
<h3 id="application-properties全局配置文件-amp-yml配置文件"><a href="#application-properties全局配置文件-amp-yml配置文件" class="headerlink" title="application.properties全局配置文件&amp;yml配置文件"></a>application.properties全局配置文件&amp;yml配置文件</h3><p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/SpringBoot%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.PNG" alt="SpringBoot的配置文件"></p>
<h4 id="1、yml以数据为中心，比json和xml更适合做数据型配置文件-如yml文件的基本语法如下"><a href="#1、yml以数据为中心，比json和xml更适合做数据型配置文件-如yml文件的基本语法如下" class="headerlink" title="1、yml以数据为中心，比json和xml更适合做数据型配置文件,如yml文件的基本语法如下"></a>1、yml以数据为中心，比json和xml更适合做数据型配置文件,如yml文件的基本语法如下</h4><ol>
<li><p>以k:v来表示一对键值对（在:后面必须加空格)。</p>
</li>
<li><p>以空格的缩进来控制层级关系，只要左对齐的一列数据，都是属于同一层级的。</p>
</li>
<li><p>属性和值是严格区分大小写。</p>
</li>
</ol>
<h4 id="2、值的写法：都是可以用k-v的形式来写"><a href="#2、值的写法：都是可以用k-v的形式来写" class="headerlink" title="2、值的写法：都是可以用k:v的形式来写"></a>2、值的写法：都是可以用k:v的形式来写</h4><ol>
<li><p>数字、字符串、布尔值: 直接写</p>
</li>
<li><p>数组: 数组可以使用行内写法：list: [a,b,c]</p>
</li>
<li><p>对象、Map（）：对象可以使用行内写法：</p>
</li>
</ol>
<p><code>person: {name:xxx, age:xxx, sex:xxx, ...}</code></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="string">profiles:prod</span></span><br><span class="line"><span class="comment">#person:</span></span><br><span class="line"><span class="comment">#  name: 陈哲凯</span></span><br><span class="line"><span class="comment">#  age: 23</span></span><br><span class="line"><span class="comment">#  sex: true</span></span><br><span class="line"><span class="comment">#  birth: 1998/08/29</span></span><br><span class="line"><span class="comment">#  list:</span></span><br><span class="line"><span class="comment">#    - "first"</span></span><br><span class="line"><span class="comment">#    - "second"</span></span><br><span class="line"><span class="comment">#    - "third"</span></span><br></pre></td></tr></table></figure></div>

<h4 id="yml配置文件值的获取"><a href="#yml配置文件值的获取" class="headerlink" title="yml配置文件值的获取"></a>yml配置文件值的获取</h4><ul>
<li>@ConfigurationProperties(prefix = “配置文件中的配置数据值”)，即可将配置文件中配置的每一个属性的值都映射到带有这个注解的组件类中</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在类定义前必须加上@Component来标注这个类是一个组件，只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在组件类定义的前面加@ConfigurationProperties注解可以将组件类的所有属性和配置文件中相关的配置进行绑定</li>
</ul>
<h3 id="ConfigurationProperties和-Value的区别"><a href="#ConfigurationProperties和-Value的区别" class="headerlink" title="@ConfigurationProperties和@Value的区别"></a>@ConfigurationProperties和@Value的区别</h3><ul>
<li>@Value是加在类的属性之前，和@ConfigurationProperties一样，能将配置文件的数据和属性绑定起来，也能在组件类中指定值，但@Value只能绑定一个属性，使用的形式：@Value(“…”)</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@ConfigurationProperties(prefix = "person")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;11*2&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"false"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.birth&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>区别：</li>
</ul>
<table>
<thead>
<tr>
<th>-</th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>
<tr>
<td>松散绑定</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表达式</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<ul>
<li>如果只是在某个业务逻辑中需要获取一个配置文件中的某项值，使用@Value；如果专门编写了一个JavaBean来和配置文件进行映射，就直接使用@ConfigurationProperties</li>
</ul>
<h3 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h3><ul>
<li>加载指定的配置文件</li>
<li>@ConfigurationProperties默认是加载application.properties全局配置文件，而@PropertySource可以加载指定的配置文件</li>
<li>例如，在Person类定义的前面加上@PropertiesSource(value = {“classpath:person.properties”}),Person类就会加载resources目录下的person.properties，将配置文件的数据绑定到类的属性中</li>
</ul>
<h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><ul>
<li><p>导入Spring的配置文件，让配置文件里面的内容生效；Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；想让Spring的配置文件生效、加载起来，就需要把@ImportResource标注在一个配置类上。</p>
</li>
<li><p>SpringBoot推荐给容器中添加组件的方式：使用全注解的方式</p>
</li>
</ul>
<h4 id="1、配置类-Spring配置文件-在SpringBootApplication类中使用-ImportResource注解指定配置文件的路径"><a href="#1、配置类-Spring配置文件-在SpringBootApplication类中使用-ImportResource注解指定配置文件的路径" class="headerlink" title="1、配置类=====Spring配置文件,在SpringBootApplication类中使用@ImportResource注解指定配置文件的路径"></a>1、配置类=====Spring配置文件,在SpringBootApplication类中使用@ImportResource注解指定配置文件的路径</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:bean.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot01HelloworldQuickApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBoot01HelloworldQuickApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2、使用-Bean给容器中添加组件（推荐方式）"><a href="#2、使用-Bean给容器中添加组件（推荐方式）" class="headerlink" title="2、使用@Bean给容器中添加组件（推荐方式）"></a>2、使用@Bean给容器中添加组件（推荐方式）</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Configuration指明当前类是一个配置类，就是来代替之前的Spring配置文件</span></span><br><span class="line"><span class="comment">* 之前在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment">* 现在可以在配置类中使用@Bean注解来添加组件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><h4 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h4><ul>
<li>形式：${random.value},value可以是int、int(n)、long和int[n, m]（n到m的随机数）等等。</li>
</ul>
<h4 id="2、占位符获取之前配置的值，若没有可以用指定的默认值"><a href="#2、占位符获取之前配置的值，若没有可以用指定的默认值" class="headerlink" title="2、占位符获取之前配置的值，若没有可以用指定的默认值"></a>2、占位符获取之前配置的值，若没有可以用指定的默认值</h4><ul>
<li>形式：${之前配置的值对应的key}</li>
</ul>
<hr>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h3><h4 id="1、多Profile文件"><a href="#1、多Profile文件" class="headerlink" title="1、多Profile文件"></a>1、多Profile文件</h4><ul>
<li>我们在主配置文件编写的时候，文件名可以是application-{profile}.properties/yml,默认使用application.properties,可以在默认配置文件中用spring.profiles.active=xxx来激活使用的配置文件,例如在application.properties下写spring.profiles.active=dev，Spring就会使用application-dev.properties作为它的配置文件，这样就可以灵活地在多个环境下的不同配置信息进行切换。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PROPERTIES"><figure class="iseeu highlight /properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">server.port&#x3D;8081</span><br></pre></td></tr></table></figure></div>

<h4 id="1、yml多文档块"><a href="#1、yml多文档块" class="headerlink" title="1、yml多文档块"></a>1、yml多文档块</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="YML"><figure class="iseeu highlight /yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#默认的配置（文档块一）</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="comment">#在这里激活使用哪个文档块</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br><span class="line"><span class="comment"># 多个文档块间使用'---'进行分隔</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 文档块二</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 文档块三</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">sex:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">b</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">c</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2000</span><span class="string">/01/01</span></span><br></pre></td></tr></table></figure></div>

<h4 id="激活指定的profile方式"><a href="#激活指定的profile方式" class="headerlink" title="激活指定的profile方式"></a>激活指定的profile方式</h4><ol>
<li><p>spring.profiles.active=xxx来激活配置</p>
</li>
<li><p>在EditConfiguration设置里面点开SpringBoot先选定你想要设置的项目，然后修改Active profiles选项，即可修改profile配置。</p>
</li>
<li><p>命令行方式：java -jar spring-boot-01-helloworld-quick-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev直接在命令行传入参数指定profile</p>
</li>
</ol>
<hr>
<h3 id="配置文件加载的位置"><a href="#配置文件加载的位置" class="headerlink" title="配置文件加载的位置"></a>配置文件加载的位置</h3><h4 id="1、内部配置文件加载位置"><a href="#1、内部配置文件加载位置" class="headerlink" title="1、内部配置文件加载位置"></a>1、内部配置文件加载位置</h4><p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BD%8D%E7%BD%AE.PNG" alt="SpringBoot配置文件加载位置"></p>
<h4 id="2、外部配置文件加载顺序"><a href="#2、外部配置文件加载顺序" class="headerlink" title="2、外部配置文件加载顺序"></a>2、外部配置文件加载顺序</h4><p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/SpringBoot%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F3.PNG" alt="SpringBoot外部配置加载顺序1"></p>
<p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/SpringBoot%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F1.PNG" alt="SpringBoot外部配置加载顺序2"></p>
<p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/SpringBoot%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F2.PNG" alt="SpringBoot外部配置加载顺序3"></p>
<hr>
<h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><p>配置文件到底能写什么？怎么写？</p>
<p><a href="https://docs.spring.io/spring-boot/docs/2.2.3.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p>
<h4 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h4><ol>
<li><p>SpringBoot启动的时候加载主配置类，开启自动配置功能@EnableAutoConfiguration</p>
</li>
<li><p>@EnableAutoConfiguration的作用：</p>
</li>
</ol>
<ul>
<li><p>使用AutoConfigurationImportSelector给容器中导入一些组件</p>
</li>
<li><p>AutoConfigurationImportSelector使用<code>List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</code>来获取候选的配置</p>
</li>
<li><p>getCandidateConfigurations使用了SpringFactoriesLoader来将类路径下的”META-INF/spring.factories”EnableAutoConfiguration里面所有的配置的值加入到容器中，每一个xxxAutoConfiguration类都是容器中的一个组件，它们都会进行一个自动配置（自动配置功能），然后加入到容器中</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><figcaption><span>Library</span></figcaption><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">......总共有一百多个组件</span><br></pre></td></tr></table></figure></div>

<ul>
<li>下面以HttpEncoding的自动配置原理来进行讲解：</li>
</ul>
<p><img src="/images/SpringBoot/%E9%85%8D%E7%BD%AE%E5%9B%BE%E7%89%87/HttpE%E4%BD%A0%E4%BB%8E%E5%AE%9AAutoConfiguration%EF%BC%88Http%E7%BC%96%E7%A0%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%89%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.PNG" alt="HttpEncodingAutoConfiguration"></p>
<h3 id="Conditional派生注解和自动配置报告"><a href="#Conditional派生注解和自动配置报告" class="headerlink" title="Conditional派生注解和自动配置报告"></a>Conditional派生注解和自动配置报告</h3><h4 id="1、Conditional派生注解"><a href="#1、Conditional派生注解" class="headerlink" title="1、Conditional派生注解"></a>1、Conditional派生注解</h4><p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/Conditional%E6%B4%BE%E7%94%9F%E6%B3%A8%E8%A7%A3.PNG" alt="Conditional派生注解"></p>
<h4 id="2、自动配置报告"><a href="#2、自动配置报告" class="headerlink" title="2、自动配置报告"></a>2、自动配置报告</h4><ul>
<li>可以在配置文件中设置debug的值来让springboot生成自动配置报告，即写上debug=true（默认为false）</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVA"><figure class="iseeu highlight /java"><table><tr><td class="code"><pre><span class="line">============================</span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动的自动配置类</span></span><br><span class="line">Positive matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnProperty</span> (spring.aop.auto=<span class="keyword">true</span>) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration.ClassProxyingConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnMissingClass</span> did not find unwanted <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">aspectj</span>.<span class="title">weaver</span>.<span class="title">Advice</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class">      - @<span class="title">ConditionalOnProperty</span> (<span class="title">spring</span>.<span class="title">aop</span>.<span class="title">proxy</span>-<span class="title">target</span>-<span class="title">class</span></span>=<span class="keyword">true</span>) matched (OnPropertyCondition)</span><br><span class="line">      ......</span><br><span class="line"><span class="comment">//没有启动的自动配置类</span></span><br><span class="line">Negative matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required <span class="class"><span class="keyword">class</span> '<span class="title">javax</span>.<span class="title">jms</span>.<span class="title">ConnectionFactory</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">   AopAutoConfiguration.AspectJAutoProxyingConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">aspectj</span>.<span class="title">weaver</span>.<span class="title">Advice</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class">        ......</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>在使用自动配置类属性时的精髓：</li>
</ul>
<p><img src="/2020/01/19/SpringBoot%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E7%B2%BE%E9%AB%93.PNG" alt="使用自动配置的精髓"></p>
<hr>
<p>参考视频：<a href="https://www.bilibili.com/video/av38657363?p=20" target="_blank" rel="noopener">B站</a><br>感谢观看</p>
]]></content>
      <categories>
        <category>-SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF之依赖属性</title>
    <url>/2019/09/22/WPF%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="依赖属性简述"><a href="#依赖属性简述" class="headerlink" title="依赖属性简述"></a>依赖属性简述</h3><ul>
<li>依赖属性的特性：依赖属性 = 普通属性+扩充特性</li>
</ul>
<h4 id="继承特性，父元素的依赖属性可被子元素所继承DataContext、FontSize、Background在父元素设置依赖属性时，如果子元素没有设置与其相同的依赖属性，子元素就会继承父元素依赖属性的值，例如"><a href="#继承特性，父元素的依赖属性可被子元素所继承DataContext、FontSize、Background在父元素设置依赖属性时，如果子元素没有设置与其相同的依赖属性，子元素就会继承父元素依赖属性的值，例如" class="headerlink" title="继承特性，父元素的依赖属性可被子元素所继承DataContext、FontSize、Background在父元素设置依赖属性时，如果子元素没有设置与其相同的依赖属性，子元素就会继承父元素依赖属性的值，例如"></a>继承特性，父元素的依赖属性可被子元素所继承DataContext、FontSize、Background在父元素设置依赖属性时，如果子元素没有设置与其相同的依赖属性，子元素就会继承父元素依赖属性的值，例如</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Window Title&#x3D;&quot;MainWindow&quot; Height&#x3D;&quot;300&quot; Width&#x3D;&quot;300&quot; FontSize&#x3D;&quot;24&quot;&gt;</span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">        &lt;TextBlock Text&#x3D;&quot;字号改变&quot; Margin&#x3D;&quot;5&quot; TextWrapping&#x3D;&quot;Wrap&quot; HorizontalAlignment&#x3D;&quot;Center&quot;&#x2F;&gt;</span><br><span class="line">        &lt;TextBlock Text&#x3D;&quot;字号改变&quot; Margin&#x3D;&quot;5&quot; TextWrapping&#x3D;&quot;Wrap&quot; HorizontalAlignment&#x3D;&quot;Center&quot;&#x2F;&gt;</span><br><span class="line">        &lt;TextBlock Text&#x3D;&quot;字号改变&quot; Margin&#x3D;&quot;5&quot; TextWrapping&#x3D;&quot;Wrap&quot; HorizontalAlignment&#x3D;&quot;Center&quot;&#x2F;&gt;</span><br><span class="line">        &lt;Button Padding&#x3D;&quot;5&quot; Content&#x3D;&quot;按下改变字号&quot; Margin&#x3D;&quot;5&quot; Click&#x3D;&quot;Button_Click&quot; HorizontalAlignment&#x3D;&quot;Center&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;StackPanel&gt;</span><br><span class="line">&lt;&#x2F;Window&gt;</span><br></pre></td></tr></table></figure></div>

<p>由于Window设置了依赖属性FontSize，而其子元素都没有设置，所以由于继承性TextBlock和<br>Button会继承Window的FontSize属性的值。</p>
<h4 id="值的自动验证和动态调整"><a href="#值的自动验证和动态调整" class="headerlink" title="值的自动验证和动态调整"></a>值的自动验证和动态调整</h4><h4 id="属性变动通知"><a href="#属性变动通知" class="headerlink" title="属性变动通知"></a>属性变动通知</h4><h3 id="自定义依赖属性"><a href="#自定义依赖属性" class="headerlink" title="自定义依赖属性"></a>自定义依赖属性</h3><h4 id="注册依赖项属性"><a href="#注册依赖项属性" class="headerlink" title="注册依赖项属性"></a>注册依赖项属性</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;要定义依赖属性时，必须定义一个静态的只读的DependencyProperty的字段，该字段其实就是Register的返回值，MyValueProperty其实就是依赖项属性</span><br><span class="line">static保持其属性信息始终可用，并且共享这些信息，readonly保持属性不可修改</span><br><span class="line">public static readonly DependencyProperty MyValueProperty &#x3D; DependencyProperty.Register(</span><br><span class="line">&quot;MyValue&quot;, &#x2F;&#x2F;依赖属性名</span><br><span class="line">typeof(int), &#x2F;&#x2F;数据类型</span><br><span class="line">typeof(DependencyPropertyClass), &#x2F;&#x2F;依赖属性的宿主类型</span><br><span class="line">new PropertyMetadata</span><br><span class="line">(100, &#x2F;&#x2F;默认值</span><br><span class="line">&#x2F;&#x2F;属性值改变时的回调方法,d为依赖属性，e为属性改变时触发的事件</span><br><span class="line">(d, e) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox.Show(&quot;调用PropertyChangedCallback委托：Property:&quot;</span><br><span class="line">        + e.Property + &quot;,OldValue:&quot; + e.OldValue + &quot;,NewValue:&quot; + e.NewValue);</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;用于动态调整值得回调方法，value为依赖属性的值</span><br><span class="line">(d, value) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    int newValue &#x3D; (int)value + 1;</span><br><span class="line">    MessageBox.Show(&quot;调用CoerceValueCallback委托，原值:&quot; + value + &quot;新值:&quot; + newValue);</span><br><span class="line">    return newValue;</span><br><span class="line">&#125;</span><br><span class="line">));</span><br></pre></td></tr></table></figure></div>

<h4 id="添加属性包装器"><a href="#添加属性包装器" class="headerlink" title="添加属性包装器"></a>添加属性包装器</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public int MyValue</span><br><span class="line">&#123;</span><br><span class="line">    get &#123; return (int)GetValue(MyValueProperty); &#125;&#x2F;&#x2F;依赖属性获取值的方式GetValue</span><br><span class="line">    set &#123; SetValue(MyValueProperty, value); &#125;&#x2F;&#x2F;依赖属性设置值的方式SetValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>包装器的作用是让依赖属性能用.Net属性使用的方式使用</li>
</ul>
<h4 id="在主程序使用用户控件的依赖属性"><a href="#在主程序使用用户控件的依赖属性" class="headerlink" title="在主程序使用用户控件的依赖属性"></a>在主程序使用用户控件的依赖属性</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Window xmlns:local&#x3D;&quot;clr-namespace:DependencyPropertyDemo&quot;</span><br><span class="line">        Title&#x3D;&quot;MainWindow&quot; Height&#x3D;&quot;300&quot; Width&#x3D;&quot;300&quot; FontSize&#x3D;&quot;24&quot;&gt;</span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">        &lt;local:MyDPUserControl x:Name&#x3D;&quot;myDP&quot;&#x2F;&gt;</span><br><span class="line">        &lt;Label Content&#x3D;&quot;&#123;Binding ElementName&#x3D;myDP, Path&#x3D;MyValue&#125;&quot; HorizontalAlignment&#x3D;&quot;Center&quot;&#x2F;&gt;</span><br><span class="line">        &lt;Button Click&#x3D;&quot;Button_Click_1&quot; HorizontalAlignment&#x3D;&quot;Center&quot; Height&#x3D;&quot;40&quot; Content&#x3D;&quot;按下改变MyValue的值&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;StackPanel&gt;</span><br><span class="line">&lt;&#x2F;Window&gt;</span><br></pre></td></tr></table></figure></div>

<p>3）依赖属性应用于数据绑定</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">    &lt;local:MyWPFClass x:Key&#x3D;&quot;MyWPFClassObject&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Window.Resources&gt;</span><br><span class="line">    &lt;StackPanel Margin&#x3D;&quot;10&quot;</span><br><span class="line">    HorizontalAlignment&#x3D;&quot;Center&quot; DataContext&#x3D;&quot;&#123;StaticResource MyWPFClassObject&#125;&quot;&gt;</span><br><span class="line">        &lt;TextBlock Text&#x3D;&quot;滚动条和文本标签都直接绑定到一个MyWPFClass对象的MyValue属性实现同步&quot;&#x2F;&gt;</span><br><span class="line">        &lt;ScrollBar Maximum&#x3D;&quot;100&quot; Minimum&#x3D;&quot;0&quot; Width&#x3D;&quot;300&quot;</span><br><span class="line">                   Background&#x3D;&quot;DeepPink&quot;</span><br><span class="line">                   Orientation&#x3D;&quot;Horizontal&quot;</span><br><span class="line">                   Margin&#x3D;&quot;10&quot; Value&#x3D;&quot;&#123;Binding MyValue&#125;&quot; LargeChange&#x3D;&quot;10&quot; SmallChange&#x3D;&quot;1&quot; HorizontalAlignment&#x3D;&quot;Center&quot;&#x2F;&gt;</span><br><span class="line">        &lt;TextBlock Margin&#x3D;&quot;10&quot;&gt;</span><br><span class="line">        &lt;Run&gt;MyWPFClassObject.MyValue&#x3D;&lt;&#x2F;Run&gt;</span><br><span class="line">        &lt;Run FontSize&#x3D;&quot;20&quot; Foreground&#x3D;&quot;Red&quot; Text&#x3D;&quot;&#123;Binding Path&#x3D;MyValue&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;TextBlock&gt;</span><br><span class="line">    &lt;&#x2F;StackPanel&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="依赖属性的自动调整特性"><a href="#依赖属性的自动调整特性" class="headerlink" title="依赖属性的自动调整特性"></a>依赖属性的自动调整特性</h3><ul>
<li>两个回调函数：</li>
</ul>
<ol>
<li>PropertyChangedCallback：当值改变时，此函数被调用</li>
<li>CoerceValueCallback：用于调整输入值</li>
</ol>
<hr>
<p>参考文献：WPF编程宝典</p>
]]></content>
      <categories>
        <category>-WPF</category>
      </categories>
      <tags>
        <tag>-WPF -C#</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF之数据绑定</title>
    <url>/2019/09/17/WPF%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h3 id="一、概念：什么是数据绑定"><a href="#一、概念：什么是数据绑定" class="headerlink" title="一、概念：什么是数据绑定"></a>一、概念：什么是数据绑定</h3><ul>
<li>WPF中的数据绑定：是在应用程序 UI 与业务逻辑之间建立连接的过程；数据绑定实质上是绑定目标与绑定源之间的桥梁。</li>
</ul>
<p><img src="/2019/09/17/WPF%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/27.PNG" alt="数据绑定"></p>
<ul>
<li>如上图所示：每一个绑定都包含四个部分：</li>
</ul>
<ol>
<li><p>绑定目标：指定需要应用到的对象。</p>
</li>
<li><p>绑定源：指定提供绑定数据的对象。</p>
</li>
<li><p>目标属性：作用到绑定目标的某一些属性。</p>
</li>
<li><p>源属性：绑定源中存储绑定数据的属性。</p>
</li>
</ol>
<hr>
<h3 id="二、数据绑定的模式（数据流的方向）"><a href="#二、数据绑定的模式（数据流的方向）" class="headerlink" title="二、数据绑定的模式（数据流的方向）"></a>二、数据绑定的模式（数据流的方向）</h3><p><img src="/2019/09/17/WPF%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/28.PNG" alt="数据绑定"></p>
<h4 id="OneWay：绑定导致对源属性的更改会自动更新目标属性，但是对目标属性的更改不会传播回源属性"><a href="#OneWay：绑定导致对源属性的更改会自动更新目标属性，但是对目标属性的更改不会传播回源属性" class="headerlink" title="OneWay：绑定导致对源属性的更改会自动更新目标属性，但是对目标属性的更改不会传播回源属性"></a>OneWay：绑定导致对源属性的更改会自动更新目标属性，但是对目标属性的更改不会传播回源属性</h4><ol>
<li><p>适用于绑定的控件为隐式只读控件的情况。</p>
</li>
<li><p>可避免 TwoWay 绑定模式的系统开销</p>
</li>
</ol>
<h4 id="TwoWay：绑定导致对源属性的更改会自动更新目标属性，而对目标属性的更改也会自动更新源属性"><a href="#TwoWay：绑定导致对源属性的更改会自动更新目标属性，而对目标属性的更改也会自动更新源属性" class="headerlink" title="TwoWay：绑定导致对源属性的更改会自动更新目标属性，而对目标属性的更改也会自动更新源属性"></a>TwoWay：绑定导致对源属性的更改会自动更新目标属性，而对目标属性的更改也会自动更新源属性</h4><ol>
<li>此绑定类型适用于可编辑窗体或其他完全交互式 UI 方案。</li>
</ol>
<h4 id="OneWayToSource-与-OneWay-绑定相反"><a href="#OneWayToSource-与-OneWay-绑定相反" class="headerlink" title="OneWayToSource 与 OneWay 绑定相反"></a>OneWayToSource 与 OneWay 绑定相反</h4><ol>
<li>一个示例方案是您只需要从 UI 重新计算源值的情况。</li>
</ol>
<h4 id="OneTime-绑定未在图中显示，该绑定会导致源属性初始化目标属性，但不传播后续更改"><a href="#OneTime-绑定未在图中显示，该绑定会导致源属性初始化目标属性，但不传播后续更改" class="headerlink" title="OneTime 绑定未在图中显示，该绑定会导致源属性初始化目标属性，但不传播后续更改"></a>OneTime 绑定未在图中显示，该绑定会导致源属性初始化目标属性，但不传播后续更改</h4><ol>
<li><p>使用当前状态的快照适合使用的或数据状态实际为静态的数据。</p>
</li>
<li><p>如果要从源属性初始化具有某个值的目标属性，并且事先不知道数据上下文，则也可以使用此绑定类型。</p>
</li>
<li><p>此绑定类型实质上是 OneWay 绑定的简化形式，在源值不更改的情况下可以提供更好的性能。</p>
</li>
</ol>
<h3 id="三、数据绑定的具体步骤"><a href="#三、数据绑定的具体步骤" class="headerlink" title="三、数据绑定的具体步骤"></a>三、数据绑定的具体步骤</h3><ol>
<li><p>定义一个类（绑定目标），定义源属性</p>
</li>
<li><p>在主窗口cs文件中new一个绑定目标的实例，给要绑定源（需要绑定的控件）设定DataContext（数据上下文）</p>
</li>
<li><p>在XAML中的绑定目标中输入目标属性和源属性的binding语句，</p>
</li>
</ol>
<ul>
<li>例Text=”{Binding Name}”,在这里Text为绑定属性，Name为目标属性。</li>
<li>补充：几乎所有控件属性都可以进行这样的数据绑定</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;TextBox x:Name&#x3D;&quot;txtname&quot; Text&#x3D;&quot;&#123;Binding Name&#125;&quot; ToolTip&#x3D;&quot;&#123;Binding Name&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure></div>

<p>​```.cs<br>private void Window_Loaded(object sender, RoutedEventArgs e)<br>{<br>    //txtname.DataContext = p;<br>    //txtage.DataContext = p;<br>    //txtheight.DataContext = p;<br>    //cbman.DataContext = p;<br>    //子控件以及所有后代控件都默认继承父控件的DataContext<br>    grid.DataContext = p;<br>}</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 如上所示，可以编写TextBox控件的Text属性为Text=<span class="string">"&#123;Binding Name&#125;"</span>使其绑定在.cs文件中用数据上下文指定的对象上，其中TextBox为绑定目标，Text和ToolTip都为目标属性，p为绑定源，Name为源属性。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 四、创建动态的数据绑定</span></span><br><span class="line"></span><br><span class="line">* 由于控件一般都有ContextChanged的事件，所以当界面改变时，逻辑层的属性也会跟着一起改变，如果要求界面层的属性跟逻辑层的属性一起发生改变，则需要实现INotifyPropertyChanged接口，并在属性值变化后触发事件：PropertyChanged</span><br><span class="line"></span><br><span class="line">* INotifyPropertyChanged：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> INotifyPropertyChanged接口是.net内置的接口</span><br><span class="line"><span class="number">2.</span> 数据绑定会检测DataContext是否实现了INotifyPropertyChanged，若实现了，就会监听PropertyChanged得知属性发生变化</span><br><span class="line"><span class="number">3.</span> 若不用监听，则没必要实现INotifyPropertyChanged接口</span><br><span class="line"></span><br><span class="line">```C<span class="meta">#</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">INotifyPropertyChanged</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = <span class="keyword">value</span>;</span><br><span class="line">            <span class="comment">//若属性改变了，事件PropertyChanged会被对象发送出去</span></span><br><span class="line">            <span class="comment">//而数据绑定会时刻监听属性的变化，当对象属性变化时，数据绑定检测到事件PropertyChanged，界面层也会跟着一起变化</span></span><br><span class="line">            <span class="keyword">if</span>(PropertyChanged!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PropertyChanged(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(<span class="string">"Name"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="五、ListBox的数据绑定"><a href="#五、ListBox的数据绑定" class="headerlink" title="五、ListBox的数据绑定"></a>五、ListBox的数据绑定</h3><ol>
<li>可以使用ListBox和数据绑定来将List里的数据显示出来</li>
<li>ListBox显示集合用到的是ItemSource属性，不是DataContext</li>
<li>在XAML中可以设置ListBox的DisplayMemberPath属性来指定需要显示的源属性，默认是把每一个项的对象属性以tostring的形式显示。</li>
<li>在XAML中也可以设置ListBox的SelectedValuePath属性来指定绑定的源属性</li>
<li>SelectedItem获得的是选中行的对应对象,若没选中行就是null；SelectedValue获得的是选中行对应的对象的“SelectedValuePath标志的属性名”</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;ListBox DisplayMemberPath&#x3D;&quot;Name&quot; SelectedValuePath&#x3D;&quot;Age&quot; x:Name&#x3D;&quot;listboxperson&quot;\&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public partial class MainWindow : Window</span><br><span class="line">    &#123;</span><br><span class="line">        public MainWindow()</span><br><span class="line">        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        private void Window_Loaded(object sender, RoutedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Person&gt; list &#x3D; new List&lt;Person&gt;();</span><br><span class="line">            list.Add(new Person());</span><br><span class="line">            list.Add(new Person(&quot;苏坤&quot;, 20));</span><br><span class="line">            list.Add(new Person(false, 160, &quot;黄蓉&quot;, 16));</span><br><span class="line">            &#x2F;&#x2F;ListBox显示的集合是ItemSource属性，不是DataContext</span><br><span class="line">            listboxperson.ItemsSource &#x3D; list;</span><br><span class="line">        &#125;</span><br><span class="line">        private void Button_Click(object sender, RoutedEventArgs e)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;SelectedItem获得的是选中行的对应对象,若没选中行就是null</span><br><span class="line">            object sItem &#x3D; listboxperson.SelectedItem;</span><br><span class="line">            &#x2F;&#x2F;SelectedValue获得的是选中行对应的对象的“SelectedValuePath标志的属性名”</span><br><span class="line">            object sValue &#x3D; listboxperson.SelectedValue;</span><br><span class="line">            MessageBox.Show(sValue.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/2019/09/17/WPF%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/29.PNG" alt="ListBox"></p>
<h3 id="六、DataGrid"><a href="#六、DataGrid" class="headerlink" title="六、DataGrid"></a>六、DataGrid</h3><ol>
<li><p>&lt;DataGrid.Columes&gt;自定义列,跟Grid布局的自定义列类似</p>
</li>
<li><p>属性AutoGenerateColumns=”False”禁止自动创建列</p>
</li>
<li><p>每列可以设置IsReadOnly来禁止编辑；整个表格也可以在DataGrid中设置IsReadOnly来禁止编辑</p>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;DataGrid x:Name&#x3D;&quot;datagrid&quot; IsReadOnly&#x3D;&quot;True&quot; AutoGenerateColumns&#x3D;&quot;False&quot;&gt;</span><br><span class="line">    &lt;DataGrid.Columns&gt;</span><br><span class="line">        &lt;DataGridTextColumn Binding&#x3D;&quot;&#123;Binding Name&#125;&quot; Header&#x3D;&quot;姓&quot;&#x2F;&gt;</span><br><span class="line">        &lt;DataGridCheckBoxColumn Binding&#x3D;&quot;&#123;Binding Gender&#125;&quot; Header&#x3D;&quot;性别&quot;&#x2F;&gt;</span><br><span class="line">        &lt;DataGridTextColumn Binding&#x3D;&quot;&#123;Binding Age&#125;&quot; Header&#x3D;&quot;年龄&quot;&#x2F;&gt;</span><br><span class="line">        &lt;DataGridTextColumn Binding&#x3D;&quot;&#123;Binding Score&#125;&quot; Header&#x3D;&quot;分数&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;DataGrid.Columns&gt;</span><br><span class="line">&lt;&#x2F;DataGrid&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public partial class DataGridTest : Window</span><br><span class="line">&#123;</span><br><span class="line">    public DataGridTest()</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeComponent();</span><br><span class="line">    &#125;</span><br><span class="line">    private void Window_Loaded(object sender, RoutedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Student&gt; list &#x3D; new List&lt;Student&gt;();</span><br><span class="line">        list.Add(new Student &#123; Name &#x3D; &quot;小明&quot;, Age &#x3D; 18, Score &#x3D; 80, Gender &#x3D; true, Class &#x3D; &quot;一班&quot; &#125;);</span><br><span class="line">        list.Add(new Student &#123; Name &#x3D; &quot;小红&quot;, Age &#x3D; 25, Score &#x3D; 60, Gender &#x3D; false, Class &#x3D; &quot;二班&quot; &#125;);</span><br><span class="line">        list.Add(new Student &#123; Name &#x3D; &quot;小姐姐&quot;, Age &#x3D; 20, Score &#x3D; 100, Gender &#x3D; false, Class &#x3D; &quot;三班&quot; &#125;);</span><br><span class="line">        datagrid.ItemsSource &#x3D; list;</span><br><span class="line">        List&lt;string&gt; strlist &#x3D; new List&lt;string&gt;();</span><br><span class="line">        strlist.Add(&quot;一班&quot;);</span><br><span class="line">        strlist.Add(&quot;二班&quot;);</span><br><span class="line">        strlist.Add(&quot;三班&quot;);</span><br><span class="line">        classcc.ItemsSource &#x3D; strlist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img src="/2019/09/17/WPF%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/30.PNG" alt="DataGrid"></p>
<hr>
<p>参考资料：<a href="https://segmentfault.com/a/1190000012981745" target="_blank" rel="noopener">segmentfault</a></p>
]]></content>
      <categories>
        <category>-WPF</category>
      </categories>
      <tags>
        <tag>-C# -WPF</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF之属性赋值的方式</title>
    <url>/2019/09/22/WPF%E4%B9%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="属性-Value形式"><a href="#属性-Value形式" class="headerlink" title="属性=Value形式"></a>属性=Value形式</h3><ul>
<li>这种形式适用于对属性赋比较简单的值，例如Width=“100”或Height=“200”是xaml中属性赋值最常用的方式。比较复杂的赋值，如Path<br><code>&lt;Path Data=&quot;M 0,0 L 200,100 L 100,200 Z&quot; Fill=&quot;Red&quot; Stroke=&quot;Black&quot;/&gt;</code></li>
<li>可在窗口上画出一个红色的三角形</li>
</ul>
<p><img src="/2019/09/22/WPF%E4%B9%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F/34.PNG" alt="WPF"></p>
<h3 id="属性标签形式"><a href="#属性标签形式" class="headerlink" title="属性标签形式"></a>属性标签形式</h3><ul>
<li><p>我们能发现在对属性赋值时，赋的都是字符串，但其实很多控件的属性不是string类型的，那WPF如何把赋的字符串类型转换为相应的类型呢？答案就是重写TypeConverter中的方法</p>
</li>
<li><p>在.cs文件中声明一个Human类:</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class Human</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public Human Child &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后在.xaml文件中添加窗口资源，声明一个Human类:</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Window.Resources&gt;</span><br><span class="line">        &lt;local:Human x:Key&#x3D;&quot;human&quot; Name&#x3D;&quot;John&quot; Child&#x3D;&quot;Little John&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Window.Resources&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在这里Key是Human对象的索引值，当需要用到该对象时，可以用human使用此对象,后面可对human对象的属性进行赋值，由于Name属性本来就是string类型，所以直接赋值是合法的，但Child属性是Human类型，像上面那样赋值会报出类型转换的错误。想要解决这个问题就必须在.cs文件中重写类型转换方法，代码如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">[TypeConverterAttribute(typeof(NameToHumanTypeConverter))]</span><br><span class="line">public class Human</span><br><span class="line">&#123;</span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public Human Child &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NameToHumanTypeConverter : TypeConverter</span><br><span class="line">&#123;</span><br><span class="line">    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)</span><br><span class="line">    &#123;</span><br><span class="line">        string name &#x3D; value.ToString();</span><br><span class="line">        Human child &#x3D; new Human();</span><br><span class="line">        child.Name &#x3D; name;</span><br><span class="line">        return child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>声明一个类用来继承TypeConverter类，重写TypeConverter中的ConvertFrom方法，再使用类型转换器把该特性绑定到Human类上</li>
</ul>
<h3 id="标签扩展形式"><a href="#标签扩展形式" class="headerlink" title="标签扩展形式"></a>标签扩展形式</h3><ul>
<li>在xaml文件中，如果属性所要赋的值很复杂的话，可以把属性以一个闭合的形式把内容包括进来，例如，定义一个应用了渐变笔刷的长方形：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Rectangle Width&#x3D;&quot;200&quot; Height&#x3D;&quot;160&quot; Stroke&#x3D;&quot;Blue&quot;&gt;</span><br><span class="line">    &lt;Rectangle.Fill&gt;</span><br><span class="line">        &lt;LinearGradientBrush&gt;</span><br><span class="line">            &lt;LinearGradientBrush.StartPoint&gt;</span><br><span class="line">                &lt;Point X&#x3D;&quot;0&quot; Y&#x3D;&quot;0&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;LinearGradientBrush.StartPoint&gt;</span><br><span class="line">            &lt;LinearGradientBrush.EndPoint&gt;</span><br><span class="line">                &lt;Point X&#x3D;&quot;1&quot; Y&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;LinearGradientBrush.EndPoint&gt;</span><br><span class="line">            &lt;LinearGradientBrush.GradientStops&gt;</span><br><span class="line">                &lt;GradientStopCollection&gt;</span><br><span class="line">                    &lt;GradientStop Offset&#x3D;&quot;0.2&quot; Color&#x3D;&quot;LightBlue&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;GradientStop Offset&#x3D;&quot;0.7&quot; Color&#x3D;&quot;DarkBlue&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;GradientStop Offset&#x3D;&quot;1&quot; Color&#x3D;&quot;Blue&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;GradientStopCollection&gt;</span><br><span class="line">            &lt;&#x2F;LinearGradientBrush.GradientStops&gt;</span><br><span class="line">        &lt;&#x2F;LinearGradientBrush&gt;</span><br><span class="line">    &lt;&#x2F;Rectangle.Fill&gt;</span><br><span class="line">&lt;&#x2F;Rectangle&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>效果如下：</li>
</ul>
<p><img src="/2019/09/22/WPF%E4%B9%8B%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F/35.PNG" alt="WPF"></p>
<ul>
<li>该代码可以简化成如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Rectangle Width&#x3D;&quot;200&quot; Height&#x3D;&quot;160&quot; Stroke&#x3D;&quot;Blue&quot; RadiusY&#x3D;&quot;99.5&quot; RadiusX&#x3D;&quot;99.5&quot;&gt;</span><br><span class="line">    &lt;Rectangle.Fill&gt;</span><br><span class="line">        &lt;LinearGradientBrush StartPoint&#x3D;&quot;0,0&quot; EndPoint&#x3D;&quot;1,1&quot;&gt;</span><br><span class="line">            &lt;LinearGradientBrush.GradientStops&gt;</span><br><span class="line">                &lt;GradientStop Offset&#x3D;&quot;0.2&quot; Color&#x3D;&quot;LightBlue&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;GradientStop Offset&#x3D;&quot;0.7&quot; Color&#x3D;&quot;DarkBlue&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;GradientStop Offset&#x3D;&quot;1&quot; Color&#x3D;&quot;Blue&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;LinearGradientBrush.GradientStops&gt;</span><br><span class="line">        &lt;&#x2F;LinearGradientBrush&gt;</span><br><span class="line">    &lt;&#x2F;Rectangle.Fill&gt;</span><br><span class="line">&lt;&#x2F;Rectangle&gt;</span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li>参考资料：<a href="https://www.bilibili.com/video/av38367210/?p=7" target="_blank" rel="noopener">b站深入浅出WPF</a></li>
</ul>
]]></content>
      <categories>
        <category>-WPF</category>
      </categories>
      <tags>
        <tag>-WPF -C#</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF之资源的定义和使用</title>
    <url>/2019/09/28/WPF%E4%B9%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Resources和ResourceDictionary"><a href="#Resources和ResourceDictionary" class="headerlink" title="Resources和ResourceDictionary"></a>Resources和ResourceDictionary</h3><ol>
<li><p>Resources和ResourceDictionary简介</p>
<p> Resources这个属性是继承自FrameworkElement类的，所以在WPF界面上的元素有会有Resources这个属性。Resources的类型为ResourceDictionary，而ResourceDictionary能以键-值得形式存储资源，当需要用到某个资源时，可以使用键来访问资源对象。</p>
</li>
<li><p>定义Resources资源</p>
<p> ResourceDictionary可以存储任意类型的对象，例：在xaml代码中引用System命名空间中的string：</p>
</li>
<li><p>使用Resources资源</p>
<p> 可以在任意元素中使用“内容=”{修饰词 键}””的形式来引用资源，例：在TextBlock引用String资源</p>
</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;Window x:Class&#x3D;&quot;demo01DynamicResource.MainWindow&quot;</span><br><span class="line">    xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&#x2F;presentation&quot;</span><br><span class="line">    xmlns:x&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&quot;</span><br><span class="line">    xmlns:d&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;expression&#x2F;blend&#x2F;2008&quot;</span><br><span class="line">    xmlns:mc&#x3D;&quot;http:&#x2F;&#x2F;schemas.openxmlformats.org&#x2F;markup-compatibility&#x2F;2006&quot;</span><br><span class="line">    xmlns:sys&#x3D;&quot;clr-namespace:System;assembly&#x3D;mscorlib&quot;</span><br><span class="line">    mc:Ignorable&#x3D;&quot;d&quot;</span><br><span class="line">    Title&#x3D;&quot;MainWindow&quot; Height&#x3D;&quot;120&quot; Width&#x3D;&quot;200&quot;&gt;</span><br><span class="line">    &lt;Window.Resources&gt;</span><br><span class="line">        &lt;sys:String x:Key&#x3D;&quot;str1&quot;&gt;同是天涯沦落人&lt;&#x2F;sys:String&gt;</span><br><span class="line">        &lt;sys:String x:Key&#x3D;&quot;str2&quot;&gt;同是天涯沦落人&lt;&#x2F;sys:String&gt;</span><br><span class="line">    &lt;&#x2F;Window.Resources&gt;</span><br><span class="line">    &lt;StackPanel&gt;</span><br><span class="line">        &lt;TextBlock x:Name&#x3D;&quot;tb1&quot; Text&#x3D;&quot;&#123;StaticResource str1&#125;&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">        &lt;TextBlock x:Name&#x3D;&quot;tb2&quot; Text&#x3D;&quot;&#123;DynamicResource str2&#125;&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">        &lt;Button x:Name&#x3D;&quot;btn&quot; Content&#x3D;&quot;ChangeString&quot; Margin&#x3D;&quot;5&quot; Click&#x3D;&quot;Btn_Click&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;StackPanel&gt;</span><br><span class="line">&lt;&#x2F;Window&gt;</span><br></pre></td></tr></table></figure></div>

<p><img src="/2019/09/28/WPF%E4%B9%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/40.PNG" alt="WPF"></p>
<ul>
<li><p>补充：</p>
<p>  1、当某元素使用某资源时，它会从自身到上开始寻找资源，本例是从Text Block开始一直找到Window例的Resource后<br>  TextBlock才停止寻找，如果没有找到资源程序会直接抛出异常。<br>  2、如果Attribute和资源类型不匹配的话，也会抛出异常。<br>  4、如果想在C#代码中使用定义在xaml代码中的资源，可以这么写：使用FindResource(“键”)自上向下地寻找资源</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> text = (<span class="keyword">string</span>)<span class="keyword">this</span>.FindResource(<span class="string">"str"</span>);</span><br><span class="line"><span class="keyword">this</span>.tb1.Text = text;</span><br></pre></td></tr></table></figure></div>

<h3 id="StaticResource和DynamicResource"><a href="#StaticResource和DynamicResource" class="headerlink" title="StaticResource和DynamicResource"></a>StaticResource和DynamicResource</h3><ul>
<li>WPF提供了两种资源的修饰词：StaticResource和DynamicResource。Static指的是程序的非执行状态而Dynamic指的是程序的运行状态。静态资源使用指的是在程序载入内存时对资源一次性使用，之后就不会去访问这个资源；而动态资源使用指的是在程序运行过程中仍然会去访问这个资源，当资源改变时，使用动态资源的内容也会跟着一起改变，例：在xaml代码中定义StaticResource和DynamicResource</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;StackPanel x:Name&#x3D;&quot;sp&quot;&gt;</span><br><span class="line">    &lt;StackPanel.Resources&gt;</span><br><span class="line">        &lt;sys:String x:Key&#x3D;&quot;str1&quot;&gt;同是天涯沦落人&lt;&#x2F;sys:String&gt;</span><br><span class="line">        &lt;sys:String x:Key&#x3D;&quot;str2&quot;&gt;同是天涯沦落人&lt;&#x2F;sys:String&gt;</span><br><span class="line">    &lt;&#x2F;StackPanel.Resources&gt;</span><br><span class="line">    &lt;TextBlock x:Name&#x3D;&quot;tb1&quot; Text&#x3D;&quot;&#123;StaticResource str1&#125;&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">    &lt;TextBlock x:Name&#x3D;&quot;tb2&quot; Text&#x3D;&quot;&#123;DynamicResource str2&#125;&quot; Margin&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">    &lt;Button x:Name&#x3D;&quot;btn&quot; Content&#x3D;&quot;ChangeString&quot; Margin&#x3D;&quot;5&quot; Click&#x3D;&quot;Btn_Click&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;StackPanel&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在C#代码中改变资源，结果：tb1内容不变，tb2内容改变</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TextBlock使用StaticResource，所以当资源改变时，Text属性也不会跟着一起改变。</span></span><br><span class="line">sp.Resources[<span class="string">"str1"</span>] = <span class="string">"相逢何必曾相识"</span>;</span><br><span class="line"><span class="comment">//TextBlock使用DynamicResource，所以当资源改变时，Text属性也会跟着一起改变。</span></span><br><span class="line">sp.Resources[<span class="string">"str2"</span>] = <span class="string">"相逢何必曾相识"</span>;</span><br></pre></td></tr></table></figure></div>

<p><img src="/2019/09/28/WPF%E4%B9%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/41.PNG" alt="WPF"></p>
<p><img src="/2019/09/28/WPF%E4%B9%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/42.PNG" alt="WPF"></p>
<h3 id="在程序中添加二进制资源"><a href="#在程序中添加二进制资源" class="headerlink" title="在程序中添加二进制资源"></a>在程序中添加二进制资源</h3><ol>
<li><p>WPF资源：资源词典里的资源、&lt;xxx.Resources&gt;标签中的资源</p>
</li>
<li><p>程序集资源（二进制资源）：程序的内嵌资源</p>
</li>
<li><p>向程序中添加二进制资源的优点：能和程序自身打包在一起，不用担心资源会意外丢失（负作用就是应用程序体积会变大）</p>
</li>
<li><p>创建二进制资源：在解决方案的项目中找到Properties中的Resources.resx,可以在其中添加字符串、图片、图标、音频等的资源，然后在xaml代码或C#代码中调用，注意：为了能让xaml编译器访问到资源文件中的某个资源，必须把该资源的访问级别设置为Public。</p>
</li>
</ol>
<ul>
<li>在xaml代码中的调用创建的二进制资源：<br>  引用命名空间：xmlns:prop=”clr-namespace:demo02rpmResource.Properties”</li>
</ul>
<p><code>&lt;Label Content=&quot;{x:Static prop:Resources.UserName}&quot; FontSize=&quot;24&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt;</code></p>
<ul>
<li>首先，要引用Properties的命名空间，然后使用Content=”{x:Static prop:Resources.UserName}”调用资源文件中的字符串，该资源为二进制资源，若使用文件夹添加资源，可以在属性窗口中修改生成操作为Resource，这样它就是二进制资源了。</li>
</ul>
<p><img src="/2019/09/28/WPF%E4%B9%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/43.PNG" alt="WPF"></p>
<p><img src="/2019/09/28/WPF%E4%B9%8B%E8%B5%84%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8/44.PNG" alt="WPF"></p>
<hr>
<p>参考书籍：深入浅出WPF</p>
]]></content>
      <categories>
        <category>-WPF</category>
      </categories>
      <tags>
        <tag>-WPF -C#</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的使用</title>
    <url>/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="vim工作模式以及切换"><a href="#vim工作模式以及切换" class="headerlink" title="vim工作模式以及切换"></a>vim工作模式以及切换</h3><ul>
<li>vim有三种工作模式：命令模式、插入模式和编辑模式</li>
</ul>
<p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/13.PNG" alt="13"></p>
<hr>
<h3 id="vim插入命令"><a href="#vim插入命令" class="headerlink" title="vim插入命令"></a>vim插入命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/14.PNG" alt="13"></p>
<hr>
<h3 id="vim定位命令"><a href="#vim定位命令" class="headerlink" title="vim定位命令"></a>vim定位命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/15.PNG" alt="vim"></p>
<hr>
<h3 id="vim删除命令"><a href="#vim删除命令" class="headerlink" title="vim删除命令"></a>vim删除命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/16.PNG" alt="vim"></p>
<hr>
<h3 id="vim复制和剪切命令"><a href="#vim复制和剪切命令" class="headerlink" title="vim复制和剪切命令"></a>vim复制和剪切命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/17.PNG" alt="vim"></p>
<hr>
<h3 id="vim替换和取消命令"><a href="#vim替换和取消命令" class="headerlink" title="vim替换和取消命令"></a>vim替换和取消命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/18.png" alt="vim"></p>
<hr>
<h3 id="vim搜索和搜索替换命令"><a href="#vim搜索和搜索替换命令" class="headerlink" title="vim搜索和搜索替换命令"></a>vim搜索和搜索替换命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/19.PNG" alt="vim"></p>
<hr>
<h3 id="vim保存和退出命令"><a href="#vim保存和退出命令" class="headerlink" title="vim保存和退出命令"></a>vim保存和退出命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/20.PNG" alt="vim"></p>
<h3 id="导入命令和设置快捷键命令"><a href="#导入命令和设置快捷键命令" class="headerlink" title="导入命令和设置快捷键命令"></a>导入命令和设置快捷键命令</h3><p><img src="/2019/09/09/vim%E7%9A%84%E4%BD%BF%E7%94%A8/21.PNG" alt="vim"></p>
<hr>
<ul>
<li>参考资料：[B站](</li>
</ul>
]]></content>
      <categories>
        <category>-Linux</category>
      </categories>
      <tags>
        <tag>-Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket协议客户端和服务器websocket-sharp组件解析</title>
    <url>/2020/10/24/WebSocket%E5%8D%8F%E8%AE%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8websocket-sharp%E7%BB%84%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="websocket-sharp组件概述"><a href="#websocket-sharp组件概述" class="headerlink" title="websocket-sharp组件概述"></a>websocket-sharp组件概述</h3><ul>
<li>websocket-sharp是一个C#实现websocket协议客户端和服务端，websocket-sharp支持RFC 6455；WebSocket客户端和服务器；消息压缩扩展；安全连接；HTTP身份验证；查询字符串，起始标题和Cookie；通过HTTP代理服务器连接；.NET Framework 3.5或更高版本（包括兼容环境，如Mono）。</li>
<li>websocket-sharp是一个单一的组件，websocket-sharp.dll。websocket-sharp是用MonoDevelop开发的。所以建立一个简单的方式是打开websocket-sharp.sln并使用MonoDevelop中的任何构建配置（例如<code>Debug</code>）运行websocket-sharp项目的构建。</li>
<li>上面介绍了.NET项目中添加websocket-sharp组件，如果想向Unity项目中使用该DLL ，则应将其添加到Unity Editor中的项目的任何文件夹。在Unity的项目中，Unity Free有一些约束：Webplayer的安全沙箱（Web Player中不提供该服务器）；WebGL网络（ WebGL中不可用）；不适用于此类UWP；对System.IO.Compression的有限支持（压缩扩展在Windows上不可用）；iOS / Android的.NET Socket支持（如果您的Unity早于Unity 5，则需要iOS / Android Pro）；适用于iOS / Android的.NET API 2.0兼容级别。适用于iOS / Android的.NET API 2.0兼容性级别可能需要在.NET 2.0之后修复缺少某些功能，例如<code>System.Func&lt;...&gt;</code>代理（因此我已将其添加到该资产包中）。</li>
<li>如果是Core项目，则引用下面的包</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="XML"><figure class="iseeu highlight /xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"websocketsharp.core"</span> <span class="attr">Version</span>=<span class="string">"1.0.0"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="websocket-sharp组件使用方法"><a href="#websocket-sharp组件使用方法" class="headerlink" title="websocket-sharp组件使用方法"></a>websocket-sharp组件使用方法</h3><h4 id="WebSocket客户端"><a href="#WebSocket客户端" class="headerlink" title="WebSocket客户端"></a>WebSocket客户端</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> WebSocketSharp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">using</span> (<span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket (<span class="string">"ws://127.0.0.1:8081/Laputa"</span>)) &#123;</span><br><span class="line">        ws.OnMessage += (sender, e) =&gt;</span><br><span class="line">            Console.WriteLine (<span class="string">"Laputa says: "</span> + e.Data);</span><br><span class="line"></span><br><span class="line">        ws.Connect ();</span><br><span class="line">        ws.Send (<span class="string">"BALUS"</span>);</span><br><span class="line">        Console.ReadKey (<span class="literal">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>由上面的代码示例中，使用<code>WebSocket</code>WebSocket URL 创建类的新实例来连接。一个<code>WebSocket.OnOpen</code>当WebSocket连接已经建立发生的事件。<code>WebSocket.OnMessage</code>当发生事件<code>WebSocket</code>接收消息。一个<code>WebSocket.OnClose</code>当WebSocket的连接已关闭发生的事件。如果要异步连接到服务器，应该使用该<code>WebSocket.ConnectAsync ()</code>方法。可以使用<code>WebSocket.Send (string)</code>，<code>WebSocket.Send (byte[])</code>或<code>WebSocket.Send (System.IO.FileInfo)</code>方法来发送数据。如果您想要异步发送数据，则应该使用该<code>WebSocket.SendAsync</code>方法。如果要明确地关闭连接，应该使用该<code>WebSocket.Close</code>方法。</li>
</ul>
<h4 id="WebSocket服务器"><a href="#WebSocket服务器" class="headerlink" title="WebSocket服务器"></a>WebSocket服务器</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> WebSocketSharp;</span><br><span class="line"><span class="keyword">using</span> WebSocketSharp.Server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Laputa</span> : <span class="title">WebSocketBehavior</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnMessage</span> (<span class="params">MessageEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">var</span> msg = e.Data == <span class="string">"BALUS"</span></span><br><span class="line">                ? <span class="string">"I've been balused already..."</span></span><br><span class="line">                : <span class="string">"I'm not available now."</span>;</span><br><span class="line"></span><br><span class="line">      Send (msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span> (<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">      <span class="keyword">var</span> wssv = <span class="keyword">new</span> WebSocketServer (<span class="string">"ws://127.0.0.1:8081"</span>);</span><br><span class="line">      wssv.AddWebSocketService&lt;Laputa&gt; (<span class="string">"/Laputa"</span>);</span><br><span class="line">      wssv.Start ();</span><br><span class="line">      Console.ReadKey (<span class="literal">true</span>);</span><br><span class="line">      wssv.Stop ();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>以通过创建继承<code>WebSocketBehavior</code>该类的类定义任何WebSocket服务的行为。可以<code>WebSocketServer</code>通过使用<code>WebSocketServer.AddWebSocketService&lt;TBehaviorWithNew&gt; (string)</code>或<code>WebSocketServer.AddWebSocketService&lt;TBehavior&gt; (string, Func&lt;TBehavior&gt;)</code>方法将任何WebSocket服务添加到服务的指定行为和路径。wssv.Start ();启动WebSocket服务器。wssv.Stop (code, reason);停止WebSocket服务器。</li>
</ul>
<h4 id="消息压缩"><a href="#消息压缩" class="headerlink" title="消息压缩"></a>消息压缩</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">ws.Compression = CompressionMethod.Deflate;</span><br></pre></td></tr></table></figure></div>

<h4 id="HTTP身份验证"><a href="#HTTP身份验证" class="headerlink" title="HTTP身份验证"></a>HTTP身份验证</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line">ws.SetCredentials (<span class="string">"nobita"</span>, <span class="string">"password"</span>, preAuth);</span><br></pre></td></tr></table></figure></div>

<h4 id="通过HTTP代理服务器连接"><a href="#通过HTTP代理服务器连接" class="headerlink" title="通过HTTP代理服务器连接"></a>通过HTTP代理服务器连接</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket (<span class="string">"ws://example.com"</span>);</span><br><span class="line">ws.SetProxy (<span class="string">"http://localhost:3128"</span>, <span class="string">"nobita"</span>, <span class="string">"password"</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="websocket-sharp组件核心对象解析"><a href="#websocket-sharp组件核心对象解析" class="headerlink" title="websocket-sharp组件核心对象解析"></a>websocket-sharp组件核心对象解析</h3><h4 id="WebSocket-Send"><a href="#WebSocket-Send" class="headerlink" title="WebSocket.Send()"></a>WebSocket.Send()</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">send</span> (<span class="params">Opcode opcode, Stream stream</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">lock</span> (_forSend) &#123;</span><br><span class="line">        <span class="keyword">var</span> src = stream;</span><br><span class="line">        <span class="keyword">var</span> compressed = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">var</span> sent = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (_compression != CompressionMethod.None) &#123;</span><br><span class="line">                stream = stream.Compress (_compression);</span><br><span class="line">                compressed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sent = send (opcode, stream, compressed);</span><br><span class="line">            <span class="keyword">if</span> (!sent)</span><br><span class="line">                error (<span class="string">"A send has been interrupted."</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            _logger.Error (ex.ToString ());</span><br><span class="line">            error (<span class="string">"An error has occurred during a send."</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compressed)</span><br><span class="line">                stream.Dispose ();</span><br><span class="line">            src.Dispose ();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用WebSocket连接发送指定的数据，该方法存在多个重载版本，并且该方法也有异步实现。该方法返回一个布尔类型的参数，表示本次信息是否发送成功。该方法接受两个参数，Opcode是一个枚举类型，表示WebSocket框架类型。该枚举类型值有Cont(等于数值0.表示连续帧)，Text(相当于数值1.表示文本框)，Binary(相当于数值2.表示二进制帧)，Close(相当于数值8.表示连接关闭框架)，Ping(相当于数值9.表示ping帧)，Pong(相当于数值10.指示pong框)。stream表示一个流对象。该方法设置了锁操作，防止并发时出现死锁问题。不过看到代码中对异常的捕获还是有些问题，该方法是直接捕获exception异常，这样会导致程序捕获代码块中的所有异常，这样会影响代码的稳定性和代码的可修复性，异常捕获的最好处理方式是将程序进行恢复。</li>
</ul>
<h4 id="WebSocket-CloseAsync"><a href="#WebSocket-CloseAsync" class="headerlink" title="WebSocket.CloseAsync()"></a>WebSocket.CloseAsync()</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloseAsync</span> (<span class="params">CloseStatusCode code, <span class="keyword">string</span> reason</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">string</span> msg;</span><br><span class="line">    <span class="keyword">if</span> (!CheckParametersForClose (code, reason, _client, <span class="keyword">out</span> msg)) &#123;</span><br><span class="line">        _logger.Error (msg);</span><br><span class="line">        error (<span class="string">"An error has occurred in closing the connection."</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    closeAsync ((<span class="keyword">ushort</span>) code, reason);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>该方法以指定的方式异步关闭WebSocket连接，该方法接受两个参数，CloseStatusCode表示关闭原因的状态码，该参数是一个枚举类型。reason表示关闭的原因。大小必须是123字节或更少。if (!CheckParametersForClose (code, reason, _client, out msg))检查参数关闭。</li>
</ul>
<h4 id="WebSocket-createHandshakeRequest"><a href="#WebSocket-createHandshakeRequest" class="headerlink" title="WebSocket.createHandshakeRequest()"></a>WebSocket.createHandshakeRequest()</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HttpRequest <span class="title">createHandshakeRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = HttpRequest.CreateWebSocketRequest(_uri);</span><br><span class="line">    <span class="keyword">var</span> headers = ret.Headers;</span><br><span class="line">    <span class="keyword">if</span> (!_origin.IsNullOrEmpty())</span><br><span class="line">        headers[<span class="string">"Origin"</span>] = _origin;</span><br><span class="line">    headers[<span class="string">"Sec-WebSocket-Key"</span>] = _base64Key;</span><br><span class="line">    _protocolsRequested = _protocols != <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (_protocolsRequested)</span><br><span class="line">        headers[<span class="string">"Sec-WebSocket-Protocol"</span>] = _protocols.ToString(<span class="string">", "</span>);</span><br><span class="line">    _extensionsRequested = _compression != CompressionMethod.None;</span><br><span class="line">    <span class="keyword">if</span> (_extensionsRequested)</span><br><span class="line">        headers[<span class="string">"Sec-WebSocket-Extensions"</span>] = createExtensions();</span><br><span class="line">    headers[<span class="string">"Sec-WebSocket-Version"</span>] = _version;</span><br><span class="line">    AuthenticationResponse authRes = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (_authChallenge != <span class="literal">null</span> &amp;&amp; _credentials != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        authRes = <span class="keyword">new</span> AuthenticationResponse(_authChallenge, _credentials, _nonceCount);</span><br><span class="line">        _nonceCount = authRes.NonceCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_preAuth)</span><br><span class="line">    &#123;</span><br><span class="line">        authRes = <span class="keyword">new</span> AuthenticationResponse(_credentials);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (authRes != <span class="literal">null</span>)</span><br><span class="line">        headers[<span class="string">"Authorization"</span>] = authRes.ToString();</span><br><span class="line">    <span class="keyword">if</span> (_cookies.Count &gt; <span class="number">0</span>)</span><br><span class="line">        ret.SetCookies(_cookies);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>该方法用于客户端创建一个websocket请求，创建握手请求。var ret = HttpRequest.CreateWebSocketRequest(_uri);根据传入的uri调用HttpRequest的方法创建请求。该方法主要操作http头部信息，创建请求。</li>
</ul>
<hr>
<ul>
<li>转载自：<a href="https://www.cnblogs.com/pengze0902/p/6697192.html" target="_blank" rel="noopener">彭泽博客</a></li>
</ul>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C# -WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title>NetCore中的日志框架</title>
    <url>/2020/07/10/%C2%96NetCore%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h3 id="Logger的级别和日志的使用"><a href="#Logger的级别和日志的使用" class="headerlink" title="Logger的级别和日志的使用"></a>Logger的级别和日志的使用</h3><ul>
<li>级别从低到高分别是Trace，Debug，Information，Warning，Error，Critical，None，我们可以在配置文件中定义我们的配置级别</li>
<li>trace一般在定义组件的内部使用，记录详细的执行过程信息，用以暴露给组件使用者。</li>
<li>debug与trace很像，但一般仅在有调试意图的位置记录，且更多地是给组件的开发者自己查看。</li>
<li>info则是在业务场景、服务调用场景等更贴近业务实现部分的信息记录。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSON"><figure class="iseeu highlight /json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"Logging"</span>: &#123;</span><br><span class="line">    <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">      <span class="attr">"Default"</span>: <span class="string">"Debug"</span>,</span><br><span class="line">      <span class="attr">"Microsoft"</span>: <span class="string">"Warning"</span>,</span><br><span class="line">      <span class="attr">"Microsoft.Hosting.Lifetime"</span>: <span class="string">"Information"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Console"</span>: &#123;</span><br><span class="line">      <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">        <span class="attr">"Default"</span>: <span class="string">"Information"</span>,</span><br><span class="line">        <span class="attr">"Program"</span>: <span class="string">"Trace"</span>,</span><br><span class="line">        <span class="attr">"alogger"</span>: <span class="string">"Trace"</span>,</span><br><span class="line">        <span class="attr">"LoggingDemo.OrderService"</span>: <span class="string">"Trace"</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"Debug"</span>: &#123;</span><br><span class="line">      <span class="attr">"LogLevel"</span>: &#123;</span><br><span class="line">        <span class="attr">"Default"</span>: <span class="string">"Information"</span>,</span><br><span class="line">        <span class="attr">"Program"</span>: <span class="string">"Trace"</span>,</span><br><span class="line">        <span class="attr">"alogger"</span>: <span class="string">"Trace"</span>,</span><br><span class="line">        <span class="attr">"LoggingDemo.OrderService"</span>: <span class="string">"Trace"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用ILoggerFactory获取日志对象和日志的输出</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;从配置文件获取配置对象</span><br><span class="line">ConfigurationBuilder builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">var dir &#x3D; Path.GetFullPath(&quot;..&#x2F;..&#x2F;..&quot;);</span><br><span class="line">builder.AddJsonFile($&quot;&#123;dir&#125;&#x2F;appsettings.json&quot;, false, true);</span><br><span class="line">var configurationRoot &#x3D; builder.Build();</span><br><span class="line"></span><br><span class="line">IServiceCollection serviceCollection &#x3D; new ServiceCollection();</span><br><span class="line">&#x2F;&#x2F;用工厂模式将配置对象注册到容器中</span><br><span class="line">serviceCollection.AddSingleton&lt;IConfiguration&gt;(p &#x3D;&gt; configurationRoot);</span><br><span class="line">&#x2F;&#x2F;往容器中添加日志的配置，添加Logging节点、Console节点和Debug节点的配置信息</span><br><span class="line">serviceCollection.AddLogging(loggingBuilder &#x3D;&gt;</span><br><span class="line">                             &#123;</span><br><span class="line">                                 loggingBuilder.AddConfiguration(configurationRoot.GetSection(&quot;&quot;));</span><br><span class="line">                                 loggingBuilder.AddConsole();</span><br><span class="line">                                 loggingBuilder.AddDebug();</span><br><span class="line">                             &#125;);</span><br><span class="line">&#x2F;&#x2F;注册OrderService服务</span><br><span class="line">serviceCollection.AddTransient&lt;OrderService&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从容器中获取日志工厂，用loggerFactory来创建一个日志记录器</span><br><span class="line">IServiceProvider service &#x3D; serviceCollection.BuildServiceProvider();</span><br><span class="line">ILoggerFactory loggerFactory &#x3D; service.GetService&lt;ILoggerFactory&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出日志</span><br><span class="line">var alogger &#x3D; loggerFactory.CreateLogger(&quot;alogger&quot;);</span><br><span class="line">alogger.LogDebug(2001, &quot;alogger:Log from debug.&quot;);</span><br><span class="line">alogger.LogInformation(2001, &quot;alogger:Log from information.&quot;);</span><br><span class="line">alogger.LogError(2001, &quot;alogger:Log from error.&quot;);</span><br><span class="line">alogger.LogWarning(2001, &quot;alogger:Log from warning.&quot;);</span><br><span class="line">alogger.LogCritical(2001, &quot;alogger:Log from critical.&quot;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用ILogger获取日志对象</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在这里logger对象是通过构造函数注入的，这个日志对象的级别是在LoggingDemo.OrderService中定义的，即类的命名空间</span><br><span class="line">public class OrderService</span><br><span class="line">&#123;</span><br><span class="line">    private ILogger&lt;OrderService&gt; _logger;</span><br><span class="line"></span><br><span class="line">    public OrderService(ILogger&lt;OrderService&gt; logger)</span><br><span class="line">    &#123;</span><br><span class="line">        _logger &#x3D; logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Show()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;建议使用模板来组织我们的输出字符串，而不是用拼接字符串的形式</span><br><span class="line">        _logger.LogInformation(&quot;Show Time &#123;time&#125;&quot;, DateTime.Now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从容器中获取OrderService</span><br><span class="line">var order &#x3D; service.GetService&lt;OrderService&gt;();</span><br><span class="line">order.Show();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意，日志中要避免出现敏感信息，如密码、密钥等。</li>
</ul>
<h3 id="日志的作用域，解决不同请求间的日志干扰"><a href="#日志的作用域，解决不同请求间的日志干扰" class="headerlink" title="日志的作用域，解决不同请求间的日志干扰"></a>日志的作用域，解决不同请求间的日志干扰</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">var logger &#x3D; service.GetService&lt;ILogger&lt;Program&gt;&gt;();</span><br><span class="line">while (Console.ReadKey().Key!&#x3D;ConsoleKey.Escape)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;创建一个日志作用域，在该作用域范围内使用一个日志对象进行日志记录</span><br><span class="line">    &#x2F;&#x2F;BeginScope是用来标识作用域的，在实际使用时scopeId可以换成不同的Id</span><br><span class="line">    using (logger.BeginScope(&quot;ScopeId:&#123;scopeId&#125;&quot;, Guid.NewGuid()))</span><br><span class="line">    &#123;</span><br><span class="line">        logger.LogInformation(&quot;Info&quot;);</span><br><span class="line">        logger.LogError(&quot;Error&quot;);</span><br><span class="line">        logger.LogTrace(&quot;Trace&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.Sleep(100);</span><br><span class="line">    Console.WriteLine(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>在web中的Id</p>
<ol>
<li>requestId 表示当前请求的唯一标识，每此请求都会有一个id</li>
<li>traceId 表示当前请求链路的唯一标识，在例如，这个请求进来，然后这个服务会调用其它服务，则整个链路上的请求，都会携带这个相同的traceId</li>
<li>spanId，表示同一个请求链路上不同节点的标识。</li>
<li>traceId + spanId 可以实现分布式追踪。</li>
</ol>
</li>
<li><p>关于BeginScope，一般由框架调用，例如controller的action中，不需要些这些代码。<br>在设计自己的组件，也是类似的。</p>
</li>
</ul>
<h3 id="结构化日志组件Serilog"><a href="#结构化日志组件Serilog" class="headerlink" title="结构化日志组件Serilog"></a>结构化日志组件Serilog</h3><ul>
<li>使用结构化日志的好处：易于检索、易于分析统计</li>
<li>场景：日志告警、上下文关联、与追踪系统集成</li>
<li>使用Serilog</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取配置文件信息</span><br><span class="line">    public static IConfiguration Configuration &#123; get; &#125; &#x3D; new ConfigurationBuilder()</span><br><span class="line">        .SetBasePath(Directory.GetCurrentDirectory())</span><br><span class="line">        .AddJsonFile(&quot;appsettings.json&quot;, false, true)</span><br><span class="line">        .AddJsonFile($&quot;appsettings.&#123;Environment.GetEnvironmentVariable(&quot;ASPNETCORE_ENVIRONMENT&quot;) ?? &quot;Production&quot;&#125;.json&quot;, false, true)</span><br><span class="line">        .AddEnvironmentVariables()</span><br><span class="line">        .Build();</span><br><span class="line">    public static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;以json格式输出日志</span><br><span class="line">        &#x2F;&#x2F;Log.Logger &#x3D; new LoggerConfiguration().ReadFrom.Configuration(Configuration)</span><br><span class="line">        &#x2F;&#x2F;    .MinimumLevel.Debug()</span><br><span class="line">        &#x2F;&#x2F;    .Enrich.FromLogContext()</span><br><span class="line">        &#x2F;&#x2F;    .WriteTo.Console(new RenderedCompactJsonFormatter())</span><br><span class="line">        &#x2F;&#x2F;    .WriteTo.File(formatter: new CompactJsonFormatter(), &quot;logs\\myapp-json.txt&quot;,</span><br><span class="line">        &#x2F;&#x2F;        rollingInterval: RollingInterval.Day)</span><br><span class="line">        &#x2F;&#x2F;    .CreateLogger();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;以默认格式输出</span><br><span class="line">        Log.Logger &#x3D; new LoggerConfiguration().ReadFrom.Configuration(Configuration)</span><br><span class="line">            .MinimumLevel.Debug()</span><br><span class="line">            &#x2F;&#x2F;把Microsoft的日志级别重写成Information</span><br><span class="line">            .MinimumLevel.Override(&quot;Microsoft&quot;, LogEventLevel.Information)</span><br><span class="line">            .Enrich.FromLogContext()</span><br><span class="line">            .WriteTo.Console()</span><br><span class="line">            .WriteTo.File(Path.Combine(&quot;logs&quot;, @&quot;log.txt&quot;), rollingInterval: RollingInterval.Day)</span><br><span class="line">            .CreateLogger();</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Information(&quot;Starting web host&quot;);</span><br><span class="line">            CreateHostBuilder(args).Build().Run();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Fatal(e, &quot;Host terminated error&quot;);</span><br><span class="line">            Console.WriteLine(e);</span><br><span class="line">            throw;</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            Log.CloseAndFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">        Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">                                  &#123;</span><br><span class="line">                                      webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                                  &#125;)</span><br><span class="line">        .UseSerilog(dispose:true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-NetCore框架</category>
      </categories>
      <tags>
        <tag>-C# -NetCore</tag>
      </tags>
  </entry>
  <entry>
    <title>WPF之连接数据库和简单操作</title>
    <url>/2019/09/20/WPF%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="WPF之数据库的连接和简单操作"><a href="#WPF之数据库的连接和简单操作" class="headerlink" title="WPF之数据库的连接和简单操作"></a>WPF之数据库的连接和简单操作</h2><hr>
<h3 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h3><ul>
<li>如何创建SqlServer的用户和设置SqlServer的权限，可在文章[Qt连接SQL Server数据库]找到如何操作</li>
</ul>
<h3 id="SqlConnection"><a href="#SqlConnection" class="headerlink" title="SqlConnection"></a>SqlConnection</h3><ul>
<li>SqlConnection表示到SqlServer的打开连接，看如下代码</li>
</ul>
<p><code>SqlConnection conn = new SqlConnection(&quot;Server=.;Database=BookDB;user id=user_b;pwd=532133921&quot;)</code></p>
<ol>
<li><p>该代码实例化了一个SqlConnection类，则对象conn可以用来表示数据库对象。</p>
</li>
<li><p>各个参数的含义：</p>
<p> Server：表示连接的服务器，.表示连接本地的服务器。</p>
<p> DataBase：表示连接的数据库。</p>
<p> user id：表示连接的用户名；pwd：表示用户名的密码。</p>
</li>
<li><p>在创建完对象后，可以用conn.Open()语句来打开数据库。</p>
</li>
</ol>
<h3 id="SqlCommand"><a href="#SqlCommand" class="headerlink" title="SqlCommand"></a>SqlCommand</h3><ul>
<li>SqlCommand表示对SqlServer执行的一个Sql语句或存储过程，即对数据库的操作，看如下代码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">using (SqlCommand cmd &#x3D; conn.CreateCommand())</span><br><span class="line">&#123;</span><br><span class="line">    cmd.CommandText &#x3D; &quot;select * from S where _STATUS&#x3D;@STATUS&quot;;</span><br><span class="line">    cmd.Parameters.Add(new SqlParameter(&quot;@STATUS&quot;, 120));</span><br><span class="line">    string i &#x3D; (string)cmd.ExecuteScalar();</span><br><span class="line">    MessageBox.Show(i.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>首先获取数据库conn的SqlCommand，即SqlCommand cmd = conn.CreateCommand()。</p>
</li>
<li><p>对cmd的CommandText属性进行赋值，该属性表示要执行的C#Sql语句。</p>
</li>
<li><p>在cmd的Parameters属性中添加@参数，cmd.Parameters.Add(new SqlParameter(“@STATUS”, 120))，即当语句执行时@STATUS会换成120。</p>
</li>
<li><p>使用cmd的执行方法ExecuteXXX()来执行Sql语句，不同的执行方法会有不同的效果。</p>
</li>
</ol>
<h3 id="SqlDataReader"><a href="#SqlDataReader" class="headerlink" title="SqlDataReader"></a>SqlDataReader</h3><ul>
<li>SqlDataReader提供了一种从数据库读取行的只进流的方式。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">using (SqlDataReader reader &#x3D; cmd.ExecuteReader())</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;查询结果只放在数据库中,没传到客户端，</span><br><span class="line">    &#x2F;&#x2F;初始指针指向第一条数据之前，没调用一次Reader指针下移一条，直至最后一条退出循环</span><br><span class="line">    while (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;GetXXX(n)：n表示获取数据库表中的第n列</span><br><span class="line">        &#x2F;&#x2F;Console.WriteLine(reader.GetString(0)+reader.GetString(1)+reader.GetString(2));</span><br><span class="line">        Jlist.Add(new J(reader.GetString(0), reader.GetString(1), reader.GetString(2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>SqlDataReader reader = cmd.ExecuteReader()，当cmd中的Sql语句执行后返回了多行结果，则可用ExecuteReader方法执行并返回一个读取器，即reader是一个读取器，可以用来读取返回的结果</li>
</ul>
<h3 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h3><p><img src="/2019/09/20/WPF%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/31.PNG" alt="DataSet"></p>
<ul>
<li><p>SqlReader提供了一个不用把数据放在客户端的方式操作数据库，但当操作的数据量很少时，把数据放在数据库会增加数据库的负担，WPF提供了一个DataSet类用来存储数据库里的数据，减小数据库负担。</p>
</li>
<li><p>DataSet表示数据内存中的缓存</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">cmd.CommandText &#x3D; &quot;select * from S where _STATUS&#x3D;@STATUS&quot;;</span><br><span class="line">cmd.Parameters.Add(new SqlParameter(&quot;@STATUS&quot;, 120));</span><br><span class="line">&#x2F;&#x2F;SqlDataAdapter是一个帮我们把SqlCommand查询结果填充到DataSet</span><br><span class="line">SqlDataAdapter adapter &#x3D; new SqlDataAdapter(cmd);</span><br><span class="line">&#x2F;&#x2F;DataSet相当于项目中一个复杂集合</span><br><span class="line">DataSet data &#x3D; new DataSet();</span><br><span class="line">&#x2F;&#x2F;adapter.Fill相当于执行了sql语句和把查询结果填充到data中</span><br><span class="line">adapter.Fill(data);</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;导出data中的第一个查询结果表，一般也只有一个表</span><br><span class="line">&#x2F;&#x2F;DataTable table &#x3D; data.Tables[0];</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;定义一个集合存储表中的各行</span><br><span class="line">&#x2F;&#x2F;DataRowCollection rows &#x3D; table.Rows;</span><br><span class="line">&#x2F;&#x2F;也可以这么写</span><br><span class="line">DataRowCollection rows &#x3D; data.Tables[0].Rows;</span><br><span class="line">for (int i &#x3D; 0; i &lt; rows.Count; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    DataRow row &#x3D; rows[i];</span><br><span class="line">    string sno &#x3D; (string)row[&quot;SNO&quot;];</span><br><span class="line">    string sname &#x3D; (string)row[&quot;SNAME&quot;];</span><br><span class="line">    Int16 status &#x3D; (Int16)row[&quot;_STATUS&quot;];</span><br><span class="line">    MessageBox.Show(sno+&quot;,&quot;+sname+&quot;,&quot;+status.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><p>SqlDataAdapter adapter = new SqlDataAdapter(cmd);SqlDataAdapter类是专门用来填充DataSet并执行Sql语句的</p>
</li>
<li><p>adapter.Fill(data);将执行结果填充到DataSet变量中</p>
</li>
<li><p>在填充后，数据会被放在DataSet中的Table[]属性，Table[0]表示第一个表，一般也只有一个表；然后可以利用DataRowCollection来遍历此表</p>
</li>
</ol>
<h3 id="ConfigurationManager"><a href="#ConfigurationManager" class="headerlink" title="ConfigurationManager"></a>ConfigurationManager</h3><ul>
<li>当我们每一次连接数据库时，总是要写那一长串的连接信息，这样非常麻烦，用户也不易进行修改，则可以把连接信息写到App.config文件中，如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;connectionStrings&gt;</span><br><span class="line">      &lt;add name&#x3D;&quot;dbConnStr&quot; connectionString&#x3D;&quot;Server&#x3D;.;DataBase&#x3D;...;user id&#x3D;...;pwd&#x3D;...&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;connectionStrings&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>当你想要使用该配置信息时，可以创建ConfigurationManager对象来获取配置文件中的信息，即：（注意，ConfigurationManager需要引用System.Configuration程序集）</li>
</ul>
<p><code>private static string connStr = ConfigurationManager.ConnectionStrings[&quot;dbConnStr&quot;].ConnectionString;</code></p>
<ul>
<li>所以，你连接数据库时就可以这么写</li>
</ul>
<p><code>SqlConnection conn = new SqlConnection(connStr)</code></p>
<h3 id="SqlHelper"><a href="#SqlHelper" class="headerlink" title="SqlHelper"></a>SqlHelper</h3><ul>
<li>有时在写对数据库的操作时，总是要写一堆类似的执行语句代码，其实可以把对数据库的操作封装成一个类SqlHelper，如下</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class SqlHelper</span><br><span class="line">&#123;</span><br><span class="line">    private static string connStr &#x3D; ConfigurationManager.ConnectionStrings[&quot;dbConnStr&quot;].ConnectionString;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 连接并打开数据库，执行sql语句。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;sql&quot;&gt;sql语句的主部分&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;parameters&quot;&gt;sql语句的参数&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;受影响的行数&lt;&#x2F;returns&gt;</span><br><span class="line">    public static int ExecuteNonQuery(string sql, params SqlParameter[] parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        using (SqlConnection conn &#x3D; new SqlConnection(connStr))</span><br><span class="line">        &#123;</span><br><span class="line">            conn.Open();</span><br><span class="line">            using (SqlCommand cmd &#x3D; conn.CreateCommand())</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.CommandText &#x3D; sql;</span><br><span class="line">                cmd.Parameters.AddRange(parameters);</span><br><span class="line">                return cmd.ExecuteNonQuery();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 连接并打开数据库，执行sql语句。</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;sql&quot;&gt;sql语句的主部分&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;parameters&quot;&gt;sql语句的参数&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;受影响的对象&lt;&#x2F;returns&gt;</span><br><span class="line">    public static Object ExecuteScalar(string sql, params SqlParameter[] parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        using (SqlConnection conn &#x3D; new SqlConnection(connStr))</span><br><span class="line">        &#123;</span><br><span class="line">            conn.Open();</span><br><span class="line">            using (SqlCommand cmd &#x3D; conn.CreateCommand())</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.CommandText &#x3D; sql;</span><br><span class="line">                cmd.Parameters.AddRange(parameters);</span><br><span class="line">                return cmd.ExecuteScalar();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 连接并打开数据库，执行sql语句。（要求SQL语句是查询结果的语句）</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;sql&quot;&gt;sql语句的主部分&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;parameters&quot;&gt;sql语句的参数&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;查询结果的表结构&lt;&#x2F;returns&gt;</span><br><span class="line">    public static DataTable ExecuteDataTable(string sql, params SqlParameter[] parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        using (SqlConnection conn &#x3D; new SqlConnection(connStr))</span><br><span class="line">        &#123;</span><br><span class="line">            conn.Open();</span><br><span class="line">            using (SqlCommand cmd &#x3D; conn.CreateCommand())</span><br><span class="line">            &#123;</span><br><span class="line">                cmd.CommandText &#x3D; sql;</span><br><span class="line">                cmd.Parameters.AddRange(parameters);</span><br><span class="line">                SqlDataAdapter adapter &#x3D; new SqlDataAdapter(cmd);</span><br><span class="line">                DataSet dataset &#x3D; new DataSet();</span><br><span class="line">                adapter.Fill(dataset);</span><br><span class="line">                return dataset.Tables[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>参考资料：<a href="https://search.bilibili.com/all?keyword=wpf%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A&from_source=banner_search&spm_id_from=333.334.b_62616e6e65725f6c696e6b.1" target="_blank" rel="noopener">b站</a></p>
]]></content>
      <categories>
        <category>-WPF</category>
      </categories>
      <tags>
        <tag>-C# -WPF -SqlServer</tag>
      </tags>
  </entry>
  <entry>
    <title>NetCore中的选项框架</title>
    <url>/2020/07/10/%C2%96NetCore%E4%B8%AD%E7%9A%84%E9%80%89%E9%A1%B9%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="NetCore中的选项框架"><a href="#NetCore中的选项框架" class="headerlink" title="NetCore中的选项框架"></a>NetCore中的选项框架</h2><h3 id="服务组件依赖选项框架"><a href="#服务组件依赖选项框架" class="headerlink" title="服务组件依赖选项框架"></a>服务组件依赖选项框架</h3><ul>
<li><p>特性</p>
<ol>
<li>支持单例模式读取配置</li>
<li>支持快照</li>
<li>支持配置变更通知</li>
<li>支持运行时动态修改选项值</li>
</ol>
</li>
<li><p>在设计我们的系统时需要遵循两个原则</p>
<ol>
<li>接口分离原则（ISP），我们的类不应该依赖它不使用的配置</li>
<li>关注点分离（SOC），不同组件、服务、类之间的配置不应该相互依赖或耦合一般使用Option来作为服务的构造函数，有IOptions、IOptionsSnapshot、IOptionsMonitor</li>
</ol>
</li>
<li><p>定义服务的选项类OrderServiceOptions、服务的接口IOrderService和服务类OrderService，在这里OrderService服务依赖了OrderServiceOptions选项</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class OrderServiceOptions</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;最大订单数</span><br><span class="line">        public int MaxOrderCount &#123; get; set; &#125; &#x3D; 100;</span><br><span class="line">    &#125;</span><br><span class="line">    public class OrderService:IOrderService</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IOptions&lt;OrderServiceOptions&gt; _options;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 该服务依赖了OrderServiceOptions</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;options&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        public OrderService(IOptions&lt;OrderServiceOptions&gt; options)</span><br><span class="line">        &#123;</span><br><span class="line">            _options &#x3D; options;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 获取最大订单数</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">        public int ShowMaxOrderCount()</span><br><span class="line">        &#123;</span><br><span class="line">            return _options.Value.MaxOrderCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public interface IOrderService</span><br><span class="line">    &#123;</span><br><span class="line">        int ShowMaxOrderCount();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;StartUp.cs</span><br><span class="line">&#x2F;&#x2F;使用Configure方法绑定配置中的数据和Options的值，服务只依赖了OrderServiceOptions选项框架</span><br><span class="line">&#x2F;&#x2F;而并没有依赖我们的配置框架，也就是说服务只关注值是什么，它并不关心配置的值是从哪来的</span><br><span class="line">&#x2F;&#x2F;即OrderService依赖了OrderServiceOptions，而OrderServiceOptions中的值和appsettings.json文件中的值绑定</span><br><span class="line">services.Configure&lt;OrderServiceOptions&gt;(Configuration.GetSection(&quot;OrderService&quot;));</span><br><span class="line">services.AddSingleton&lt;IOrderService, OrderService&gt;();</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="选项数据的热更新"><a href="#选项数据的热更新" class="headerlink" title="选项数据的热更新"></a>选项数据的热更新</h3><ul>
<li>关键类型：<ol>
<li>IOption&lt;&gt;是单例的，它不跟踪配置更新，读不到更新后的值。</li>
<li>IOptionMonitor &lt;&gt;是单例的，它跟踪配置更新，总是读到最新的值。</li>
<li>IOptionSnapshot&lt;&gt;是范围的，它在范围的生命周期中，不会更新，但它会读到范围生命周期创建前的变更。</li>
</ol>
</li>
<li>使用IOptionsSnapshot进行热更新，还是之前的代码，只是将IOption换成IOptionsSnapshot，注意使用IOptionsSnapshot时，注册服务需要换成作用域模式</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">private readonly IOptionsSnapshot&lt;OrderServiceOptions&gt; _options;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 该服务依赖了OrderServiceOptions</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;options&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public OrderService(IOptionsSnapshot&lt;OrderServiceOptions&gt; options)</span><br><span class="line">&#123;</span><br><span class="line">    _options &#x3D; options;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;StartUp</span><br><span class="line">services.Configure&lt;OrderServiceOptions&gt;(Configuration.GetSection(&quot;OrderService&quot;));</span><br><span class="line">services.AddScoped&lt;IOrderService, OrderService&gt;();</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用IOptionsMonitor进行热更新和IOptionsSnapshot相同，但IOptionsMonitor可以适用于单例模式，而且在取值时用的是CurrentValue属性</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">private readonly IOptionsMonitor&lt;OrderServiceOptions&gt; _options;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 该服务依赖了OrderServiceOptions</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;options&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public OrderService(IOptionsMonitor&lt;OrderServiceOptions&gt; options)</span><br><span class="line">&#123;</span><br><span class="line">    _options &#x3D; options;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取最大订单数</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">public int ShowMaxOrderCount()</span><br><span class="line">&#123;</span><br><span class="line">    return _options.CurrentValue.MaxOrderCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>定义一个扩展方法来操作我们OrderService的注册，并在扩展方法中动态配置我们的选项对象</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public static class OrderServiceExtensions</span><br><span class="line">&#123;</span><br><span class="line">    public static IServiceCollection AddOrderServiceCollection(this IServiceCollection services,</span><br><span class="line">                                                               IConfiguration configuration)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;绑定配置中的数据和Options的值，服务只依赖了OrderServiceOptions选项框架</span><br><span class="line">        &#x2F;&#x2F;而并没有依赖我们的配置框架，也就是说服务只关注值是什么，它并不关心配置的值是从哪来的</span><br><span class="line">        services.Configure&lt;OrderServiceOptions&gt;(configuration.GetSection(&quot;OrderService&quot;));</span><br><span class="line">        &#x2F;&#x2F;动态配置我们的选项对象</span><br><span class="line">        services.PostConfigure&lt;OrderServiceOptions&gt;(opt &#x3D;&gt; &#123; opt.MaxOrderCount +&#x3D; 100; &#125;);</span><br><span class="line">        services.AddSingleton&lt;IOrderService, OrderService&gt;();</span><br><span class="line">        return services;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;StartUp</span><br><span class="line">services.AddOrderServiceCollection(Configuration);</span><br></pre></td></tr></table></figure></div>

<p>这样做的好处是，可以把StartUp类中的一些服务的注册给抽离出来，使得代码更有结构。</p>
</li>
</ul>
<h3 id="为选项数据添加验证"><a href="#为选项数据添加验证" class="headerlink" title="为选项数据添加验证"></a>为选项数据添加验证</h3><ul>
<li>直接注册验证函数</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;绑定选项并为选项添加验证逻辑Configure(opt &#x3D;&gt; &#123; configuration.GetSection(&quot;OrderService&quot;).Bind(opt); &#125;)就相当于上面那一句</span><br><span class="line">&#x2F;&#x2F;Validate(opt &#x3D;&gt; opt.MaxOrderCount &lt;&#x3D; 100);是用来添加验证，当MaxOrderCount小于等于100验证通过</span><br><span class="line">services.AddOptions&lt;OrderServiceOptions&gt;().Configure(opt &#x3D;&gt; &#123; configuration.GetSection(&quot;OrderService&quot;).Bind(opt); &#125;)</span><br><span class="line">    .Validate(opt &#x3D;&gt; opt.MaxOrderCount &lt;&#x3D; 100);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>实现DataAnnotations</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用属性验证的方式</span><br><span class="line">services.AddOptions&lt;OrderServiceOptions&gt;().Configure(opt &#x3D;&gt; &#123; configuration.GetSection(&quot;OrderService&quot;).Bind(opt); &#125;)</span><br><span class="line">    .ValidateDataAnnotations();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在验证的属性上添加验证特性，表示MaxOrderCount的值为1到100</span><br><span class="line">[Range(1, 100)]</span><br><span class="line">public int MaxOrderCount &#123; get; set; &#125; &#x3D; 100;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用IValidateOptions<TOptions></TOptions></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个验证类，实现IValidateOptions接口，该接口必需实现一个Validate方法，用来添加验证逻辑</span><br><span class="line">public class OrderServiceValidateOptions:IValidateOptions&lt;OrderServiceOptions&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        public ValidateOptionsResult Validate(string name, OrderServiceOptions options)</span><br><span class="line">        &#123;</span><br><span class="line">            if (options.MaxOrderCount&gt;100)</span><br><span class="line">            &#123;</span><br><span class="line">                return ValidateOptionsResult.Fail(&quot;MaxOrderCount不能大于100&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return ValidateOptionsResult.Success;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用实现接口验证的方式</span><br><span class="line">services.AddOptions&lt;OrderServiceOptions&gt;().Configure(opt &#x3D;&gt; &#123; configuration.GetSection(&quot;OrderService&quot;).Bind(opt); &#125;)</span><br><span class="line">    .Services.AddSingleton&lt;IValidateOptions&lt;OrderServiceOptions&gt;, OrderServiceValidateOptions&gt;();</span><br></pre></td></tr></table></figure></div>

<p>一般，当配置比较简单，且验证逻辑仅仅是对单个值的简单验证时，推荐DataAnnotations。</p>
<p>DataAnnotations不满足时，推荐验证函数，在设计组件的配置读取时推荐这种写法。</p>
<p>实现验证接口的方式，一般是验证逻辑较为复杂时，或验证逻辑依赖其它服务时。</p>
]]></content>
      <categories>
        <category>-NetCore框架</category>
      </categories>
      <tags>
        <tag>-C# -NetCore</tag>
      </tags>
  </entry>
  <entry>
    <title>React入门1</title>
    <url>/2020/07/10/%C2%96React%E5%85%A5%E9%97%A81/</url>
    <content><![CDATA[<h3 id="创建项目执行的命令"><a href="#创建项目执行的命令" class="headerlink" title="创建项目执行的命令"></a>创建项目执行的命令</h3><ul>
<li>npm install -g create-react-app</li>
<li>create-react-app [项目名称]</li>
<li>cd进项目文件</li>
<li>再执行npm start就可以启动react项目</li>
</ul>
<h3 id="jsx语法"><a href="#jsx语法" class="headerlink" title="jsx语法"></a>jsx语法</h3><ul>
<li>jsx语法就是js+xml的语法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//render是一个渲染函数</span></span><br><span class="line"><span class="comment">//第一个参数含义是要插入的元素</span></span><br><span class="line"><span class="comment">//第二个参数含义是插入的位置，在这里的位置是指public的index.html文件中id为root的元素</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>解读jsx语法：遇到&lt;&gt;按照html语法解析，遇到{}按照js语法解析，例如下面代码和上面的代码有一样的效果</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> react = <span class="string">"React"</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;react&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h3 id="React元素渲染"><a href="#React元素渲染" class="headerlink" title="React元素渲染"></a>React元素渲染</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在这段代码中定义了一个tick函数，然后使用setInterval设置每隔1秒调用tick函数</span></span><br><span class="line"><span class="comment">//tick调用则重新渲染了页面，这是react实时渲染的功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//在定义html标签变量时，需要用()括起来</span></span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello World!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/</span>h2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(element,</span></span><br><span class="line"><span class="regexp">    document.getElementById('root')</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">setInterval(tick, 1000);</span></span><br></pre></td></tr></table></figure></div>

<h3 id="React的组件"><a href="#React的组件" class="headerlink" title="React的组件"></a>React的组件</h3><ul>
<li>创建一个jsx文件，使用ES6的语法来创建一个类，使用类的形式来表示一个组件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类的形式创建组件，Hook形式</span></span><br><span class="line"><span class="comment">//组件类需要继承React.Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//渲染函数</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello React Component!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将App类暴露出去，让其他类可识别</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure></div>

<ul>
<li>再index.js中引入组件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./app"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入后使用标签为App的元素即可调用App类中的渲染函数</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure></div>

<ul>
<li>React项目都是由很多个组件组成的，所以组件在React中是很重要的。</li>
</ul>
<h3 id="porps属性"><a href="#porps属性" class="headerlink" title="porps属性"></a>porps属性</h3><ul>
<li>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"./home"</span></span><br><span class="line"><span class="keyword">import</span> MyNav <span class="keyword">from</span> <span class="string">"./MyNav"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类的形式创建组件，Hook形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">//渲染函数</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> nav1 = [<span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"C#"</span>]</span><br><span class="line">        <span class="keyword">const</span> nav2 = [<span class="string">"Python"</span>, <span class="string">"Go"</span>, <span class="string">"Java"</span>]</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Hello React Component!&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Home/</span>&gt;</span><br><span class="line">                &#123;<span class="comment">/* 在这里的MyNav元素为自定义组件，所以这里的nav和title</span></span><br><span class="line"><span class="comment">                属性转换为props对象传递给MyNav组件，MyNav组件再把属性值</span></span><br><span class="line"><span class="comment">                渲染到它的组件上，再把props传回到App组件中*/</span>&#125;</span><br><span class="line">                &lt;MyNav nav=&#123;nav1&#125; title=<span class="string">"语言1"</span>/&gt;</span><br><span class="line">                &lt;MyNav nav=&#123;nav2&#125; title=<span class="string">"语言2"</span>/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该组件接收唯一带有数据的props对象并返回一个React元素，这使一个类组件</span></span><br><span class="line"><span class="comment">//props在MyNav类中是只读的，不能修改</span></span><br><span class="line"><span class="comment">//然后使用jsx语法来渲染</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNav</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h3&gt;&#123;<span class="keyword">this</span>.props.title&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">                &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;</span></span><br><span class="line"><span class="regexp">                        this.props.nav.map((element, index)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                            return &lt;li key=&#123;index&#125;&gt;&#123;element&#125;&lt;/</span>li&gt;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数组件，效果和上面的类组件一样</span></span><br><span class="line"><span class="comment">/*function MyNav(props) &#123;</span></span><br><span class="line"><span class="comment">  return (</span></span><br><span class="line"><span class="comment">            &lt;div&gt;</span></span><br><span class="line"><span class="comment">                &lt;h3&gt;&#123;this.props.title&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">                &lt;ul&gt;</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        this.props.nav.map((element, index)=&gt;&#123;</span></span><br><span class="line"><span class="comment">                            return &lt;li key=&#123;index&#125;&gt;&#123;element&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">                        &#125;)</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">            &lt;/div&gt;</span></span><br><span class="line"><span class="comment">        )</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure></div>

<h3 id="组件的状态State"><a href="#组件的状态State" class="headerlink" title="组件的状态State"></a>组件的状态State</h3><ul>
<li>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件</li>
<li>当要设置State时，应调用setState方法进行设置</li>
<li>一般可以使用state来设置自定义组件的属性值，</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="React生命周期函数"><a href="#React生命周期函数" class="headerlink" title="React生命周期函数"></a>React生命周期函数</h3><ul>
<li>componentWillMount：在组件渲染之前执行</li>
<li>componentDidMount：在组件渲染之后执行</li>
<li>shouldComponentUpdate：返回true和false，true代表运行改变，false代表不允许</li>
<li>componentWillUpdate：数据在改变之前执行（）</li>
<li>componentDidUpdate：数据修改完成执行</li>
<li>componentWillReveiceProps：Props发生改变执行</li>
<li>componentWillUnmount：组件卸载前执行</li>
</ul>
<p><img src="/2020/07/10/%C2%96React%E5%85%A5%E9%97%A81/C:%5CUsers%5C14276%5CDocuments%5CComponentLifeTime.png" alt></p>
<ul>
<li>React中的子传父、父传子</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"./home"</span></span><br><span class="line"><span class="keyword">import</span> MyNav <span class="keyword">from</span> <span class="string">"./MyNav"</span></span><br><span class="line"><span class="keyword">import</span> StateComponent <span class="keyword">from</span> <span class="string">"./StateComponent"</span></span><br><span class="line"><span class="keyword">import</span> Clock <span class="keyword">from</span> <span class="string">"./clock"</span></span><br><span class="line"><span class="keyword">import</span> ComponentLife <span class="keyword">from</span> <span class="string">"./ComponentLife"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类的形式创建组件，Hook形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            title:<span class="string">"文本1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// changeHandler = ()=&gt;&#123;</span></span><br><span class="line">    <span class="comment">//     this.setState(</span></span><br><span class="line">    <span class="comment">//         &#123;title:"文本2"&#125;</span></span><br><span class="line">    <span class="comment">//     )</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    changeHandler1 = <span class="function">(<span class="params">text</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;<span class="attr">title</span>:text&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//渲染函数</span></span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> nav1 = [<span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"C#"</span>]</span><br><span class="line">        <span class="keyword">const</span> nav2 = [<span class="string">"Python"</span>, <span class="string">"Go"</span>, <span class="string">"Java"</span>]</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">                &lt;h1&gt;Hello React Component!&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">                &lt;Home/&gt;</span></span><br><span class="line"><span class="comment">                &lt;MyNav nav=&#123;nav1&#125; title="语言1"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;MyNav nav=&#123;nav2&#125; title="语言2"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;StateComponent/&gt;</span></span><br><span class="line"><span class="comment">                &lt;Clock /&gt;</span></span><br><span class="line"><span class="comment">                */</span>&#125;</span><br><span class="line">                &lt;ComponentLife title=&#123;<span class="keyword">this</span>.state.title&#125; changeHandler2=&#123;<span class="keyword">this</span>.changeHandler1&#125;/&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure></div>



<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentLife</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"componentWillMount"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"componentDidMount"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"shouldComponentUpdate"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"componentWillUpdate"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"componentDidUpdate"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"componentWillReceiveProps"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"componentWillUnmount"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    changeHandler = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            count:<span class="keyword">this</span>.state.count+=<span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    changeHandler1 = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.props.changeHandler2(<span class="string">'text2'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count &#125; = <span class="keyword">this</span>.state</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                LifeTime:&#123;count&#125; - &#123;<span class="keyword">this</span>.props.title&#125;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.changeHandler&#125;&gt;增加&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.changeHandler1&#125;&gt;修改title&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="setState更新是同步还是异步"><a href="#setState更新是同步还是异步" class="headerlink" title="setState更新是同步还是异步"></a>setState更新是同步还是异步</h3><ul>
<li>如果执行下面的代码，setState方法是同步的，当setState还没执行完时，console.log方法会被调用，所以会出现数据不一致的现象</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SetStateDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    increment = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;</span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                setState是同步还是异步</span><br><span class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.increment&#125;&gt;修改&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>处理这个问题有两种办法，第一种是使用React给定的解决方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把increment函数改成下面函数</span></span><br><span class="line"><span class="comment">//第二个参数lambda里的代码会等第一个参数执行完再执行</span></span><br><span class="line">increment = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;,()=&gt;&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>第二种是使用ES6的异步关键字(async/await)来解决</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> increment()&#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">this</span>.setStateAsync(</span><br><span class="line">            &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;)</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count);</span><br><span class="line">    &#125;</span><br><span class="line">    setStateAsync(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(state, resolve)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                setState是同步还是异步</span><br><span class="line">                &lt;p&gt;&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;this.increment.bind(this)&#125;&gt;修改&lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-React</category>
      </categories>
      <tags>
        <tag>-React -JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Windows上的Docker以配置文件的方式启动Redis</title>
    <url>/2020/09/23/%E5%A6%82%E4%BD%95%E5%9C%A8Windows%E4%B8%8A%E7%9A%84Docker%E4%BB%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%AF%E5%8A%A8Redis/</url>
    <content><![CDATA[<h3 id="创建Redis配置文件"><a href="#创建Redis配置文件" class="headerlink" title="创建Redis配置文件"></a>创建Redis配置文件</h3><ul>
<li>先从网上拷贝一份配置文件：<a href="https://raw.githubusercontent.com/antirez/redis/5.0/redis.conf" target="_blank" rel="noopener">https://raw.githubusercontent.com/antirez/redis/5.0/redis.conf</a></li>
<li>然后再自己的本地目录创建一个redis.config文件，将上面配置文件的内容拷贝到里面。</li>
<li>修改redis配置文件中的内容，这里对一些常用的配置选项进行说明：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">选项名</th>
<th align="center">作用</th>
<th align="center">可能取值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bind</td>
<td align="center">指定 redis 只接收来自于该IP地址的请求</td>
<td align="center">如果不进行设置，那么将处理所有请求</td>
</tr>
<tr>
<td align="center">port</td>
<td align="center">redis监听的端口号</td>
<td align="center">6379</td>
</tr>
<tr>
<td align="center">protected-mode</td>
<td align="center">是否开启保护模式，默认开启。要是配置里没有指定bind和密码，开启该参数后，redis只会本地进行访问， 拒绝外部访问。要是开启了密码和bind，可以开启。否则最好关闭</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">此参数为设置客户端空闲超过timeout，服务端会断开连接</td>
<td align="center">为0则服务端不会主动断开连接， 不能小于0</td>
</tr>
<tr>
<td align="center">daemonize</td>
<td align="center">是否在后台执行</td>
<td align="center">yes/no</td>
</tr>
<tr>
<td align="center">pidfile</td>
<td align="center">redis的进程文件</td>
<td align="center">/var/run/redis/redis.pid</td>
</tr>
<tr>
<td align="center">logfile</td>
<td align="center">指定了记录日志的文件。空字符串的话，日志会打印到标准输出设备。</td>
<td align="center">/usr/local/redis/var/redis.log</td>
</tr>
<tr>
<td align="center">loglevel</td>
<td align="center">指定了服务端日志的级别。级别包括：debug（很多信息，方便开发、测试），verbose（许多有用的信息， 但是没有debug级别信息多），notice（适当的日志级别，适合生产环境），warn（只有非常重要的信息）</td>
<td align="center">notice</td>
</tr>
<tr>
<td align="center">databases</td>
<td align="center">数据库的数量，默认使用的数据库是0。</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">save</td>
<td align="center">RDB核心规则配置 save &lt;指定时间间隔&gt; &lt;执行指定次数更新操作&gt;，满足条件就将内存中的数据同步到硬盘 中。官方出厂配置默认是 900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的 数据快照写入磁盘。若不想用RDB方案，可以把 save “” 的注释打开。</td>
<td align="center">save “” <br>save 900 1 <br>save 300 10 <br>save 60 10000</td>
</tr>
<tr>
<td align="center">stop-writes-on-bgsave-error</td>
<td align="center">当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通 过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">dir</td>
<td align="center">数据目录，数据库的写入会在这个目录。rdb、aof文件也会写在这个目录</td>
<td align="center">/usr/local/redis/var</td>
</tr>
<tr>
<td align="center">dbfilename</td>
<td align="center">指定本地数据库文件名，一般采用默认的 dump.rdb</td>
<td align="center">dump.rdb</td>
</tr>
<tr>
<td align="center">masterauth</td>
<td align="center">配置master的密码，这样可以在连上master后进行认证。</td>
<td align="center">123456</td>
</tr>
<tr>
<td align="center">requirepass</td>
<td align="center">配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。</td>
<td align="center">123456</td>
</tr>
<tr>
<td align="center">maxmemory</td>
<td align="center">配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区 是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些</td>
<td align="center">122000000</td>
</tr>
</tbody></table>
<ul>
<li>更多的配置在：<a href="https://blog.csdn.net/suprezheng/article/details/90679790" target="_blank" rel="noopener">https://blog.csdn.net/suprezheng/article/details/90679790</a></li>
</ul>
<h3 id="以配置文件的方式启动"><a href="#以配置文件的方式启动" class="headerlink" title="以配置文件的方式启动"></a>以配置文件的方式启动</h3><ul>
<li>假设我把redis的配置文件放在了<code>d:/Redis/redisDemo/redis.conf</code>下，使用-v选项进行挂载。</li>
<li>在配置文件中把port设置成了7000，用-p指定内外部的端口 。</li>
<li>用-d来指定镜像和redis-server指定使用配置文件的路径。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">docker --name redisDemo -v d:/Redis/redisDemo/redis.conf:/usr/local/etc/redis/redis.conf -p 7000:7000 -d redis redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure></div>

<ul>
<li>运行容器后，使用下面命令进入bash</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">docker exec -it redisDemo bash</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后需要修复集群的IP和端口为<code>127.0.0.1:7000</code></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster fix 127.0.0.1:7000</span><br></pre></td></tr></table></figure></div>

<ul>
<li>然后用下面命令就可以进入客户端使用了</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7000</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-Docker</category>
      </categories>
      <tags>
        <tag>-Docker -Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>React入门2</title>
    <url>/2020/07/10/%C2%96React%E5%85%A5%E9%97%A82/</url>
    <content><![CDATA[<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">IfDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 常见的场景：</span></span><br><span class="line"><span class="comment">     * 1、对视图条件进行切换</span></span><br><span class="line"><span class="comment">     * 2、做缺省值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            isLogin:<span class="literal">false</span>,</span><br><span class="line">            names:[<span class="string">"czk"</span>]</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clickHandler = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;</span><br><span class="line">                isLogin:<span class="keyword">this</span>.state.isLogin = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; names &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">let</span> showView = <span class="keyword">this</span>.state.isLogin ?</span><br><span class="line">        &lt;div&gt;登录成功&lt;<span class="regexp">/div&gt;:</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;请登录&lt;/</span>div&gt;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                条件渲染：&#123;showView&#125;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.clickHandler&#125;&gt;登录&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &#123;</span></span><br><span class="line"><span class="regexp">                    names.length&gt;0?</span></span><br><span class="line"><span class="regexp">                    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                    &#123;</span></span><br><span class="line"><span class="regexp">                        names.map((element, index)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                            return &lt;h1 key=&#123;index&#125;&gt;&#123;element&#125;&lt;/</span>h1&gt;</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                    &lt;<span class="regexp">/div&gt;:&lt;div&gt;请等待数据正在请求。。。&lt;/</span>div&gt;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="列表渲染-amp-Key"><a href="#列表渲染-amp-Key" class="headerlink" title="列表渲染&amp;Key"></a>列表渲染&amp;Key</h3><ul>
<li>在需要循环某字段创建标签时，可以使用map函数来创建，在循环时记住要把key属性加上去，因为在多次渲染的过程中，如果元素没有被改变（是依靠index来确定元素有没有改变），它是不会被重新渲染的，这可以提高渲染性能。如果不加key属性，则每次渲染都会全部重新渲染</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            userinfo:[</span><br><span class="line">                &#123;</span><br><span class="line">                    name:<span class="string">"Axl"</span>,</span><br><span class="line">                    age:<span class="number">18</span>,</span><br><span class="line">                    sex:<span class="string">"男"</span>,</span><br><span class="line">                    hobbies:[<span class="string">"打乒乓"</span>, <span class="string">"打篮球"</span>]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    name:<span class="string">"Czk"</span>,</span><br><span class="line">                    age:<span class="number">18</span>,</span><br><span class="line">                    sex:<span class="string">"男"</span>,</span><br><span class="line">                    hobbies:[<span class="string">"打乒乓"</span>, <span class="string">"打篮球"</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clickHandler = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;</span><br><span class="line">                userinfo:<span class="keyword">this</span>.state.userinfo.concat([&#123;</span><br><span class="line">                    name:<span class="string">"Sash"</span>,</span><br><span class="line">                    age:<span class="number">18</span>,</span><br><span class="line">                    sex:<span class="string">"女"</span>,</span><br><span class="line">                    hobbies:[</span><br><span class="line">                        <span class="string">"打乒乓"</span>, <span class="string">"打篮球"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;])</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;列表渲染&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div&gt;</span></span><br><span class="line"><span class="regexp">                    &lt;ul&gt;</span></span><br><span class="line"><span class="regexp">                        &#123;</span></span><br><span class="line"><span class="regexp">                            this.state.userinfo.map((element, index)=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                                return (</span></span><br><span class="line"><span class="regexp">                                    &lt;li key=&#123;index&#125;&gt;</span></span><br><span class="line"><span class="regexp">                                        &lt;span&gt;&#123;element.name&#125;&lt;/</span>span&gt;</span><br><span class="line">                                        &lt;span&gt;&#123;element.age&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                                        &lt;span&gt;&#123;element.sex&#125;&lt;/</span>span&gt;</span><br><span class="line">                                        &lt;div&gt;</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                element.hobbies.map(<span class="function">(<span class="params">element, index</span>)=&gt;</span>&#123;</span><br><span class="line">                                                    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;element&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">                                                &#125;)</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                                    &lt;/</span>li&gt;</span><br><span class="line">                                )</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.clickHandler&#125;&gt;添加数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="RefsAndDOM"><a href="#RefsAndDOM" class="headerlink" title="RefsAndDOM"></a>RefsAndDOM</h3><ul>
<li>受控组件，就是渲染的控件属性用的是state中的值</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="comment">//受控组件</span></span><br><span class="line"><span class="comment">//可以看到使用了state保存属性的值，在需要修改值的时候，需要使用setState函数来进行修改，这种方法修改值比较复杂，若控件不多的话，建议使用这种方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">FormDemo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            value:<span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleSubmit = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value)</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    changeHandler = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(</span><br><span class="line">            &#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value = e.target.value&#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"text"</span> value=&#123;<span class="keyword">this</span>.state.value&#125; onChange=&#123;<span class="keyword">this</span>.changeHandler&#125;/&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">                &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>非受控组件，就是控件的渲染使用了ref属性来渲染</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非受控组件</span></span><br><span class="line"><span class="comment">//这种方法改变值比较简单，不用写触发事件的函数</span></span><br><span class="line"><span class="comment">//在引用使用了ref属性的控件时，this.user.current就等价于&lt;input type="text" ref=&#123;this.username&#125;/&gt;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RefsForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="comment">//创建一个ref</span></span><br><span class="line">        <span class="keyword">this</span>.username = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    handleSubmit = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.username.current.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;form onSubmit = &#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.username&#125;/&gt;</span><br><span class="line">                &lt;input type=<span class="string">"submit"</span> value=<span class="string">"提交"</span>/&gt;</span><br><span class="line">            &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><ul>
<li>在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升”</li>
<li>首先，写一个判断水是否煮开了的组件</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">BoilingVerdict</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(props.celsius &gt;= <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The water would not boil.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建temperatureInput组件，用来封装输入</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scaleNames = &#123;</span><br><span class="line">    c: <span class="string">'Celsius'</span>,</span><br><span class="line">    f: <span class="string">'Fahrenheit'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TemperatureInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            temperature : <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(e)&#123;</span><br><span class="line">        <span class="keyword">this</span>.props.onTemperatureChange(e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> temperature = <span class="keyword">this</span>.props.temperature;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="keyword">this</span>.props.scale;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;fieldset&gt;</span><br><span class="line">                &lt;legend&gt;Enter temperature <span class="keyword">in</span> &#123;scaleNames[scale]&#125;:&lt;<span class="regexp">/legend&gt;</span></span><br><span class="line"><span class="regexp">                &lt;input value=&#123;temperature&#125; onChange = &#123;this.handleChange&#125;&gt;&lt;/i</span>nput&gt;</span><br><span class="line">                </span><br><span class="line">            &lt;<span class="regexp">/fieldset&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>再创建父组件Calculator，用来转换华/摄氏度</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> BoilingVerdict <span class="keyword">from</span> <span class="string">"./boilingVerdict"</span></span><br><span class="line"><span class="keyword">import</span> TemperatureInput <span class="keyword">from</span> <span class="string">"./temperatureInput"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.handleCelsiusChange = <span class="keyword">this</span>.handleCelsiusChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.handleFahrenheitChange = <span class="keyword">this</span>.handleFahrenheitChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            scale:<span class="string">'c'</span>, <span class="attr">temperature</span> : <span class="string">''</span> </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    handleCelsiusChange(temperature) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            scale: <span class="string">'c'</span>, </span><br><span class="line">            temperature:temperature</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleFahrenheitChange(temperature) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            scale: <span class="string">'f'</span>, </span><br><span class="line">            emperature:temperature</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">const</span> temperature = <span class="keyword">this</span>.state.temperature;</span><br><span class="line">        <span class="keyword">const</span> scale = <span class="keyword">this</span>.state.scale;</span><br><span class="line">        <span class="keyword">const</span> celsius = (scale === <span class="string">'f'</span> ? tryConvert(temperature, toCelsius) : temperature);</span><br><span class="line">        <span class="keyword">const</span> fahrenheit = (scale === <span class="string">'c'</span> ? tryConvert(temperature, toFahrenheit) : temperature);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;TemperatureInput</span><br><span class="line">                scale=<span class="string">"c"</span></span><br><span class="line">                temperature=&#123;celsius&#125;</span><br><span class="line">                onTemperatureChange=&#123;<span class="keyword">this</span>.handleCelsiusChange&#125; /&gt;</span><br><span class="line">                &lt;TemperatureInput</span><br><span class="line">                scale=<span class="string">"f"</span></span><br><span class="line">                temperature=&#123;fahrenheit&#125;</span><br><span class="line">                onTemperatureChange=&#123;<span class="keyword">this</span>.handleFahrenheitChange&#125; /&gt;</span><br><span class="line">                &lt;BoilingVerdict</span><br><span class="line">                celsius=&#123;<span class="built_in">parseFloat</span>(celsius)&#125; /&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function toCelsius(fahrenheit) &#123;</span></span><br><span class="line"><span class="regexp">    return (fahrenheit - 32) * 5 /</span> <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(<span class="params">celsius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (celsius * <span class="number">9</span> / <span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">temperature, convert</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> output = convert(input);</span><br><span class="line">    <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">return</span> rounded.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>整个状态提升的过程是这样的：<ol>
<li>在摄氏度输入框输入，触发handleChange函数，利用了props触发父组件中子组件的onTemperatureChange属性</li>
<li>调用了handleCelsiusChange，把父组件中的state对象重新赋值</li>
<li>此时父组件的渲染函数被重新调用，温度互相转换</li>
<li>最后通过props把转换后的温度传递到子组件中。</li>
<li>华氏度和摄氏度一样</li>
</ol>
</li>
</ul>
<h3 id="组合组件-amp-继承"><a href="#组合组件-amp-继承" class="headerlink" title="组合组件&amp;继承"></a>组合组件&amp;继承</h3><ul>
<li>在父组件中若子组件的内部包含了其他标签，则子组件可以使用<em>this</em>.props.children去引用它，比如：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Compose</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Compose:</span><br><span class="line">                &#123;<span class="comment">/* 这里的children就是Compose中的div */</span>&#125;</span><br><span class="line">                &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/父组件</span></span><br><span class="line"><span class="regexp">&lt;Compose&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        我是组合效果</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/Compose&gt;</span></span><br></pre></td></tr></table></figure></div>



<h3 id="类型验证"><a href="#类型验证" class="headerlink" title="类型验证"></a>类型验证</h3><ul>
<li><p>类型验证是React中子组件对组件传递过来的props对象中的数据进行验证</p>
</li>
<li><p>使用PropTypes进行类型验证：</p>
</li>
<li><p>先在子组件中引入PropTypes(import PropTypes from “prop-types”)</p>
</li>
<li><p>然后在子组件中创建类型验证：</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">PropsTypeValidation</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Hello：&#123;<span class="keyword">this</span>.props.title&#125;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/表示title为string类型，且为必需</span></span><br><span class="line"><span class="regexp">PropsTypeValidation.propType = &#123;</span></span><br><span class="line"><span class="regexp">    title:PropTypes.string.isRequired</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/为title设置默认值</span></span><br><span class="line"><span class="regexp">PropsTypeValidation.defaultProps = &#123;</span></span><br><span class="line"><span class="regexp">    title:"默认标题"</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>还有很多的验证方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JSX"><figure class="iseeu highlight /jsx"><table><tr><td class="code"><pre><span class="line">MyComponent.propTypes = &#123;</span><br><span class="line">  <span class="comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class="line">  <span class="comment">// 这些属性都是可选的。</span></span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.bool,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class="line">  <span class="comment">// (或 Fragment) 也包含这些类型。</span></span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素。</span></span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素类型（即，MyComponent）。</span></span><br><span class="line">  optionalElementType: PropTypes.elementType,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class="line">  <span class="comment">// JS 的 instanceof 操作符。</span></span><br><span class="line">  optionalMessage: PropTypes.instanceOf(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class="line">  <span class="comment">// 枚举类型。</span></span><br><span class="line">  optionalEnum: PropTypes.oneOf([<span class="string">'News'</span>, <span class="string">'Photos'</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class="line">  optionalUnion: PropTypes.oneOfType([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.instanceOf(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class="line">  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由某一类型的值组成</span></span><br><span class="line">  optionalObjectOf: PropTypes.objectOf(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由特定的类型值组成</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.shape(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// An object with warnings on extra properties</span></span><br><span class="line">  optionalObjectWithStrictShape: PropTypes.exact(&#123;</span><br><span class="line">    name: PropTypes.string,</span><br><span class="line">    quantity: PropTypes.number</span><br><span class="line">  &#125;),   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class="line">  <span class="comment">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任意类型的数据</span></span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class="line">  customProp: <span class="function"><span class="keyword">function</span>(<span class="params">props, propName, componentName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid prop `'</span> + propName + <span class="string">'` supplied to'</span> +</span><br><span class="line">        <span class="string">' `'</span> + componentName + <span class="string">'`. Validation failed.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class="line">  <span class="comment">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class="line">  <span class="comment">// 第一个是数组或对象本身</span></span><br><span class="line">  <span class="comment">// 第二个是他们当前的键。</span></span><br><span class="line">  customArrayProp: PropTypes.arrayOf(<span class="function"><span class="keyword">function</span>(<span class="params">propValue, key, componentName, location, propFullName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/matchme/</span>.test(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">'Invalid prop `'</span> + propFullName + <span class="string">'` supplied to'</span> +</span><br><span class="line">        <span class="string">' `'</span> + componentName + <span class="string">'`. Validation failed.'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>-React</category>
      </categories>
      <tags>
        <tag>-React -JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>理解OAuth2.0</title>
    <url>/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/</url>
    <content><![CDATA[<p><a href="http://en.wikipedia.org/wiki/OAuth" target="_blank" rel="noopener">OAuth</a>是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是2.0版。</p>
<p>本文对OAuth 2.0的设计思路和运行流程，做一个简明通俗的解释，主要参考材料为<a href="http://www.rfcreader.com/#rfc6749" target="_blank" rel="noopener">RFC 6749</a>。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051201.png" alt="OAuth Logo"></p>
<h2 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h2><p>为了理解OAuth的适用场合，让我举一个假设的例子。</p>
<p>有一个”云冲印”的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让”云冲印”读取自己储存在Google上的照片。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051202.png" alt="云冲印"></p>
<p>问题是只有得到用户的授权，Google才会同意”云冲印”读取这些照片。那么，”云冲印”怎样获得用户的授权呢？</p>
<p>传统方法是，用户将自己的Google用户名和密码，告诉”云冲印”，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。</p>
<blockquote>
<p>（1）”云冲印”为了后续的服务，会保存用户的密码，这样很不安全。</p>
<p>（2）Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。</p>
<p>（3）”云冲印”拥有了获取用户储存在Google所有资料的权力，用户没法限制”云冲印”获得授权的范围和有效期。</p>
<p>（4）用户只有修改密码，才能收回赋予”云冲印”的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。</p>
<p>（5）只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。</p>
</blockquote>
<p>OAuth就是为了解决上面这些问题而诞生的。</p>
<h2 id="二、名词定义"><a href="#二、名词定义" class="headerlink" title="二、名词定义"></a>二、名词定义</h2><p>在详细讲解OAuth 2.0之前，需要了解几个专用名词。它们对读懂后面的讲解，尤其是几张图，至关重要。</p>
<blockquote>
<p>（1） <strong>Third-party application</strong>：第三方应用程序，本文中又称”客户端”（client），即上一节例子中的”云冲印”。</p>
<p>（2）<strong>HTTP service</strong>：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</p>
<p>（3）<strong>Resource Owner</strong>：资源所有者，本文中又称”用户”（user）。</p>
<p>（4）<strong>User Agent</strong>：用户代理，本文中就是指浏览器。</p>
<p>（5）<strong>Authorization server</strong>：认证服务器，即服务提供商专门用来处理认证的服务器。</p>
<p>（6）<strong>Resource server</strong>：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</p>
</blockquote>
<p>知道了上面这些名词，就不难理解，OAuth的作用就是让”客户端”安全可控地获取”用户”的授权，与”服务商提供商”进行互动。</p>
<h2 id="三、OAuth的思路"><a href="#三、OAuth的思路" class="headerlink" title="三、OAuth的思路"></a>三、OAuth的思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。</p>
<p>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h2 id="四、运行流程"><a href="#四、运行流程" class="headerlink" title="四、运行流程"></a>四、运行流程</h2><p>OAuth 2.0的运行流程如下图，摘自RFC 6749。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051203.png" alt="OAuth运行流程"></p>
<blockquote>
<p>（A）用户打开客户端以后，客户端要求用户给予授权。</p>
<p>（B）用户同意给予客户端授权。</p>
<p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p>
<p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p>
<p>（E）客户端使用令牌，向资源服务器申请获取资源。</p>
<p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p>
</blockquote>
<p>不难看出来，上面六个步骤之中，B是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<p>下面一一讲解客户端获取授权的四种模式。</p>
<h2 id="五、客户端的授权模式"><a href="#五、客户端的授权模式" class="headerlink" title="五、客户端的授权模式"></a>五、客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h2 id="六、授权码模式"><a href="#六、授权码模式" class="headerlink" title="六、授权码模式"></a>六、授权码模式</h2><p>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051204.png" alt="授权码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户访问客户端，后者将前者导向认证服务器。</p>
<p>（B）用户选择是否给予客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p>
<p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p>
<p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="HTTP"><figure class="iseeu highlight /http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>C步骤中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure>
</blockquote>
<p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure>
</blockquote>
<p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">  "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。</p>
<h2 id="七、简化模式"><a href="#七、简化模式" class="headerlink" title="七、简化模式"></a>七、简化模式</h2><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051205.png" alt="简化模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端将用户导向认证服务器。</p>
<p>（B）用户决定是否给于客户端授权。</p>
<p>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。</p>
<p>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。</p>
<p>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。</p>
<p>（F）浏览器执行上一步获得的脚本，提取出令牌。</p>
<p>（G）浏览器将令牌发给客户端。</p>
</blockquote>
<p>下面是上面这些步骤所需要的参数。</p>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，此处的值固定为”token”，必选项。</li>
<li>client_id：表示客户端的ID，必选项。</li>
<li>redirect_uri：表示重定向的URI，可选项。</li>
<li>scope：表示权限范围，可选项。</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="HTTP"><figure class="iseeu highlight /http"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=token&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">    &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br></pre></td></tr></table></figure></div>
</blockquote>
<p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span>: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA</span><br><span class="line">          &amp;state=xyz&amp;token_type=example&amp;expires_in=3600</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在上面的例子中，认证服务器用HTTP头信息的Location栏，指定浏览器重定向的网址。注意，在这个网址的Hash部分包含了令牌。</p>
<p>根据上面的D步骤，下一步浏览器会访问Location指定的网址，但是Hash部分不会发送。接下来的E步骤，服务提供商的资源服务器发送过来的代码，会提取出Hash中的令牌。</p>
<h2 id="八、密码模式"><a href="#八、密码模式" class="headerlink" title="八、密码模式"></a>八、密码模式</h2><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p>
<p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051206.png" alt="密码模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）用户向客户端提供用户名和密码。</p>
<p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p>
<p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li>
<li>username：表示用户名，必选项。</li>
<li>password：表示用户的密码，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span><br></pre></td></tr></table></figure>
</blockquote>
<p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",</span><br><span class="line">  "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<p>整个过程中，客户端不得保存用户的密码。</p>
<h2 id="九、客户端模式"><a href="#九、客户端模式" class="headerlink" title="九、客户端模式"></a>九、客户端模式</h2><p>客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向”服务提供商”进行认证。严格地说，客户端模式并不属于OAuth框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求”服务提供商”提供服务，其实不存在授权问题。</p>
<p><img src="/2020/10/22/%E7%90%86%E8%A7%A3OAuth2-0/bg2014051207.png" alt="客户端模式"></p>
<p>它的步骤如下：</p>
<blockquote>
<p>（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。</p>
<p>（B）认证服务器确认无误后，向客户端提供访问令牌。</p>
</blockquote>
<p>A步骤中，客户端发出的HTTP请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示授权类型，此处的值固定为”client</em>credentials”，必选项。</li>
<li>scope：表示权限范围，可选项。</li>
</ul>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=client_credentials</span><br></pre></td></tr></table></figure>
</blockquote>
<p>认证服务器必须以某种方式，验证客户端身份。</p>
<p>B步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json;charset=UTF-8</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "access_token":"2YotnFZFEjr1zCsicMWpAA",</span><br><span class="line">  "token_type":"example",</span><br><span class="line">  "expires_in":3600,</span><br><span class="line">  "example_parameter":"example_value"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，各个参数的含义参见《授权码模式》一节。</p>
<h2 id="十、更新令牌"><a href="#十、更新令牌" class="headerlink" title="十、更新令牌"></a>十、更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。</p>
<p>客户端发出更新令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant<em>type：表示使用的授权模式，此处的值固定为”refresh</em>token”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>
<p>下面是一个例子。</p>
<blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/token</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Authorization</span>: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">grant_type=refresh_token&amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><a href="http://www.ruanyifeng.com/home.html" target="_blank" rel="noopener">阮一峰的网络日志</a></p>
]]></content>
      <categories>
        <category>-OAuth2.0</category>
      </categories>
      <tags>
        <tag>-OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>NetCore框架的配置</title>
    <url>/2020/07/10/%C2%96NetCore%E6%A1%86%E6%9E%B6%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="配置框架的核心组件包及核心类型"><a href="#配置框架的核心组件包及核心类型" class="headerlink" title="配置框架的核心组件包及核心类型"></a>配置框架的核心组件包及核心类型</h3><ul>
<li><p>核心组件包：</p>
<ol>
<li>Microsoft.Extensions.Configuration.Abstractions</li>
<li>Microsoft.Extensions.Configuration</li>
</ol>
</li>
<li><p>核心类型</p>
<ol>
<li>IConfiguration</li>
<li>IConfigurationRoot</li>
<li>IConfigurationSection</li>
<li>IConfigurationBuilder</li>
</ol>
</li>
<li><p>配置框架的扩展点</p>
<ol>
<li>IConfigurationSource</li>
<li>IConfigurationProvider</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用来构建数据源</span><br><span class="line">IConfigurationBuilder builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">&#x2F;&#x2F;定义了一个内存的数据配置源</span><br><span class="line">builder.AddInMemoryCollection(new Dictionary&lt;string, string&gt;</span><br><span class="line">                              &#123;</span><br><span class="line">                                  &#123;&quot;key1&quot;, &quot;value1&quot; &#125;,</span><br><span class="line">                                  &#123;&quot;key2&quot;, &quot;value2&quot; &#125;,</span><br><span class="line">                                  &#123;&quot;section1:key3&quot;, &quot;value3&quot; &#125;,</span><br><span class="line">                                  &#123;&quot;section2:section3:key4&quot;, &quot;value4&quot; &#125;</span><br><span class="line">                              &#125;);</span><br><span class="line">&#x2F;&#x2F;构建数据源</span><br><span class="line">IConfigurationRoot configurationRoot &#x3D; builder.Build();</span><br><span class="line">&#x2F;&#x2F;读取配置信息</span><br><span class="line">Console.WriteLine($&quot;key1:&#123;configurationRoot[&quot;key1&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;key2:&#123;configurationRoot[&quot;key2&quot;]&#125;&quot;);</span><br><span class="line">&#x2F;&#x2F;定义一个节点，用来读取value3</span><br><span class="line">IConfigurationSection section1 &#x3D; configurationRoot.GetSection(&quot;section1&quot;);</span><br><span class="line">Console.WriteLine($&quot;section1:key3:&#123;section1[&quot;key3&quot;]&#125;&quot;);</span><br><span class="line">&#x2F;&#x2F;嵌套节点</span><br><span class="line">IConfigurationSection section2 &#x3D; configurationRoot.GetSection(&quot;section2&quot;);</span><br><span class="line">var section3 &#x3D; section2.GetSection(&quot;section3&quot;);</span><br><span class="line">Console.WriteLine($&quot;section2:section3:key4:&#123;section3[&quot;key4&quot;]&#125;&quot;);</span><br></pre></td></tr></table></figure></div>

<h3 id="命令行配置提供程序"><a href="#命令行配置提供程序" class="headerlink" title="命令行配置提供程序"></a>命令行配置提供程序</h3><ul>
<li><p>支持的命令格式：</p>
<ol>
<li>无前缀的 key=value模式</li>
<li>双中横线模式 –key=value或 –key value</li>
<li>正斜杠模式 /key=value或/key value</li>
</ol>
<p>注意：等号连字符和空格连字符不能混用</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">var builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">&#x2F;&#x2F;builder.AddCommandLine(args);</span><br><span class="line"></span><br><span class="line">#region 命令替换</span><br><span class="line">&#x2F;&#x2F;将CommandLineKey2的value替换为-k2的value</span><br><span class="line">var mapper &#x3D; new Dictionary&lt;string, string&gt; &#123;&#123;&quot;-k2&quot;, &quot;CommandLineKey2&quot;&#125;&#125;;</span><br><span class="line">builder.AddCommandLine(args, mapper);</span><br><span class="line"></span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">var configurationRoot &#x3D; builder.Build();</span><br><span class="line">Console.WriteLine($&quot;CommandLineKey1:&#123;configurationRoot[&quot;CommandLineKey1&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;CommandLineKey2:&#123;configurationRoot[&quot;CommandLineKey2&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;CommandLineKey3:&#123;configurationRoot[&quot;CommandLineKey3&quot;]&#125;&quot;);</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure></div>

<h3 id="环境变量配置提供程序"><a href="#环境变量配置提供程序" class="headerlink" title="环境变量配置提供程序"></a>环境变量配置提供程序</h3><ul>
<li>该配置方式一般在Docker或K8s中使用，当AspNetCore需要一些内置的配置时也可使用</li>
<li>配置的分层键，”__”代替”:”，还支持根据前缀加载</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">var builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">builder.AddEnvironmentVariables();</span><br><span class="line"></span><br><span class="line">var configurationRoot &#x3D; builder.Build();</span><br><span class="line">Console.WriteLine($&quot;key1:&#123;configurationRoot[&quot;EnvironmentKey1&quot;]&#125;&quot;);</span><br><span class="line"></span><br><span class="line">#region 分层键</span><br><span class="line"></span><br><span class="line">var section1 &#x3D; configurationRoot.GetSection(&quot;Section1&quot;);</span><br><span class="line">Console.WriteLine($&quot;key3:&#123;section1[&quot;Key3&quot;]&#125;&quot;);</span><br><span class="line">var section2 &#x3D; configurationRoot.GetSection(&quot;Section1:Section2&quot;);</span><br><span class="line">Console.WriteLine($&quot;key4:&#123;section2[&quot;Key4&quot;]&#125;&quot;);</span><br><span class="line"></span><br><span class="line">#endregion</span><br><span class="line"></span><br><span class="line">#region 前缀过滤</span><br><span class="line"></span><br><span class="line">builder.AddEnvironmentVariables(&quot;Fre_&quot;);</span><br><span class="line">var configurationRoot2 &#x3D; builder.Build();</span><br><span class="line">Console.WriteLine($&quot;key5:&#123;configurationRoot2[&quot;key5&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;key6:&#123;configurationRoot2[&quot;key6&quot;]&#125;&quot;);</span><br><span class="line"></span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure></div>

<h3 id="文件配置提供程序"><a href="#文件配置提供程序" class="headerlink" title="文件配置提供程序"></a>文件配置提供程序</h3><ul>
<li>配置文件的类型有：ini，json，newtonsoftjson，xml，usersecrets</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">var builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">string dir &#x3D; Path.GetFullPath(&quot;..&#x2F;..&#x2F;..&quot;);</span><br><span class="line">&#x2F;&#x2F;optional参数为false时，当文件不存在时会报错，否则不会报错</span><br><span class="line">&#x2F;&#x2F;reloadOnChange参数为true时，表示在程序运行的过程中，修改文件会重新加载文件，否则不加载</span><br><span class="line">builder.AddJsonFile($&quot;&#123;dir&#125;&#x2F;appsettings.json&quot;, false, true);</span><br><span class="line"></span><br><span class="line">var configurationRoot &#x3D; builder.Build();</span><br><span class="line">Console.WriteLine($&quot;Key1:&#123;configurationRoot[&quot;Key1&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;Key2:&#123;configurationRoot[&quot;Key2&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;Key3:&#123;configurationRoot[&quot;Key3&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;Key4:&#123;configurationRoot[&quot;Key4&quot;]&#125;&quot;);</span><br><span class="line">Console.ReadKey();</span><br><span class="line">Console.WriteLine($&quot;Key1:&#123;configurationRoot[&quot;Key1&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;Key2:&#123;configurationRoot[&quot;Key2&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;Key3:&#123;configurationRoot[&quot;Key3&quot;]&#125;&quot;);</span><br><span class="line">Console.WriteLine($&quot;Key4:&#123;configurationRoot[&quot;Key4&quot;]&#125;&quot;);</span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#x2F;&#x2F;读取ini文件中的配置，后添加的配置文件会覆盖前面的配置文件，即ini文件会覆盖json文件</span><br><span class="line">builder.AddIniFile($&quot;&#123;dir&#125;&#x2F;appsettings.ini&quot;, false, true);</span><br><span class="line">var configurationRoot2 &#x3D; builder.Build();</span><br><span class="line">Console.WriteLine($&quot;Key1:&#123;configurationRoot2[&quot;Key1&quot;]&#125;&quot;);</span><br></pre></td></tr></table></figure></div>

<h3 id="配置变更监听"><a href="#配置变更监听" class="headerlink" title="配置变更监听"></a>配置变更监听</h3><ul>
<li>场景：1、需要记录配置源的变更时，2、需要在配置数据变更时触发特定操作时</li>
<li>GetReloadToken()、RegisterChangeCallback</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">var configurationRoot &#x3D; builder.Build();</span><br><span class="line">&#x2F;&#x2F;获取reloadtoken</span><br><span class="line">IChangeToken token &#x3D; configurationRoot.GetReloadToken();</span><br><span class="line">RegisterChangeCallback会监视configurationRoot中配置信息的变化，</span><br><span class="line">&#x2F;&#x2F;当配置信息变化时，该方法就会执行callback方法，但RegisterChangeCallback</span><br><span class="line">&#x2F;&#x2F;只会监听一次</span><br><span class="line">token.RegisterChangeCallback(state &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;Key1:&#123;configurationRoot[&quot;Key1&quot;]&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;Key2:&#123;configurationRoot[&quot;Key2&quot;]&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;Key3:&#123;configurationRoot[&quot;Key3&quot;]&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;Key4:&#123;configurationRoot[&quot;Key4&quot;]&#125;&quot;);</span><br><span class="line">&#125;, configurationRoot);</span><br></pre></td></tr></table></figure></div>



<ul>
<li>OnChange静态方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*OnChange方法的功能和RegisterChangeCallback一样，但它能监听多次变化</span><br><span class="line">*第一个参数为配置更新后如何获取reloadtoken，第二个参数是配置更新后执行的操作</span><br><span class="line">*&#x2F;</span><br><span class="line">ChangeToken.OnChange(() &#x3D;&gt; configurationRoot.GetReloadToken(), () &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine($&quot;Key1:&#123;configurationRoot[&quot;Key1&quot;]&#125;&quot;);</span><br><span class="line">                Console.WriteLine($&quot;Key2:&#123;configurationRoot[&quot;Key2&quot;]&#125;&quot;);</span><br><span class="line">                Console.WriteLine($&quot;Key3:&#123;configurationRoot[&quot;Key3&quot;]&#125;&quot;);</span><br><span class="line">                Console.WriteLine($&quot;Key4:&#123;configurationRoot[&quot;Key4&quot;]&#125;&quot;);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><ul>
<li>将配置值绑定到已有对象，使用Bind方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">        var dir &#x3D; Path.GetFullPath(&quot;..&#x2F;..&#x2F;..&quot;);</span><br><span class="line">        builder.AddJsonFile($&quot;&#123;dir&#125;&#x2F;appsettings.json&quot;, false);</span><br><span class="line"></span><br><span class="line">        var configurationRoot &#x3D; builder.Build();</span><br><span class="line">        var config &#x3D; new OrderConfig</span><br><span class="line">        &#123;</span><br><span class="line">            Key1 &#x3D; &quot;config key1&quot;,</span><br><span class="line">            Key2 &#x3D; &quot;config key2&quot;,</span><br><span class="line">            Key3 &#x3D; true</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;*使用bind方法可以把配置文件中的数据绑定到代码中具体的类中*&#x2F;</span><br><span class="line">             </span><br><span class="line">        configurationRoot.GetSection(&quot;OrderConfig&quot;).Bind(config);</span><br><span class="line">        Console.WriteLine($&quot;Key1:&#123;config.Key1&#125;&quot;);</span><br><span class="line">        Console.WriteLine($&quot;Key2:&#123;config.Key2&#125;&quot;);</span><br><span class="line">        Console.WriteLine($&quot;Key3:&#123;config.Key3&#125;&quot;);</span><br><span class="line">        Console.WriteLine($&quot;Key4:&#123;config.Key4&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OrderConfig</span><br><span class="line">&#123;</span><br><span class="line">    public string Key1 &#123; get; set; &#125;</span><br><span class="line">    public string Key2 &#123; get; set; &#125;</span><br><span class="line">    public bool Key3 &#123; get; set; &#125;</span><br><span class="line">    public int Key4 &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将配置值绑定到私有属性上，在bind方法中传入一个设置委托，如下</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">             * 若是set为私有的属性，可以在bind方法中把BindNonPublicProperties设置为true</span><br><span class="line">             * bind方法对没有set的属性是不生效的</span><br><span class="line">             *&#x2F;</span><br><span class="line">configurationRoot.GetSection(&quot;OrderConfig&quot;).Bind(config, opt &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                opt.BindNonPublicProperties &#x3D; true;</span><br><span class="line">            &#125;);</span><br><span class="line">class OrderConfig</span><br><span class="line">    &#123;</span><br><span class="line">        public string Key1 &#123; get; set; &#125;</span><br><span class="line">        public string Key2 &#123; get; set; &#125;</span><br><span class="line">        public bool Key3 &#123; get; set; &#125;</span><br><span class="line">    	&#x2F;&#x2F;把set设置为private</span><br><span class="line">        public int Key4 &#123; get; private set; &#125; &#x3D; 100;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="自定义配置数据源"><a href="#自定义配置数据源" class="headerlink" title="自定义配置数据源"></a>自定义配置数据源</h3><ul>
<li>定义配置的提供者MyConfigurationProvider，该自定义类既可以实现IConfigurationProvider接口，又可继承ConfigurationProvider这个抽象类，在这里我们选择继承ConfigurationProvider</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class MyConfigurationProvider : ConfigurationProvider</span><br><span class="line">&#123;</span><br><span class="line">    private Timer timer;</span><br><span class="line"></span><br><span class="line">    public MyConfigurationProvider()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;每隔3秒重新加载一下数据</span><br><span class="line">        timer &#x3D; new Timer();</span><br><span class="line">        timer.Elapsed +&#x3D; Time_Elapsed;</span><br><span class="line">        timer.Interval &#x3D; 3000;</span><br><span class="line">        timer.Start();</span><br><span class="line">    &#125;</span><br><span class="line">    public override void Load()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;框架初次加载数据</span><br><span class="line">        Load(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Time_Elapsed(object sender, ElapsedEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;重新加载数据</span><br><span class="line">        Load(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Load(bool reload)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;Data是ConfigurationProvider类提供的一个存储数据的集合,可用来存储配置信息</span><br><span class="line">        &#x2F;&#x2F;将最新时间填充到数据集合中</span><br><span class="line">        Data[&quot;lastTime&quot;] &#x3D; DateTime.Now.ToString();</span><br><span class="line">        if (reload)</span><br><span class="line">        &#123;</span><br><span class="line">            OnReload();</span><br><span class="line">        &#125;C#</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>定义配置的数据源MyConfigurationSource，该类实现了IConfigurationSource接口，并返回一个MyConfigurationProvider的实例</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public class MyConfigurationSource:IConfigurationSource</span><br><span class="line">&#123;</span><br><span class="line">    public IConfigurationProvider Build(IConfigurationBuilder builder)</span><br><span class="line">    &#123;</span><br><span class="line">        return new MyConfigurationProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>定义一个扩展方法，作为程序使用数据源的接口，这样做的目的是不会向外部暴露我们定义的数据源类</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">public static class MyConfigurationBuilderExtension</span><br><span class="line">&#123;</span><br><span class="line">    public static IConfigurationBuilder AddMyConfiguration(this IConfigurationBuilder builder)</span><br><span class="line">    &#123;</span><br><span class="line">        builder.Add(new MyConfigurationSource());</span><br><span class="line">        return builder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用自定义数据源</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="code"><pre><span class="line">var builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">builder.AddMyConfiguration();</span><br><span class="line">var configurationRoot &#x3D; builder.Build();</span><br><span class="line">&#x2F;&#x2F;该程序会每三秒打印一次最新的时间</span><br><span class="line">ChangeToken.OnChange(() &#x3D;&gt; configurationRoot.GetReloadToken(), () &#x3D;&gt;</span><br><span class="line">                     &#123;</span><br><span class="line">                         var lastTime &#x3D; configurationRoot[&quot;lastTime&quot;];</span><br><span class="line">                         Console.WriteLine($&quot;lastTime:&#123;lastTime&#125;&quot;);</span><br><span class="line">                     &#125;);</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>-NetCore框架</category>
      </categories>
      <tags>
        <tag>-C# -NetCore</tag>
      </tags>
  </entry>
  <entry>
    <title>真会C#?——协变、逆变、不变</title>
    <url>/2020/09/27/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%8D%8F%E5%8F%98%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E4%B8%8D%E5%8F%98/</url>
    <content><![CDATA[<h3 id="什么是协变、逆变、不变"><a href="#什么是协变、逆变、不变" class="headerlink" title="什么是协变、逆变、不变"></a>什么是协变、逆变、不变</h3><ul>
<li><code>Covariance</code>协变，当值作为返回值/out输出，例子：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">public interface IEnumerable&lt;out T&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Contravariance</code>逆变，当值作为参数/in输入，例子：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> Action&lt;<span class="keyword">in</span> T&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Invariance</code>不变，当值既是输入又是输出，例子：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">public interface IList&lt;T&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>下面有一个例子：这个例子的<code>string element = strings1[3];</code>语句会报错，若将<code>IList</code>类型的变量换成<code>IEnumerable</code>或跟<code>Action&lt;T&gt;</code>那样赋值就不会出错，因为<code>IEnumerable</code>的泛型只能作为输出，就不会出现从string-&gt;object转换的问题，而逆变和不变都会出现这个问题，但<code>IEnumerable</code>就会出现object-&gt;string转换问题。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * IEnumerable&lt;out T&gt;的泛型类型是作为返回值输出的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        IEnumerable&lt;<span class="keyword">string</span>&gt; strings = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;;</span><br><span class="line">        IEnumerable&lt;<span class="keyword">object</span>&gt; objects = strings;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * IList&lt;T&gt;的泛型类型是既作输入也作为输出的，</span></span><br><span class="line"><span class="comment">             * 这里的objects并不能隐式地转换为strings，因为这么做不是安全的，</span></span><br><span class="line"><span class="comment">             * 因为IList的元素是作为输入的，如果能做隐式转换，则代表可以用Add方法</span></span><br><span class="line"><span class="comment">             * 添加一个object，在执行strings[3]就存在向下转换的问题，它原本是一个</span></span><br><span class="line"><span class="comment">             * object，但被当成了一个string，这就导致了类型转换的安全问题,有可能会抛出</span></span><br><span class="line"><span class="comment">             * InvalidCastException异常。</span></span><br><span class="line"><span class="comment">             * 如果你确保你的输入是一个string，那就可以使用显式地把objects进行转换</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        IList&lt;<span class="keyword">string</span>&gt; strings1 = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt; &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;;</span><br><span class="line">        IList&lt;<span class="keyword">object</span>&gt; objects1 = (IList&lt;<span class="keyword">object</span>&gt;)strings;</span><br><span class="line">        objects1.Add(<span class="keyword">new</span> <span class="keyword">object</span>());</span><br><span class="line">        <span class="comment">//这里会抛出InvalidCastException异常，因为string[3]并不是一个字符串</span></span><br><span class="line">        <span class="keyword">string</span> element = strings1[<span class="number">3</span>];</span><br><span class="line">        Console.WriteLine(element);</span><br><span class="line">        <span class="keyword">object</span> o = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Action&lt;in T&gt;的泛型类型是作为参数输入的，</span></span><br><span class="line"><span class="comment">             * 由于string本身就是object，所以objAction能够很自然地转换为Action&lt;string&gt;类型</span></span><br><span class="line"><span class="comment">             * 而反过来则不行，因为object不一定就是string类型。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        Action&lt;<span class="keyword">object</span>&gt; objAction = obj =&gt; Console.WriteLine(obj);</span><br><span class="line">        Action&lt;<span class="keyword">string</span>&gt; strAction = objAction;</span><br><span class="line">        objAction(<span class="string">"Print me"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>variance只能出现在接口和委托里面</li>
</ul>
<h3 id="Variance转换"><a href="#Variance转换" class="headerlink" title="Variance转换"></a>Variance转换</h3><ul>
<li>Variance转换其实是引用转换的一个例子，引用转换是指，你无法改变其底层的值，只能改变编译时的类型。</li>
<li>本体转换：变量从一个类型转换到相同类型的变量</li>
</ul>
<h4 id="合理的转换"><a href="#合理的转换" class="headerlink" title="合理的转换"></a>合理的转换</h4><ul>
<li>如果是从A到B的转换是本体转换或者隐式引用转换，则从<code>IEnumerable&lt;A&gt;</code>到<code>IEnumerable&lt;B&gt;</code>的转换就是合理的：<ol>
<li>IEnumerable<string> to IEnumerable<object></object></string></li>
<li>IEnumerable<string> to IEnumerable<IConvertible></IConvertible></string></li>
<li>IEnumerable<IDisposable> to IEnumerable<object></object></IDisposable></li>
</ol>
</li>
</ul>
<h4 id="不合理的转换"><a href="#不合理的转换" class="headerlink" title="不合理的转换"></a>不合理的转换</h4><ul>
<li>不合理的转换：<ol>
<li>IEnumerable<object> to IEnumerable<string></string></object></li>
<li>IEnumerable<string> to IEnumerable<Stream></Stream></string></li>
<li>（装箱）IEnumerable<int> to IEnumerable<IConvertible></IConvertible></int></li>
<li>（数值转换）IEnumerable<int> to IEnumerable<long></long></int></li>
</ol>
</li>
</ul>
<h3 id="使用Linq进行转换"><a href="#使用Linq进行转换" class="headerlink" title="使用Linq进行转换"></a>使用Linq进行转换</h3><ul>
<li>在linq中可以使用Cast方法来对输出进行类型转换，也可以在末端加上输出类型的泛型。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">string</span>[] strings = &#123; <span class="string">"a"</span>, <span class="string">"ab"</span>, <span class="string">"abc"</span> &#125;;</span><br><span class="line">        List&lt;<span class="keyword">object</span>&gt; list1 = strings</span><br><span class="line">            .Where(x =&gt; x.Length &gt; <span class="number">1</span>)</span><br><span class="line">            .Cast&lt;<span class="keyword">object</span>&gt;()</span><br><span class="line">            .ToList();</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">object</span>&gt; list2 = strings</span><br><span class="line">            .Where(x =&gt; x.Length &gt; <span class="number">1</span>)</span><br><span class="line">            .ToList&lt;<span class="keyword">object</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>学习资料：[B站杨旭](</p>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C#</tag>
      </tags>
  </entry>
  <entry>
    <title>真会C#?——事件Event</title>
    <url>/2020/09/22/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6Event/</url>
    <content><![CDATA[<h3 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h3><ul>
<li>事件是一种使对象或类能够提供通知的成员，在C#中扮演了<code>使对象或类具备通知能力的成员</code>的角色，本质上是委托的包装器，比如：手机铃声响了，会通知你该起床了，这时，就可以说事件使手机具备了通知的能力。</li>
<li>事件的功能 = 通知 + 可选的事件参数，事件的事件参数使可选的，比如：手机邮件铃声响，这就通知你有一封邮件发送过来，而邮件就是通知携带的额外信息，即为事件参数（EventArgs）</li>
<li>而事件的功能就是<code>用于对象或类间的动作协调与信息传递</code>。</li>
</ul>
<h3 id="事件模型的组成部分"><a href="#事件模型的组成部分" class="headerlink" title="事件模型的组成部分"></a>事件模型的组成部分</h3><ul>
<li><p>事件模型的五个组成部分：</p>
<ol>
<li>事件的拥有者（eventsource，对象）。</li>
<li>事件成员（event，成员）。</li>
<li>事件的订阅者（event subscriber，对象）。</li>
<li>事件处理器（event handler，成员）——本质上是一个回调方法。</li>
<li>事件订阅——把事件处理器和事件关联在一起，本质上是一种以委托类型为基础的“约定”。</li>
</ol>
</li>
<li><p>事件模型中的五个动作：</p>
<ol>
<li>我拥有一个事件（事件字段）。</li>
<li>一个人或一群人关心我这个事件（订阅）。</li>
<li>我这个事件发生了（事件的触发）。</li>
<li>关心这个事件的人会被依次通知到（通知顺序和订阅顺序一致）。</li>
<li>被通知到的人根据拿到的事件信息（EventArgs或者通知本身）对事件进行响应（又称“处理事件”）。</li>
</ol>
</li>
<li><p>事件模型常见的四种形式：</p>
<ol>
<li>事件的拥有者和事件的订阅者无关联</li>
</ol>
<p><img src="/2020/09/22/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6Event/Snipaste_2020-09-22_09-45-04.png" alt="Snipaste_2020-09-22_09-45-04"></p>
<ol start="2">
<li>事件的拥有者是事件订阅者的一个成员</li>
</ol>
<p><img src="/2020/09/22/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6Event/Snipaste_2020-09-22_09-45-16.png" alt="Snipaste_2020-09-22_09-45-16"></p>
<ol start="3">
<li>事件的订阅者是事件拥有者的一个成员</li>
</ol>
<p><img src="/2020/09/22/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6Event/Snipaste_2020-09-22_09-45-23.png" alt="Snipaste_2020-09-22_09-45-23"></p>
<ol start="4">
<li>事件的拥有者同时也是事件的订阅者</li>
</ol>
<p><img src="/2020/09/22/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E4%BA%8B%E4%BB%B6Event/Snipaste_2020-09-22_09-45-31.png" alt="Snipaste_2020-09-22_09-45-31"></p>
</li>
</ul>
<h3 id="事件的四个形式的例子"><a href="#事件的四个形式的例子" class="headerlink" title="事件的四个形式的例子"></a>事件的四个形式的例子</h3><ul>
<li>事件的拥有者和事件的订阅者无关联</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Timers;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EventDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//事件的拥有者</span></span><br><span class="line">            Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">            <span class="comment">//timer时间间隔的长度，每过一秒钟就会触发一次事件</span></span><br><span class="line">            timer.Interval = <span class="number">1000</span>;</span><br><span class="line">            <span class="comment">//事件的订阅者</span></span><br><span class="line">            <span class="keyword">var</span> boy = <span class="keyword">new</span> Boy();</span><br><span class="line">            <span class="keyword">var</span> girl = <span class="keyword">new</span> Girl();</span><br><span class="line">            <span class="comment">//timer.Elapsed是Timer提供的事件成员，而+=操作就是事件的订阅</span></span><br><span class="line">            <span class="comment">//事件处理的顺序和订阅的顺序一致</span></span><br><span class="line">            timer.Elapsed += boy.Action;</span><br><span class="line">            timer.Elapsed += girl.Action;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//开启timer，使触发事件</span></span><br><span class="line">            timer.Start();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Boy</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//事件的处理器，事件和处理器之间必须遵循着一些约定，即委托的类型</span></span><br><span class="line">        <span class="comment">//这个委托类型是参数列表为下面列表的委托类型</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="keyword">object</span> sender, ElapsedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Jump!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Girl</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"><span class="keyword">object</span> sender, ElapsedEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sing!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>事件的拥有者是事件订阅者的一个成员，在这里需要手动引用<code>System.Windows.Forms</code>程序集</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EventDemo4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> form = <span class="keyword">new</span> MyForm();</span><br><span class="line">            form.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件的订阅者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> TextBox textBox;</span><br><span class="line">        <span class="comment">//事件的拥有者</span></span><br><span class="line">        <span class="keyword">private</span> Button button;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyForm</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            textBox = <span class="keyword">new</span> TextBox();</span><br><span class="line">            button = <span class="keyword">new</span> Button();</span><br><span class="line">            textBox.Width = <span class="number">1000</span>;</span><br><span class="line">            button.Text = <span class="string">"Say Hello"</span>;</span><br><span class="line">            button.Top = <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(button);</span><br><span class="line">            <span class="keyword">this</span>.Controls.Add(textBox);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//事件和订阅</span></span><br><span class="line">            <span class="keyword">this</span>.button.Click += <span class="keyword">this</span>.ButtonClicked;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理器</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ButtonClicked</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox.Text = <span class="string">"Hello World!!!!!!!!!!!!!!!!!!!!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>事件的拥有者同时也是事件的订阅者</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Windows.Forms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EventDemo3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> myForm = <span class="keyword">new</span> MyForm();</span><br><span class="line">            <span class="comment">//事件的拥有者同时也是事件的订阅者</span></span><br><span class="line">            myForm.Click += myForm.FormClicked;</span><br><span class="line">            myForm.ShowDialog();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyForm</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FormClicked</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.Text = DateTime.Now.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意：一个事件可以关联多个事件处理器，一个事件处理器可以关联多个事件</li>
</ul>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><h4 id="事件的完整自定义形式"><a href="#事件的完整自定义形式" class="headerlink" title="事件的完整自定义形式"></a>事件的完整自定义形式</h4><ul>
<li>下面例子模拟了客户进餐馆点餐这一个过程，这个过程一共由以下部分组成：<ol>
<li>顾客（事件的拥有者）——<code>Customer</code></li>
<li>订单（事件）——<code>Order</code></li>
<li>服务员（事件的订阅者/响应者）——<code>Waiter</code></li>
<li>对顾客的订单进行的响应（事件处理器）——<code>Waiter.Action</code></li>
<li>顾客喊来服务员进行点餐（事件的触发）——<code>Customer.Action</code></li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">WholeEventDefinition</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> customer = <span class="keyword">new</span> Customer();</span><br><span class="line">            <span class="keyword">var</span> waiter = <span class="keyword">new</span> Waiter();</span><br><span class="line">            <span class="comment">//订阅，这个订阅在这个例子中并不需要显式的表现出来，因为顾客和服务员本身就存在订单服务这样一种关系</span></span><br><span class="line">            customer.Order += waiter.Action;</span><br><span class="line">            customer.Action();</span><br><span class="line">            customer.PayTheBill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件参数，类名一般是事件名+EventArgs，需要派生于EventArgs这个基类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderEventArgs</span> :<span class="title">EventArgs</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> DishName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Size &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单事件处理器的委托类型，用来规范（约束）事件处理器，委托类型名一般是事件名+EventHandler</span></span><br><span class="line"><span class="comment">     * 第一个参数是事件的拥有者，也就是eventsource，第二个参数是携带的事件参数，</span></span><br><span class="line"><span class="comment">     * 在这里就是顾客要通知服务员说我要点餐，具体点什么餐，就可以放在OrderEventArgs对象里面</span></span><br><span class="line"><span class="comment">     * 另外，OrderEventHandler、OrderEventArgs和Customer三者的访问级别必须是在同级别的，</span></span><br><span class="line"><span class="comment">     * 因为它们一般是一起使用的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">OrderEventHandler</span>(<span class="params">Customer customer, OrderEventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事件的拥有者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//委托字段：用来存储或引用那些事件处理器</span></span><br><span class="line">        <span class="keyword">private</span> OrderEventHandler orderEventHandler;</span><br><span class="line">        <span class="comment">//事件字段：表示事件本身，使用orderEventHandler来和事件处理器产生关联</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">event</span> OrderEventHandler Order</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//事件处理器的添加器，当使用+=时触发</span></span><br><span class="line">            <span class="keyword">add</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHandler += <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//事件处理器的移除器，当使用-=时触发</span></span><br><span class="line">            <span class="keyword">remove</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> Bill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 支付订单</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayTheBill</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"I will pay $<span class="subst">&#123;<span class="keyword">this</span>.Bill&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WalkIn</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Walk into the restaurant"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SitDown</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Sit Down"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Let me think..."</span>);</span><br><span class="line">                Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若orderEventHandler不为null，含义就是根本没有订阅事件，也就不能触发事件的发生</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.orderEventHandler!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//准备事件参数</span></span><br><span class="line">                <span class="keyword">var</span> e = <span class="keyword">new</span> OrderEventArgs &#123;DishName = <span class="string">"KongPao Chicken"</span>, Size = <span class="string">"large"</span>&#125;;</span><br><span class="line">                <span class="keyword">this</span>.orderEventHandler.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">            <span class="keyword">this</span>.WalkIn();</span><br><span class="line">            <span class="keyword">this</span>.SitDown();</span><br><span class="line">            <span class="keyword">this</span>.Think();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件的订阅者</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Waiter</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//事件处理器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Action</span>(<span class="params">Customer customer, OrderEventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"I will serve you the dish - &#123;0&#125;"</span>, e.DishName);</span><br><span class="line">            <span class="keyword">double</span> price = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">switch</span> (e.Size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"small"</span>:</span><br><span class="line">                    price = price * <span class="number">0.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"large"</span>:</span><br><span class="line">                    price = price * <span class="number">1.5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            customer.Bill += price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="事件的简略自定义形式"><a href="#事件的简略自定义形式" class="headerlink" title="事件的简略自定义形式"></a>事件的简略自定义形式</h4><ul>
<li>可以将事件的定义简化成下面形式：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完整的定义</span></span><br><span class="line"><span class="keyword">private</span> OrderEventHandler orderEventHandler;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> OrderEventHandler Order</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.orderEventHandler += <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">remove</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.orderEventHandler -= <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简略的定义,这里的Order就包含了储存事件处理器的委托，</span></span><br><span class="line"><span class="comment"> * 这里看起来事件就是一种特殊的委托，但事件其实并不是委托</span></span><br><span class="line"><span class="comment"> * 它只是用来操作委托的一种类型，它只能进行+=和-=操作</span></span><br><span class="line"><span class="comment"> * 如果使用简略方式，则Order在类的内部既代表了委托也代表了事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> OrderEventHandler Order;</span><br></pre></td></tr></table></figure></div>

<h3 id="使用事件的好处"><a href="#使用事件的好处" class="headerlink" title="使用事件的好处"></a>使用事件的好处</h3><ul>
<li>可以看到其实事件并不是必须的了，因为事件可以做的事情委托也可以做，根本就不需要多此一举来定义事件，那为什么要使用事件呢？<ol>
<li>如果使用public的委托字段来进行订阅和调用，那类的内外部都可以对委托字段进行访问，而且委托字段拥有对事件处理器的完全访问权，这样就有可能在类的外部滥用委托字段，从而导致代码的混乱</li>
<li>使用event的好处是event在类的内外部的操作权限是不一致的，在类的内部它对委托字段拥有完全的访问权，而在类的外部它只能对类内部的委托字段进行+=和-=操作，即订阅和删除订阅操作，这样就保证了类内部的委托字段不会在外部随意地操作，保证委托字段地安全性。</li>
<li>事件的触发必须由事件的拥有者进行调用，这就避免了外部对其进行一些非法操作。</li>
</ol>
</li>
</ul>
<h3 id="事件的触发"><a href="#事件的触发" class="headerlink" title="事件的触发"></a>事件的触发</h3><ul>
<li>触发事件的方法一般命名为On+事件名，访问级别为protected，不能为public。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Let me think..."</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.Order != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="keyword">new</span> OrderEventArgs &#123;DishName = <span class="string">"KongPao Chicken"</span>, Size = <span class="string">"large"</span>&#125;;</span><br><span class="line">        <span class="keyword">this</span>.Order.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的代码可以改成下面形式</span></span><br><span class="line"><span class="comment">/**********************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Think</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"Let me think..."</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若orderEventHandler不为null，含义就是根本没有订阅事件，也就不能触发事件的发生</span></span><br><span class="line">    OnOrder(<span class="string">"GongPao Chicken"</span>, <span class="string">"large"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">OnOrder</span>(<span class="params"><span class="keyword">string</span> dishName, <span class="keyword">string</span> size</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.Order != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//准备事件参数</span></span><br><span class="line">        <span class="keyword">var</span> e = <span class="keyword">new</span> OrderEventArgs &#123; DishName = dishName, Size = size &#125;;</span><br><span class="line">        <span class="keyword">this</span>.Order.Invoke(<span class="keyword">this</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV13b411b7Ht?p=23" target="_blank" rel="noopener">B站刘铁猛</a></p>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C#</tag>
      </tags>
  </entry>
  <entry>
    <title>真会C#?——委托</title>
    <url>/2020/09/18/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<h3 id="委托简介"><a href="#委托简介" class="headerlink" title="委托简介"></a>委托简介</h3><h4 id="什么是委托"><a href="#什么是委托" class="headerlink" title="什么是委托"></a>什么是委托</h4><ul>
<li><em>C#</em> 中<em>的委托</em>(Delegate)类似于 C 或 C++ 中函数的指针。它是一个对象，他知道该如何调用一个方法，其实它就是一个方法的包装器或引用变量。</li>
</ul>
<h4 id="定义委托"><a href="#定义委托" class="headerlink" title="定义委托"></a>定义委托</h4><ul>
<li>委托类型：委托类型定义了委托实例可以调用的那类方法，即定义了方法的返回类型和参数类列表</li>
<li>所有的委托类型都派生于<code>System.MuticastDelegate</code>，而它又派生于<code>System.Delegate</code></li>
<li>委托实例：把方法赋值给委托变量时就创建了委托实例</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 委托类型：使用delegate关键字进行定义</span></span><br><span class="line"><span class="comment">         * 这里定义了委托可以调用的方法的返回类型和参数列表</span></span><br><span class="line"><span class="comment">         * delegate [返回类型] [委托类型名称(跟类名一样)]([参数列表]);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">Transformer</span>(<span class="params"><span class="keyword">int</span> x</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 委托实例：用方法的引用来实例化一个Transformer类型的委托</span></span><br><span class="line"><span class="comment">             * 这个其实跟类的实例化没什么差别，就是用来实例化委托的对象是方法的引用</span></span><br><span class="line"><span class="comment">             * [委托名称] t = new [委托名称]([方法名称]);这时t委托实例就拥有了Square方法调用的权力</span></span><br><span class="line"><span class="comment">             * 简写：[委托名称] t = [方法名称];</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        Transformer t = Square;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 使用委托实例来调用方法，这跟Square(3)的效果是一样的</span></span><br><span class="line"><span class="comment">             * [委托实例].Invoke([蚕食列表]);</span></span><br><span class="line"><span class="comment">             * 简写：[委托实例]([蚕食列表]);</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">var</span> result = t(<span class="number">3</span>);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Square</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="委托的好处"><a href="#委托的好处" class="headerlink" title="委托的好处"></a>委托的好处</h4><ul>
<li>委托实例其实就是调用者的委托：调用者调用委托，再由委托调用目标方法。这样做的好处就是把调用者和目标方法解耦合了，使用delegate能很容易地写出经典的设计模式。下面有一个列子：在调用者和目标函数中间加入了中间层，可以使用这个中间层对目标方法进行增强，这就是适配器设计模式（类似于插件）。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">Transformer</span>(<span class="params"><span class="keyword">int</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Util</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Transform</span>(<span class="params"><span class="keyword">int</span>[] values, Transformer t</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                values[i] = t(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DelegateDemo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Square</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; x * x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DelegateDemo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Util.Transform(values, Square);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> values)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;<span class="keyword">value</span>&#125;</span>"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h3><ul>
<li>一个委托实例可以引用一组目标方法，所有的委托实例都具有多播的功能。</li>
<li>使用<code>+</code>或<code>+=</code>操作符就可以合并委托实例，合并后调用就会顺序地调用各个委托实例委托的方法，调用的顺序跟合并的顺序一致。</li>
<li>使用<code>-</code>或<code>-=</code>操作访可以移除合并的委托实例。</li>
<li>C#会把这些操作符编译成<code>System.Delegate</code>中的<code>Combine</code>和<code>Remove</code>两个静态方法</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> <span class="title">Transformer</span>(<span class="params"><span class="keyword">int</span> x</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Transformer t = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//在这里方法也可以当成是一个委托实例</span></span><br><span class="line">        <span class="comment">//Transformer t = Square</span></span><br><span class="line">        t += Square;</span><br><span class="line">        <span class="comment">//t = t + Cube</span></span><br><span class="line">        t += Cube;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用的时候就会按照Square、Cube顺序进行调用</span></span><br><span class="line">        <span class="comment">//返回最后一个方法的返回值</span></span><br><span class="line">        <span class="keyword">var</span> i = t(<span class="number">3</span>);</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移除委托实例</span></span><br><span class="line">        <span class="comment">//若把所有的委托实例都移除了，那么委托实例会为null</span></span><br><span class="line">        t -= Cube;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> j = t(<span class="number">3</span>);</span><br><span class="line">        Console.WriteLine(j);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Square</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = x * x;</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Cube</span>(<span class="params"><span class="keyword">int</span> x</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = x * x * x;</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="实例方法目标和静态方法目标"><a href="#实例方法目标和静态方法目标" class="headerlink" title="实例方法目标和静态方法目标"></a>实例方法目标和静态方法目标</h3><ul>
<li>当一个实例方法被赋值给委托对象的时候，这个委托对象不仅要保留着对方法的引用，还要保留着方法所属实例的引用</li>
<li>而实例的引用就是<code>System.Delegate</code>中的<code>Target</code>属性。</li>
<li>如果引用的是静态方法，那么<code>Target</code>属性的值就为null</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">ProgressReporter</span>(<span class="params"><span class="keyword">int</span> x</span>)</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">X</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InstInstanceProgress</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; Console.WriteLine(<span class="string">$"X：<span class="subst">&#123;x&#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        X x = <span class="keyword">new</span> X();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 当p委托了x对象中的InstInstanceProgress方法时，</span></span><br><span class="line"><span class="comment">             * 他也会保留方法所属的x对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        ProgressReporter p = x.InstInstanceProgress;</span><br><span class="line">        p(<span class="number">99</span>);</span><br><span class="line">        <span class="comment">//True</span></span><br><span class="line">        Console.WriteLine(p.Target == x);</span><br><span class="line">        <span class="comment">//Void InstInstanceProgress(Int32)</span></span><br><span class="line">        Console.WriteLine(p.Method);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="泛型委托类型"><a href="#泛型委托类型" class="headerlink" title="泛型委托类型"></a>泛型委托类型</h3><ul>
<li>委托类型可以包含泛型类型的参数，<code>public delegate T Transformer&lt;T&gt; (T arg);</code></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delegate</span> T Transformer&lt;T&gt;(T arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Util</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> Transform&lt;T&gt;(T[] values, Transformer&lt;T&gt; t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//t(values[i])只返回Cube的返回值</span></span><br><span class="line">                values[i] = t(values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] values = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        Transformer&lt;<span class="keyword">int</span>&gt; t = Square;</span><br><span class="line">        t += Cube;</span><br><span class="line">        Util.Transform(values, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> values)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Square</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; x * x;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Cube</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Func和Action委托"><a href="#Func和Action委托" class="headerlink" title="Func和Action委托"></a>Func和Action委托</h3><h4 id="Func"><a href="#Func" class="headerlink" title="Func"></a>Func</h4><ul>
<li><code>Func</code>类型的定义都放在了System命名空间下，它代表的是有返回值的委托类型，它有多种不同的泛型类型可供使用：<ol>
<li><code>delegate TResult Func&lt;out TResult&gt;();</code>：有返回值，没有参数的委托类型，out表示<code>TResult</code>类型的变量只能作为方法的输出。</li>
<li><code>delegate TResult Func&lt;in T, out TResult&gt;(T arg);</code>：有返回值，一个参数的委托类型，in表示<code>T</code>类型的变量只能作为方法的输入。</li>
<li><code>delegate TResult Func&lt;in T1, in T2... out TResult&gt;(T1 arg1, T2 arg2...);</code>：有返回值，多个个参数的委托类型，最多可以支持16个输入参数。</li>
</ol>
</li>
</ul>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><ul>
<li><code>Action</code>类型的定义都放在了System命名空间下，它代表的是没有返回值的委托类型，它有多种不同的泛型类型可供使用：</li>
</ul>
<ol>
<li><code>delegate void Action();</code>：没有返回值，没有参数的委托类型。</li>
<li><code>delegate void Action&lt;in T&gt;(T arg);</code>：没有返回值，一个参数的委托类型。</li>
<li><code>delegate void Action&lt;in T1, in T2...&gt;(T1 arg1, T2 arg2...);</code>：没有返回值，多个个参数的委托类型，最多可以支持16个输入参数。</li>
</ol>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] values1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Func委托类型进行委托</span></span><br><span class="line">        Transform1(values1, Square);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> <span class="keyword">value</span> <span class="keyword">in</span> values1)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Action委托类型进行委托</span></span><br><span class="line">        <span class="keyword">int</span>[] values2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        Transform2(values2, Cube);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> Transform1&lt;T&gt;(T[] values, Func&lt;T, T&gt; tranFunc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Func有返回值</span></span><br><span class="line">            values[i] = tranFunc(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> Transform2&lt;T&gt;(T[] values, Action&lt;T&gt; tranAction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Action没有返回值</span></span><br><span class="line">            tranAction(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Square</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; x * x;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Cube</span>(<span class="params"><span class="keyword">int</span> x</span>)</span> =&gt; Console.WriteLine(x*x*x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="接口和委托"><a href="#接口和委托" class="headerlink" title="接口和委托"></a>接口和委托</h3><ul>
<li>委托可以解决的委托，接口都可以解决，那在什么时候更适合自定义的委托而不是使用接口呢？<ol>
<li>需要多播的功能，接口不能实现多播的功能</li>
<li>订阅者需要多次实现接口jian</li>
</ol>
</li>
</ul>
<h3 id="委托的兼容性"><a href="#委托的兼容性" class="headerlink" title="委托的兼容性"></a>委托的兼容性</h3><ul>
<li>委托类型：委托类型之间时互不相容的，即使方法签名一样。</li>
<li>委托实例：如果委托实例拥有相同的方法目标，那么委托实例就是相等的。</li>
<li>参数：委托可以接受比它的定义参数类型更加抽象的参数类型的方法，这个叫做委托的逆变。</li>
<li>返回值：委托可以接受比它的定义返回类型更加具体的返回类型的方法，这个叫做委托的协变。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//委托的参数类型是string</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">delegate</span> <span class="keyword">object</span> <span class="title">Printer</span>(<span class="params"><span class="keyword">string</span> str</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Printer printer = Print;</span><br><span class="line">        printer(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//而目标方法的参数是object，比委托参数更加抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">string</span> <span class="title">Print</span>(<span class="params"><span class="keyword">object</span> o</span>)</span> =&gt; (<span class="keyword">string</span>)o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>而委托支持的仅仅只是引用转换，而不支持装箱拆箱操作，比如下面例子：他并不支持将int进行装箱</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">StringAction</span>(<span class="params"><span class="keyword">int</span> str</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            StringAction stringAction = Print;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params"><span class="keyword">object</span> o</span>)</span> =&gt; Console.WriteLine(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV1Zf4y117fs" target="_blank" rel="noopener">B站杨旭</a></p>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C#</tag>
      </tags>
  </entry>
  <entry>
    <title>真会C#?——异步编程1</title>
    <url>/2020/09/18/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B1/</url>
    <content><![CDATA[<h3 id="线程Thread"><a href="#线程Thread" class="headerlink" title="线程Thread"></a>线程Thread</h3><ul>
<li>线程是一个可执行路径，它可以独立于其他线程执行，每个线程都在操作系统的进程内执行，而操作系统提供了程序运行的独立环境</li>
<li>在C#中线程的创建方式是<code>var thread = new Thread(WriteY);</code>，他必须传入一个执行任务，这个执行任务可以是一个函数（委托），然后可以设置它的名字，调用<code>Start()</code>来执行线程中的任务，在这里会看到X和Y交替输出，这是thread线程和主线程并发执行的效果。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">ThreadDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ThreadDemo</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(WriteY);</span><br><span class="line">            thread.Name = <span class="string">"Y Thread"</span>;</span><br><span class="line">            thread.Start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">"X"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteY</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.Write(<span class="string">"Y"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>线程的一些属性<ol>
<li>IsAlive：线程一旦开始执行，IsAlive就是true，线程结束就为false，结束的条件是传入的委托结束了执行</li>
<li>Name：线程的名称，只能设置一次，一般用于调试。</li>
<li>CurrentThread：返回当前执行的线程</li>
<li>注意：线程一旦结束，就无法再重启</li>
</ol>
</li>
</ul>
<h3 id="Join和Sleep"><a href="#Join和Sleep" class="headerlink" title="Join和Sleep"></a>Join和Sleep</h3><ul>
<li>Join：调用Join方法，就可以等待另一个线程结束，即thread2调用了Join方法后，其他的线程就会等待thread2执行结束后才能执行</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread thread1, thread2;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        thread1 = <span class="keyword">new</span> Thread(ThreadProc);</span><br><span class="line">        thread1.Name = <span class="string">"Thread1"</span>;</span><br><span class="line">        thread1.Start();</span><br><span class="line"></span><br><span class="line">        thread2 = <span class="keyword">new</span> Thread(ThreadProc);</span><br><span class="line">        thread2.Name = <span class="string">"Thread2"</span>;</span><br><span class="line">        thread2.Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ThreadProc</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"\nCurrent thread: &#123;0&#125;"</span>, Thread.CurrentThread.Name);</span><br><span class="line">        <span class="keyword">if</span> (Thread.CurrentThread.Name == <span class="string">"Thread1"</span> &amp;&amp; thread2.ThreadState != ThreadState.Unstarted)</span><br><span class="line">            <span class="comment">//等待thread2执行结束后thread1才往下执行</span></span><br><span class="line">            thread2.Join();</span><br><span class="line">        Thread.Sleep(<span class="number">4000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"\nCurrent thread: &#123;0&#125;"</span>, Thread.CurrentThread.Name);</span><br><span class="line">        Console.WriteLine(<span class="string">"Thread1: &#123;0&#125;"</span>, thread1.ThreadState);</span><br><span class="line">        Console.WriteLine(<span class="string">"Thread2: &#123;0&#125;\n"</span>, thread2.ThreadState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Sleep：会暂停当前的线程，但线程不会被抢占</li>
<li>添加超时：使用TimeSpan对象来设置Join的超时时间或设置Sleep的超时时间</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JoinTimeSpan</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> TimeSpan waitTime = <span class="keyword">new</span> TimeSpan(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(Work);</span><br><span class="line">        thread.Start();</span><br><span class="line">        <span class="keyword">if</span> (thread.Join(waitTime))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"New thread terminated"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"Join timed out."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Work</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Thread.Sleep(waitTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>注意：<ol>
<li><code>Thread.Sleep(0)</code>这样调用会导致线程立即放弃当前的时间片，自动将cpu移交给其他线程。这个功能类似于<code>Thread.Yield()</code>，但是它只会把执行交给同一处理器上的其他线程。</li>
<li>当等待Sleep或Join的时候，线程处于阻塞的状态。</li>
<li><code>Sleep(0)</code>或<code>Yield()</code>在高级性能调试中是一个很好的诊断工具，有助于发现线程安全问题，但在生产代码中不能随意地使用<code>Yield()</code>函数。</li>
</ol>
</li>
</ul>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul>
<li>如果线程的执行由于某种原因导致暂停，则就认为该线程被阻塞了。被阻塞的线程会立即将其处理器的时间片生成给其他线程，从此就不再消耗处理器的时间，直到满足其阻塞条件为止。</li>
<li>可以使用<code>ThreadState</code>属性来判断线程是否处于被阻塞状态，<code>ThreadState</code>是一个枚举，可以用来获取线程的状态。它可以通过按位的形式合并状态的选项。</li>
</ul>
<p><img src="/2020/09/18/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B1/Snipaste_2020-09-17_11-43-11.png" alt="Snipaste_2020-09-17_11-43-11"></p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//按位进行或操作</span></span><br><span class="line">        <span class="comment">//比较有用的有四个状态：Unstarted、Running、WaitSleepJoin和Stopped</span></span><br><span class="line">        <span class="keyword">var</span> state = ThreadState.Unstarted | ThreadState.Stopped | ThreadState.WaitSleepJoin;</span><br><span class="line">        Console.WriteLine(<span class="string">$"<span class="subst">&#123;Convert.ToString((<span class="keyword">int</span>)state, <span class="number">2</span>)&#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="解除阻塞Unblocking"><a href="#解除阻塞Unblocking" class="headerlink" title="解除阻塞Unblocking"></a>解除阻塞Unblocking</h4><ul>
<li>当遇到下列四种情况的时候，就会解除阻塞：</li>
</ul>
<ol>
<li>阻塞条件被满足</li>
<li>操作超时（需要设置超时条件）</li>
<li>通过<code>Thread.Interrupt()</code>进行打断</li>
<li>通过<code>Thread.Abort()</code>进行中止</li>
</ol>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><ul>
<li>当线程阻塞时或接触阻塞时，操作系统将执行上下文切换，这回产生少量开销。</li>
</ul>
<h4 id="阻塞vs忙等待"><a href="#阻塞vs忙等待" class="headerlink" title="阻塞vs忙等待"></a>阻塞vs忙等待</h4><ul>
<li>阻塞和忙等待也被称为<code>IO-bound</code>和<code>Cpu-bound</code></li>
<li>IO-bound操作的工作方式有两种：<ol>
<li>在当前线程上同步等待</li>
<li>异步的操作</li>
</ol>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">Console.ReadLine(), Thread.Sleep(), Thread.Join()...</span><br></pre></td></tr></table></figure></div>

<ul>
<li>而Cpu-bound就类似于死循环</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//忙等待+阻塞</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    Thread.Sleep(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="本地状态和共享状态"><a href="#本地状态和共享状态" class="headerlink" title="本地状态和共享状态"></a>本地状态和共享状态</h4><ul>
<li>Local本地独立：CLR为每个线程分配自己的内存栈，以便使本地变量保持独立。</li>
<li>Shared共享：<ol>
<li>如果多个线程都引用到同一个对象实例，那么它们就共享了数据。</li>
<li>被lambda表达式或匿名委托所捕获的本地变量，会被编译器转化为字段，所以也会被共享。</li>
<li>静态字段也会在线程间共享。</li>
</ol>
</li>
<li>下面的_done字段就是共享变量</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> _done;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(Go).Start();</span><br><span class="line">        Go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_done)</span><br><span class="line">        &#123;</span><br><span class="line">            _done = <span class="literal">true</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"Done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>字段共享就会引出线程安全问题，因为上述例子的输出有可能不是固定的，如果在<code>_done = true;</code>前加上<code>Thread.Sleep()</code>结果就会不一样</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> _done;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(Go).Start();</span><br><span class="line">        Go();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_done)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">            _done = <span class="literal">true</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">"Done"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><ul>
<li>在现实中应该尽量避免这种共享变量的使用，这种线程安全也可以用互斥锁lock来解决。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> _locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> _done;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(Go).Start();</span><br><span class="line">            Go();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (_locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!_done)</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">                    _done = <span class="literal">true</span>;</span><br><span class="line">                    Console.WriteLine(<span class="string">"Done"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在这里使用<code>lock</code>将共享代码块包括，这个<code>lock</code>代码块就称为临界区，每次只允许一个线程进入，在多线程上下文中，以这种方式避免不确定性的代码就叫做线程安全</li>
<li>但是使用lock来解决线程安全也存在很大的问题，第一很容易忘记对字段加锁，第二会引起死锁。</li>
</ul>
<h3 id="线程传参"><a href="#线程传参" class="headerlink" title="线程传参"></a>线程传参</h3><ul>
<li>可以直接使用lambda表达式做为Thread的参数，比如：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">                   &#123;</span><br><span class="line">                       Console.WriteLine(<span class="string">"Hello World"</span>);</span><br><span class="line">                   &#125;).Start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可以使用Thread的Start方法来传递任务的参数，因为传参委托的类型是<code>ThreadStart</code>，所以参数必须是object类型。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(G).Start(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">G</span>(<span class="params"><span class="keyword">object</span> str</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine((<span class="keyword">string</span>)str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>使用lambda表达式可以很简单地给Thread传递参数。但是线程开始后，可能会不小心修改了被捕获地变量，比如下面的例子，每一次运行都有不同的输出，而且输出有可能会有相同的值。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() =&gt; Console.Write(i)).Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可以使用局部变量来解决这个问题</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = i;</span><br><span class="line">    <span class="keyword">new</span> Thread(() =&gt; Console.Write(temp)).Start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul>
<li>线程的优先级（Priority属性）决定了相对于操作系统中其他活跃线程所占的执行时间。</li>
<li>如果想让某线程的优先级比其他进程中的线程高，那就必须提升进程的优先级，这里可以使用Process类</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (Process p = Process.GetCurrentProcess())</span><br><span class="line">&#123;</span><br><span class="line">    p.PriorityClass = ProcessPriorityClass.High;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>但是，提高线程或进程的优先级可能会导致其他线程或线程处于饥饿状态，不能随便设置。</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><ul>
<li>有时，你需要让某个线程一直处于等待状态，直到接收到其他线程发来的通知，才解除等待状态，这就叫做signaling。最简单的信号结构是<code>MaunalResetEvent</code>类对象。</li>
<li>调用<code>MaunalResetEvent</code>类对象的<code>WaitOne</code>方法就会阻塞当前的线程，直到另一个线程通过调用<code>Set</code>方法来打开信号（发送信号）。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> signal = <span class="keyword">new</span> ManualResetEvent(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">                                &#123;</span><br><span class="line">                                    Console.WriteLine(<span class="string">"Waiting for signal..."</span>);</span><br><span class="line">                                    <span class="comment">//等待主线程发送的信号</span></span><br><span class="line">                                    signal.WaitOne();</span><br><span class="line">                                    signal.Dispose();</span><br><span class="line">                                    Console.WriteLine(<span class="string">"Got signal!"</span>);</span><br><span class="line">                                &#125;);</span><br><span class="line">        thread.Start();</span><br><span class="line">        Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">//向thread打开信号</span></span><br><span class="line">        signal.Set();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>信号打开后可以通过<code>Reset</code>方法来重新关闭信号。</li>
</ul>
<h3 id="同步上下文"><a href="#同步上下文" class="headerlink" title="同步上下文"></a>同步上下文</h3><ul>
<li>Thread Marshaling：Marshaling的意思是假如要将一个平台上的数据发送给另一个平台，但是两个平台使用的数据格式不一致，这时候就需要把数据转化为可发送的数据格式，这就类似于json的序列化，而接收端就是Unmarshaling，也就类似于反序列化。而Thread Marshaling就是把一些数据的所有权从一个线程交给另外一个线程。</li>
<li>在C#中同步上下文是用<code>System.ComponentModel</code>下的<code>SynchronizationContext</code>抽象类来实现的，可以通过实例化<code>SynchronizationContext</code>的子类，调用它的Post方法来实现同步上下文，这一般在富客户端应用比较常用（WPF、WinForm）,它可以让主线程的一些事件的操作交给UI线程，这样UI线程可以做一下事件的调用，主线程也不会进入假死。</li>
</ul>
<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV1Zf4y117fs" target="_blank" rel="noopener">B站杨旭</a></p>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C#</tag>
      </tags>
  </entry>
  <entry>
    <title>真会C#?——异步编程2</title>
    <url>/2020/09/25/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B2/</url>
    <content><![CDATA[<h3 id="线程池（Thread-Pool）"><a href="#线程池（Thread-Pool）" class="headerlink" title="线程池（Thread Pool）"></a>线程池（Thread Pool）</h3><ul>
<li><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的<a href="https://baike.baidu.com/item/堆栈/1682032" target="_blank" rel="noopener">堆栈</a>大小，以默认的优先级运行，并处于多线程单元中</p>
</li>
<li><p>当开始一个线程的时候，将花费几百微秒来组织一个心得局部变量栈，而使用线程池可以节省这种组织开销，即通过预先创建一个可循环使用线程的池来减少这一开销。</p>
</li>
<li><p>线程池对于高效的并行编程和细粒度并发是必不可少的，它允许在不被线程启动的开销淹没的情况下运行短期操作（这种短期操作开销很小）。</p>
</li>
</ul>
<h3 id="使用线程池需要注意的地方"><a href="#使用线程池需要注意的地方" class="headerlink" title="使用线程池需要注意的地方"></a>使用线程池需要注意的地方</h3><ul>
<li>不可以设置线程池的Name</li>
<li>池线程都是后台线程</li>
<li>阻塞池线程可能使性能降级</li>
<li>可以自由地更改池线程的优先级，当线程释放回池时优先级将还原</li>
<li>可以使用<code>Thread.CurrentThread.IsThreadPoolThread</code>属性来判断是否执行在线程池上。</li>
</ul>
<h3 id="有哪些用了线程池"><a href="#有哪些用了线程池" class="headerlink" title="有哪些用了线程池"></a>有哪些用了线程池</h3><ul>
<li>WCF、Asp.Net Core、ASMX等应用服务器</li>
<li>System.Timers.Timer、System.Threading.Timer</li>
<li>并行编程结构</li>
<li>。。。</li>
</ul>
<h3 id="线程池中的整洁"><a href="#线程池中的整洁" class="headerlink" title="线程池中的整洁"></a>线程池中的整洁</h3><ul>
<li>如果项充分利用CPU，那么保持线程池的“整洁”是非常重要的。</li>
</ul>
<h4 id="超额订阅"><a href="#超额订阅" class="headerlink" title="超额订阅"></a>超额订阅</h4><ul>
<li><p>CPU的超额订阅：活跃的线程超过CPU的核数，操作系统就需要对线程进行时间切片。</p>
</li>
<li><p>线程池提供了另一个功能，即确保临时超出的Compute-Bound工作不会导致CPU的超额订阅。由于超额订阅需要增加时间切片，时间切片又需要昂贵的上下文切换，并且可能使CPU缓存失效（至关重要）。</p>
</li>
</ul>
<h4 id="CLR的策略"><a href="#CLR的策略" class="headerlink" title="CLR的策略"></a>CLR的策略</h4><ul>
<li>C#中使用CLR通过对任务排队并对其启动进行节流限制来避免线程池中的超额订阅。它首先运行尽可能对的并发任务，然后通过一些算法调整并发线程的级别，并在特定的方向上不断调整工作负载，具体就是确保并发线程的运行始终追随最佳的性能曲线。</li>
<li>如果下面两点能够满足，则CLR的策略将发挥出最佳的效果：<ol>
<li>工作项大多是短时间（&lt;250毫秒，理想情况下&lt;100毫秒）运行的，因此CLR有更多的机会进行测量和调整。</li>
<li>大部分时间都被阻塞的工作项不会主宰线程池。</li>
</ol>
</li>
</ul>
<h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><h4 id="Thread的问题"><a href="#Thread的问题" class="headerlink" title="Thread的问题"></a>Thread的问题</h4><ul>
<li>Thread是用来创建concurrency（并发）的一种低级别工具，他有一些限制：<ol>
<li>Thread在进行Join的时候，很难从线程获得返回值，解决这个问题可能需要设置一些共享变量。</li>
<li>如果操作抛出异常，捕获和传播该异常都会很麻烦。</li>
<li>无法告诉线程在结束时开始做另外的工作，你必须使用Join来完成这个操作，这将会导致其他线程不能执行。</li>
<li>很难使用较小的并发来组建大型的并发，导致了对手动同步的更大依赖。</li>
</ol>
</li>
</ul>
<h4 id="Task-class"><a href="#Task-class" class="headerlink" title="Task class"></a>Task class</h4><ul>
<li>Task类是一个相对高级的并发工具，它是在<code>System.Threading.Tasks</code>命名空间下的，它代表了一个并发操作，可以很好地解决上述问题，它有一些操作可能由Thread支持，有可能不由Thread支持。</li>
<li>Task是可以组合的，可以使用Continuation把它们串成链。</li>
<li>Tasks可以使用线程池来减少启动延迟，它也可以利用回调的方式，在等待IO绑定操作时完全避免线程。</li>
</ul>
<h4 id="开始一个Task"><a href="#开始一个Task" class="headerlink" title="开始一个Task"></a>开始一个Task</h4><ul>
<li>开始一个Task的最简单方法是使用<code>Task.Run</code>这个静态方法，只需要传入一个委托即可。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建了一个任务，在创建任务时会自动使用线程池，线程池里面有一个线程（也就是委托实例）</span></span><br><span class="line"><span class="comment">             * 主线程执行完后Task中的线程还没有执行结束就被kill了，这时并不会输出线程中的那句话</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        Task.Run(() =&gt; &#123; Console.WriteLine(<span class="string">"Hello Task!"</span>); &#125;);</span><br><span class="line">        <span class="comment">//这时要阻塞一下主线程才可以执行线程中的语句</span></span><br><span class="line">        <span class="comment">// Console.ReadLine();</span></span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Task默认使用线程池，也就是后台线程：当主线程结束时，你创建的所有tasks都会结束。</li>
<li><code>Task.Run</code>返回了一个Task对象，可以使用它来监视线程的执行过程</li>
<li>使用<code>Task.Run</code>来启动线程的任务是“热”任务，它并不需要调用Start，而使用Task的构造器创建的任务为“冷”任务，需要使用Start来启动线程池中的线程，但很少使用冷任务。</li>
<li>可以通过Task的Status属性来跟踪task的执行状态；</li>
</ul>
<h4 id="Wait"><a href="#Wait" class="headerlink" title="Wait"></a>Wait</h4><ul>
<li>调用task的Wait方法会进行阻塞直到Task中的并发操作完成，这就相当于调用了thread上的Join方法。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> task = Task.Run(() =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">                Console.WriteLine(<span class="string">"Hello Task!"</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//task的状态:WaitingToRun</span></span><br><span class="line">            Console.WriteLine(task.Status);</span><br><span class="line">            <span class="comment">//是否完成操作：false</span></span><br><span class="line">            Console.WriteLine(task.IsCompleted);</span><br><span class="line">            <span class="comment">//task的状态:Running</span></span><br><span class="line">            Console.WriteLine(task.Status);</span><br><span class="line">            <span class="comment">//阻塞直至task完成操作</span></span><br><span class="line">            task.Wait();</span><br><span class="line">            <span class="comment">//是否完成操作：true</span></span><br><span class="line">            Console.WriteLine(task.IsCompleted);</span><br><span class="line">            <span class="comment">//task的状态:RanToCompletion</span></span><br><span class="line">            Console.WriteLine(task.Status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Wait也可以传入一个超时时间和一个取消指令来提前结束等待。</li>
</ul>
<h4 id="长时间运行的任务"><a href="#长时间运行的任务" class="headerlink" title="长时间运行的任务"></a>长时间运行的任务</h4><ul>
<li>Task比较适合短时间运行的Compute-Bound类的工作，而那种长时间运行的任务可以使用下面方式运行：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> task = Task.Factory.StartNew(() =&gt;</span><br><span class="line">                                         &#123;</span><br><span class="line">                                             Thread.Sleep(<span class="number">3000</span>);</span><br><span class="line">                                             Console.WriteLine(<span class="string">"Hello Task!"</span>);</span><br><span class="line">                                         &#125;, TaskCreationOptions.LongRunning);</span><br><span class="line">        task.Wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="Task的返回值"><a href="#Task的返回值" class="headerlink" title="Task的返回值"></a>Task的返回值</h4><ul>
<li>Task有一个泛型子类叫做<code>Task&lt;TResult&gt;</code>，它指定Task的返回值类型，使用<code>Func&lt;TResult&gt;</code>委托或兼容的Lambda表达式来调用Task.Run就可以得到<code>Task&lt;TResult&gt;</code>，随后可以通过Result属性来获得返回的结果。</li>
<li>如果task还没有完成操作，访问Result属性就会阻塞该线程直到task完成操作。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; task = Task.Run(() =&gt;</span><br><span class="line">                                  &#123;</span><br><span class="line">                                      Console.WriteLine(<span class="string">"Foo"</span>);</span><br><span class="line">                                      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">                                  &#125;);</span><br><span class="line">        <span class="comment">//若task还没执行完成，访问Result将会阻塞主线程，直至task执行结束。</span></span><br><span class="line">        <span class="keyword">var</span> taskResult = task.Result;</span><br><span class="line">        Console.WriteLine(taskResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//2到3000000中的质数的个数</span></span><br><span class="line">        <span class="keyword">var</span> task = Task.Run(() =&gt;</span><br><span class="line">                            Enumerable.Range(<span class="number">2</span>, <span class="number">3000000</span>).Count(n =&gt;</span><br><span class="line">                                                               Enumerable.Range(<span class="number">2</span>, (<span class="keyword">int</span>) Math.Sqrt(n) - <span class="number">1</span>).All(i =&gt; n % i &gt; <span class="number">0</span>)));</span><br><span class="line">        Console.WriteLine(<span class="string">"Task running..."</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">"The answer is "</span> + task.Result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>Task&lt;TResult&gt;</code>可以看作是一种所谓的future、promise（未来/许诺），早它里面包裹着一个Result，可以在<code>Task.Run</code>后依旧可以使用。</li>
</ul>
<h4 id="Task的异常"><a href="#Task的异常" class="headerlink" title="Task的异常"></a>Task的异常</h4><ul>
<li>与Thread不一样，Task可以很方便的传播异常，如果task里面抛出了一个未处理的异常，则该异常就会重新被抛出给：<ol>
<li>调用Wait()的地方</li>
<li>访问了<code>Task&lt;TResult&gt;</code>的Result属性的地方。</li>
</ol>
</li>
<li>在Task里面抛出的异常会被CLR包装到<code>AggregateException</code>异常里。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Task task = Task.Run(() =&gt;</span><br><span class="line">                             &#123;</span><br><span class="line">                                 <span class="keyword">throw</span> <span class="literal">null</span>;</span><br><span class="line">                             &#125;);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当task中抛出异常后，会在这里捕获异常</span></span><br><span class="line">            task.Wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (AggregateException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.InnerException <span class="keyword">is</span> NullReferenceException)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可以使用Task的<code>IsFaulted</code>和<code>IsCanceled</code>属性来检测Task是否发生了故障。两个属性都返回false，则没有错误发生。</li>
<li>如果ICanceled为true，则说明一个OperationCanceledException为该Task抛出了</li>
<li>如果IsFaulted为true，则说明另一个类型的异常被抛出了，而Exception属性也将指明错误。</li>
</ul>
<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV1Zf4y117fs?p=11" target="_blank" rel="noopener">B站杨旭</a></p>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C#</tag>
      </tags>
  </entry>
  <entry>
    <title>真会C#?——异步编程3</title>
    <url>/2020/10/03/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B3/</url>
    <content><![CDATA[<h3 id="Continuation"><a href="#Continuation" class="headerlink" title="Continuation"></a>Continuation</h3><ul>
<li>Continuation表示当Task结束操作时，继续执行其他的一些操作，它通常是通过回调的方式来实现的。当Task一结束，就会开始执行。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Task&lt;<span class="keyword">int</span>&gt; task = Task.Run(() =&gt;</span><br><span class="line">                                  Enumerable.Range(<span class="number">2</span>, <span class="number">3000000</span>).Count(n =&gt;</span><br><span class="line">                                                                     Enumerable.Range(<span class="number">2</span>, (<span class="keyword">int</span>)Math.Sqrt(n) - <span class="number">1</span>).All(i =&gt; n % i &gt; <span class="number">0</span>)));</span><br><span class="line">        TaskAwaiter&lt;<span class="keyword">int</span>&gt; awaiter = task.GetAwaiter();</span><br><span class="line">        <span class="comment">//OnCompleted()代表当task结束时运行</span></span><br><span class="line">        awaiter.OnCompleted(() =&gt;</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//获取Task的返回结果</span></span><br><span class="line">                                <span class="keyword">var</span> result = awaiter.GetResult();</span><br><span class="line">                                Console.WriteLine(result);</span><br><span class="line">                            &#125;);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在task上调用<code>GetAwaiter</code>会返回一个awaiter对象，它的<code>OnCompleted</code>方法中的委托会在task结束或发生故障时执行。可以将Continuation附加到已经结束的task上面。</li>
<li>其实使用<code>task.Result</code>也可以获取task的返回值，但使用<code>GetResult</code>的好处是，如果task发生故障，那么异常会被直接抛出，而不是包装在<code>AggregateException</code>里面，这样catch就不用判断异常的类型。</li>
</ul>
<h3 id="ContinueWith"><a href="#ContinueWith" class="headerlink" title="ContinueWith"></a>ContinueWith</h3><ul>
<li>使用它的效果和使用<code>awaiter.OnCompleted</code>的效果一样。不同的是<code>OnCompleted</code>没有返回值，而<code>ContinueWith</code>返回原来Task实例，可以用它来附加更多的Continuation，但这样就必须直接处理<code>AggregateException</code>。它要求传入一个原来Task实例类型的参数的委托。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Task&lt;<span class="keyword">int</span>&gt; task = Task.Run(() =&gt;</span><br><span class="line">                Enumerable.Range(<span class="number">2</span>, <span class="number">3000000</span>).Count(n =&gt;</span><br><span class="line">                    Enumerable.Range(<span class="number">2</span>, (<span class="keyword">int</span>)Math.Sqrt(n) - <span class="number">1</span>).All(i =&gt; n % i &gt; <span class="number">0</span>)));</span><br><span class="line">            <span class="keyword">var</span> continueWith = task.ContinueWith(task =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result = task.Result;</span><br><span class="line">                Console.WriteLine(result);</span><br><span class="line">            &#125;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="TaskCompletionSource"><a href="#TaskCompletionSource" class="headerlink" title="TaskCompletionSource"></a>TaskCompletionSource</h3><ul>
<li>TaskCompletionSource是创建Task的另外一种方式，它可以让你在稍后开始和结束的任意操作中创建Task，提供了一个可手动执行的“从属”Task，即可指示操作何时结束或发生故障</li>
<li>一般推荐用它来创建IO-Bound类的工作，一是可以获得所有Task的优点，二是不需要在操作时阻塞线程。</li>
<li>下面是TaskCompletionSource的简易源码和它的使用方法。<img src="/2020/10/03/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B3/Snipaste_2020-10-02_21-40-56.png" alt="Snipaste_2020-10-02_21-40-56"></li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CS"><figure class="iseeu highlight /cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// var tcs = new TaskCompletionSource&lt;int&gt;();</span></span><br><span class="line">        <span class="comment">// new Thread(() =&gt;</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     Thread.Sleep(5000);</span></span><br><span class="line">        <span class="comment">//     tcs.SetResult(42);</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     IsBackground = true</span></span><br><span class="line">        <span class="comment">// &#125;.Start();</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// var task = tcs.Task;</span></span><br><span class="line">        <span class="comment">// Console.WriteLine(task.Result);</span></span><br><span class="line">        <span class="keyword">var</span> task = Run(() =&gt;</span><br><span class="line">                       &#123;</span><br><span class="line">                           Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">                           <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">                       &#125;);</span><br><span class="line">        Console.WriteLine(task.Result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用此方法相当于调用Task.Factory.StartNew</span></span><br><span class="line">    <span class="comment">//并使用TaskCreationOptions.LongRunning选项来创建非线程池的线程</span></span><br><span class="line">    <span class="keyword">static</span> Task&lt;TResult&gt; Run&lt;TResult&gt;(Func&lt;TResult&gt; func)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;TResult&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() =&gt;</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">try</span></span><br><span class="line">                       &#123;</span><br><span class="line">                           tcs.SetResult(func());</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                       &#123;</span><br><span class="line">                           tcs.SetException(e);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;).Start();</span><br><span class="line">        <span class="keyword">return</span> tcs.Task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>TaskCompletionSource的真正用处是用它创建Task并不占用线程。</p>
</li>
<li><p>使用TaskCompletionSource自定义一个延迟函数，使用dotnet core新添加的Task.Delay可以达到相同的效果，但两者的区别是：一个是不会占用线程，它会等待Continuation开始后，才占用线程；而使用Task.Delay相当于异步版本的Thread.Sleep，它会并发地去执行任务。</p>
</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//使用TaskCompletionSource来进行延迟并不会占用新线程</span></span><br><span class="line">        <span class="comment">//5秒之后，Continuation开始的时候，才占用新线程</span></span><br><span class="line">        Delay(<span class="number">5000</span>)</span><br><span class="line">            .GetAwaiter()</span><br><span class="line">            .OnCompleted(() =&gt; Console.WriteLine(<span class="string">"Print After Delay."</span>));</span><br><span class="line">        <span class="comment">//Task.Delay相当于异步版本的Thread.Sleep，所以下面两个任务是并发进行的</span></span><br><span class="line">        Task.Delay(<span class="number">5000</span>).GetAwaiter().OnCompleted(() =&gt; Console.WriteLine(<span class="string">"Print After Task.Delay.GetAwaiter"</span>));</span><br><span class="line">        Task.Delay(<span class="number">10000</span>).ContinueWith(ant =&gt; Console.WriteLine(<span class="string">"Print After Task.Delay.ContinueWith"</span>));</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Task <span class="title">Delay</span>(<span class="params"><span class="keyword">int</span> milliseconds</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> tcs = <span class="keyword">new</span> TaskCompletionSource&lt;<span class="keyword">object</span>&gt;();</span><br><span class="line">        <span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        timer.Elapsed += <span class="keyword">delegate</span></span><br><span class="line">        &#123;</span><br><span class="line">            timer.Dispose();</span><br><span class="line">            tcs.SetResult(<span class="literal">null</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.Start();</span><br><span class="line">        <span class="keyword">return</span> tcs.Task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="同步和异步。。。"><a href="#同步和异步。。。" class="headerlink" title="同步和异步。。。"></a>同步和异步。。。</h3><h4 id="并发-并行-同步-异步-多线程"><a href="#并发-并行-同步-异步-多线程" class="headerlink" title="并发 并行 同步 异步 多线程"></a>并发 并行 同步 异步 多线程</h4><ul>
<li>它们之间的区别：<ol>
<li>并发：在<a href="http://baike.baidu.com/view/880.htm" target="_blank" rel="noopener">操作系统</a>中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个<a href="http://baike.baidu.com/view/2107226.htm" target="_blank" rel="noopener">处理机</a>上运行。其中两种并发关系分别是同步和互斥</li>
<li>互斥：进程间相互排斥的使用临界资源的现象，就叫互斥。</li>
<li>同步：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。其中并发又有伪并发和真并发，伪并发是指单核处理器的并发，真并发是指多核处理器的并发。</li>
<li>并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。</li>
<li>多线程：多线程是程序设计的逻辑层概念，它是进程中并发运行的一段代码。多线程可以实现线程间的切换执行。</li>
<li>异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。</li>
</ol>
</li>
<li>异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。</li>
</ul>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><ul>
<li><p>同步操作会在返回调用者之前完成它的工作，即在没有得到响应之前会一直等待，直到完成工作，把响应返回给调用者。</p>
</li>
<li><p>异步操作会在返回调用者之后完成它的（大部分）工作，即调用者调用之后，这个调用就直接返回了，没有返回结果（这时这个调用由task的Continuation负责），后面可以继续调用其他方法，而调用的结果会通过状态或通知来通知调用者。</p>
<p><img src="/2020/10/03/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B3/v2-7e4074a08d2a71f1e34fc06345b39c3a_hd.png" alt="同步模型"></p>
<p><img src="/2020/10/03/%E7%9C%9F%E4%BC%9AC-%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B3/v2-a86781d839b0ae665753d370e363d6c8_hd.png" alt="异步模型"></p>
</li>
<li><p>使用异步会启用并发，因为它的工作会与调用者并发执行，异步方法通常会很快就返回到调用者，所以也叫非阻塞方法。</p>
</li>
<li><p>目前有以下几种异步方法：</p>
<ol>
<li>Thread.Start</li>
<li>Task.Run</li>
<li>Continuation</li>
<li>…</li>
</ol>
</li>
</ul>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><ul>
<li>异步编程：就是将长时间运行的函数写成异步的；传统的方法是将长时间运行的函数写成同步的，然后按需引入并发</li>
<li>异步编程相对于传统同步编程有两个好处，一是大大减少了代码量；二是IO-bound并发可不适用线程来实现，可提高可扩展性和执行效率。</li>
<li>异步编程的用途是可编写高效处理大量并发IO的应用程序（服务器应用），它并不负责线程安全，而是关注执行效率，比如：每一个网络请求并不会消耗一个线程。</li>
<li>以下两种操作建议使用异步编写：<ol>
<li>IO-bound和Computed-bound操作</li>
<li>执行时间超过50毫秒的操作</li>
</ol>
</li>
<li>另一方面过细粒度的并发可能会损害性能，因为异步操作也是开销。</li>
</ul>
<h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><ul>
<li>async和await关键字可以让我们写出简洁的异步代码；</li>
</ul>
<h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><ul>
<li>await关键字简化了附加Continuation的过程，它的效果如下：</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简写形式</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="keyword">await</span> xxx;</span><br><span class="line">yyy(x);</span><br><span class="line"><span class="comment">//相当于下面：</span></span><br><span class="line"><span class="keyword">var</span> awaiter = xxx.GetAwaiter();</span><br><span class="line">awaiter.OnCompleted(()=&gt;&#123;</span><br><span class="line">    <span class="keyword">var</span> result = awaiter.GetResult();</span><br><span class="line">    yyy(x);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>可以await什么？一般await的表达式返回的是一个task，但满足下列条件的任意对象都可以被await：</p>
<ol>
<li>拥有GetAwaiter方法，他返回一个awaiter（实现了INotifyCompletion.OnCompleted接口）。</li>
<li>拥有GetResult方法。</li>
<li>一个bool类型的IsCompleted属性。</li>
</ol>
</li>
<li><p>注意：</p>
<ol>
<li><code>await</code>都是和<code>async</code>一起使用的，await是在函数的调用前面加上的，表示它是一个Continuation，若在方法体中使用了<code>await</code>，就需要在方法返回值的前面加上<code>async</code>。</li>
<li>被await标记的语句的返回值的类型必须是Task，可以使用<code>Task&lt;TResult&gt;</code>来指定Continuation的结果。</li>
</ol>
</li>
</ul>
<h4 id="async"><a href="#async" class="headerlink" title="async"></a>async</h4><ul>
<li>使用了<code>async</code>修饰符的方法就是<code>异步函数</code>，<code>async</code>修饰符会让编译器把<code>await</code>当作关键字而不是标识符，它只能应用于方法的返回值前（包括lambda表达式），用async修饰的方法可以返回<code>void</code>、<code>Task</code>、<code>Task&lt;TResult&gt;</code>。</li>
<li><code>async</code>修饰符对方法的签名或访问修饰符（public…）没有影响，它只会影响方法内部。所以在接口中使用<code>async</code>是没有意义的</li>
<li>使用<code>async</code>来重载非<code>async</code>方法是合法的</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="CSHARP"><figure class="iseeu highlight /csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">await</span> DisplayPrimesCountAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">DisplayPrimesCountAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> result = <span class="keyword">await</span> GetPrimesCountAsync(<span class="number">2</span>, <span class="number">1000000</span>);</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Task&lt;<span class="keyword">int</span>&gt; <span class="title">GetPrimesCountAsync</span>(<span class="params"><span class="keyword">int</span> start, <span class="keyword">int</span> count</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Task.Run(() =&gt;</span><br><span class="line">                        ParallelEnumerable.Range(start, count).Count(n =&gt;</span><br><span class="line">                                                                     Enumerable.Range(<span class="number">2</span>, (<span class="keyword">int</span>) Math.Sqrt(n) - <span class="number">1</span>)</span><br><span class="line">                                                                     .All(i =&gt; n % i &gt; <span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="异步函数如何执行"><a href="#异步函数如何执行" class="headerlink" title="异步函数如何执行"></a>异步函数如何执行</h4><ul>
<li>当遇到<code>await</code>表达式时，执行会迅速地返回给调用者，就像<code>yield return</code>一样，在返回前运行时会附加一个<code>Continuation</code>到await地task上，为保证task结束时，执行会跳回原方法，从停止地地方继续执行。</li>
<li>如果发生故障，则异常会被重新抛出，如果正常运行，则task的返回值就会赋给await表达式。</li>
<li>Lambda表达式中也可以写成异步的形式，写法和异步函数类似。</li>
</ul>
<hr>
<p>学习资料：<a href="https://www.bilibili.com/video/BV1Zf4y117fs?p=21" target="_blank" rel="noopener">B站杨旭</a></p>
]]></content>
      <categories>
        <category>-C#</category>
      </categories>
      <tags>
        <tag>-C#</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-S3对象存储部署与应用开发</title>
    <url>/2020/12/04/SequoiaDB-S3%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="配置-SequoiaDB-巨杉数据库存储引擎"><a href="#配置-SequoiaDB-巨杉数据库存储引擎" class="headerlink" title="配置 SequoiaDB 巨杉数据库存储引擎"></a>配置 SequoiaDB 巨杉数据库存储引擎</h3><p>在 SequoiaDB 巨杉数据库存储引擎中开启 RC 级别事务，并且配置为等锁模式，同时为 SequoiaS3 的存储创建专属的域。</p>
<p>1）通过 Linux 命令行进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）开启 RC 级别事务，且配置为等锁模式；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">transactionon</span>: <span class="literal">true</span>, <span class="attr">transisolation</span>: <span class="number">1</span>, <span class="attr">translockwait</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建存储元数据的集合空间所在的域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"metaDomain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span>&#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建存储对象数据的集合空间所在的域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"dataDomain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span>&#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="配置-SequoiaS3-系统"><a href="#配置-SequoiaS3-系统" class="headerlink" title="配置 SequoiaS3 系统"></a>配置 SequoiaS3 系统</h3><p>为 SequoiaS3 系统设置监听端口、数据存储域、存储引擎的协调节点等启动的基础配置。</p>
<p>1）进入 SequoiaS3 包目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiadb/tools/sequoias3</span><br></pre></td></tr></table></figure></div>

<p>2）配置 SequoiaS3，配置对外监听端口；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo 'server.port=8002' &gt;&gt; config/application.properties</span><br></pre></td></tr></table></figure></div>

<p>3）配置 coord 节点的 IP 和端口，可以配置多组并使用逗号分隔</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo 'sdbs3.sequoiadb.url=sequoiadb://localhost:11810' &gt;&gt; config/application.properties</span><br></pre></td></tr></table></figure></div>

<p>4）配置 SequoiaS3 的存储创建了专属的域</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo 'sdbs3.sequoiadb.meta.domain=metaDomain' &gt;&gt; config/application.properties</span><br><span class="line">echo 'sdbs3.sequoiadb.data.domain=dataDomain' &gt;&gt; config/application.properties</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li>详细配置说明： <a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1573442163-edition_id-304" target="_blank" rel="noopener">SequoiaS3 实例参数配置</a></li>
</ul>
</blockquote>
<h3 id="启动-SequoiaS3-系统"><a href="#启动-SequoiaS3-系统" class="headerlink" title="启动 SequoiaS3 系统"></a>启动 SequoiaS3 系统</h3><p>1）配置修改完成后，通过 ./sequoias3.sh 可执行脚本启动 SequoiaS3；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiadb/tools/sequoias3/sequoias3.sh start</span><br></pre></td></tr></table></figure></div>

<p>2）进入 SequoiaDB Shell，查看 SequoiaS3 元数据表,SequoiaS3 实例在启动的时候如果这些元数据表不存在会自动创建；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>3）使用javascript语法连接协调节点，获取 db 数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>4）查看集合列表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.list(SDB_SNAP_COLLECTIONS);</span><br></pre></td></tr></table></figure></div>

<p>操作截图： <img src="https://doc.shiyanlou.com/courses/1543/1207281/31431b6f49340653d09fc4e3bb519651-0" alt="图片描述"></p>
<p>5）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>系统启动时需确保数据库已经正常运行，系统启动后会创建默认管理员用户，您可以使用该默认管理员用户创建新的用户，然后使用新用户角色进行桶操作，对象操作。</p>
<ul>
<li>默认管理员账户名：<code>administrator</code></li>
<li>默认管理员AccessKeyID：<code>ABCDEFGHIJKLMNOPQRST</code></li>
<li>默认管理员用户SecreatKeyID：<code>abcdefghijklmnopqrstuvwxyz0123456789ABCD</code></li>
</ul>
</blockquote>
<h3 id="用户接口相关操作"><a href="#用户接口相关操作" class="headerlink" title="用户接口相关操作"></a>用户接口相关操作</h3><p>在本例中将使用 curl restful 方式来测试 SequoiaS3 用户接口，主要包括用户创建、密钥获取、用户删除等相关操作。后续操作需要启动 SequoiaS3 进程，如有关闭需要打开。</p>
<h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>使用 curl 创建用户 s3user（其中 ABCDEFGHIJKLMNOPQRST 为默认管理员 AccessKeyID ，为 abcdefghijklmnopqrstuvwxyz0123456789ABCD 默认管理员用户 SecreatKeyID ）：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X POST "http://localhost:8002/users/?Action=CreateUser&amp;UserName=s3user&amp;role=admin" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/b89682796a34237a95815548ff26a638-0" alt="图片描述"></p>
<h4 id="获取用户的访问秘钥"><a href="#获取用户的访问秘钥" class="headerlink" title="获取用户的访问秘钥"></a>获取用户的访问秘钥</h4><p>使用 curl 获取 s3user 用户访问秘钥（需管理员用户权限）：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X POST "http://localhost:8002/users/?Action=GetAccessKey&amp;UserName=s3user" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/78de27f5dddc4e8f77a6e47b894cae0a-0" alt="图片描述"></p>
<h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><p>使用 curl 删除用户 s3user（需管理员用户权限）：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X POST "http://localhost:8002/users/?Action=DeleteUser&amp;UserName=s3user" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/8a4801991c4f5799d08d0ac27e434354-0" alt="图片描述"></p>
<h3 id><a href="#" class="headerlink" title></a><img src="https://doc.shiyanlou.com/courses/1538/1207281/64eadd46276ef314129528df3fdcaa93-0" alt="图片描述"></h3><h3 id="桶增删查接口相关操作"><a href="#桶增删查接口相关操作" class="headerlink" title="桶增删查接口相关操作"></a>桶增删查接口相关操作</h3><p>在本例中将使用 curl restful 方式来测试 SequoiaS3 桶接口，主要包括桶创建、桶获取、桶删除等相关操作。</p>
<h4 id="创建桶"><a href="#创建桶" class="headerlink" title="创建桶"></a>创建桶</h4><p>使用 curl 创建桶 sdbbucket：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X PUT "http://localhost:8002/sdbbucket" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/a5d29a21424f40238447e1e844dd1827-0" alt="图片描述"></p>
<h4 id="获取桶信息"><a href="#获取桶信息" class="headerlink" title="获取桶信息"></a>获取桶信息</h4><p>使用 curl 获取所有桶信息：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X GET "http://localhost:8002" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/55aa35d007ebe9b8efcd830c9a594c86-0" alt="图片描述"></p>
<h4 id="删除桶"><a href="#删除桶" class="headerlink" title="删除桶"></a>删除桶</h4><p>1）使用 curl 删除桶 sdbbucket；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X DELETE "http://localhost:8002/sdbbucket" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/5cba4a862e1740474f4a769890014fc7-0" alt="图片描述"></p>
<p>2）检查桶是否存在，确认结果中是否存在桶 sdbbucket；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v GET "http://localhost:8002" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/64eadd46276ef314129528df3fdcaa93-0" alt="图片描述"></p>
<h3 id="文件上传和下载相关操作"><a href="#文件上传和下载相关操作" class="headerlink" title="文件上传和下载相关操作"></a>文件上传和下载相关操作</h3><p>在本例中将使用 curl restful 方式来测试 SequoiaS3 文件对象接口，主要包括文件对象上传、下载、删除相关操作。<br>如果已经删除桶则需要重新创建，需要先确保 sdbbucket 桶已创好。<br>使用 curl 创建桶 sdbbucket ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v -X PUT "http://localhost:8002/sdbbucket" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<h4 id="文件对象上传"><a href="#文件对象上传" class="headerlink" title="文件对象上传"></a>文件对象上传</h4><p>1）检查 /opt/sequoiadb/tools/sequoias3/ 目录下是否存在 sequoia-s3-3.4.jar 这个文件，后面向 sdbbucket 桶上传此文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls /opt/sequoiadb/tools/sequoias3/sequoia-s3-3.4.jar</span><br></pre></td></tr></table></figure></div>

<p>2）使用 curl 向 sdbbucket 中写入文件 “sequoia-s3-3.4.jar” ，在S3中的名称是 “sdbs3.jar”；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -X PUT -T "/opt/sequoiadb/tools/sequoias3/sequoia-s3-3.4.jar" "http://localhost:8002/sdbbucket/sdbs3.jar" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"  -H "Content-Type: text/plain"</span><br></pre></td></tr></table></figure></div>

<p>3）进入 SequoiaDB Shell，查看对象是否上传成功；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>4）使用javascript语法连接协调节点，获取 db 数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>5）在元数据集合中查找文件名，确定是否上传成功；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.S3_SYS_Meta.S3_ObjectMeta.find( &#123; <span class="string">"Key"</span>: <span class="string">"sdbs3.jar"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<ul>
<li>上传前去确保桶 sdbbucket 存在，如不存在，使用之前命令创建 sdbbucket 桶对象。</li>
<li>第一次上传对象时，会创建 S3_ObjectData* 的集合，该集合用于保存对象文件。</li>
</ul>
</blockquote>
<h4 id="文件对象下载"><a href="#文件对象下载" class="headerlink" title="文件对象下载"></a>文件对象下载</h4><p>1）从桶 sdbbucket 中读取文件对象 “sdbs3.jar”，并存放到本地目录 sdbs3.jar 文件中；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -o sdbs3.jar -X GET "http://localhost:8002/sdbbucket/sdbs3.jar" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"  -H "Content-Type: text/plain"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/1d8217811ea029b8b7833bc8ce441e05-0" alt="图片描述"></p>
<p>2）查看下载的文件 sdbs3.jar，观察该文件与 sequoia-s3-3.4.jar 大小是否一致；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls -trl</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/2344f68c5f160315919c996195a239fb" alt="图片描述"></p>
<h4 id="文件对象删除"><a href="#文件对象删除" class="headerlink" title="文件对象删除"></a>文件对象删除</h4><p>1）从桶 sdbbucket 中删除文件对象 “sdbs3.jar”；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -X DELETE "http://localhost:8002/sdbbucket/sdbs3.jar" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>2）进入 SequoiaDB Shell，查看对象是否删除成功；</p>
<p>使用 linux 命令进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>使用javascript语法连接协调节点，获取 db 数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>在元数据集合中查找文件名，如果返回值为空，则对象删除成功；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.S3_SYS_Meta.S3_ObjectMeta.find( &#123; <span class="string">"Key"</span>: <span class="string">"sdbs3.jar"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建-JAVA-工程项目"><a href="#创建-JAVA-工程项目" class="headerlink" title="创建 JAVA 工程项目"></a>创建 JAVA 工程项目</h3><p>本小节介绍使用 Java S3 的使用样例，实现基本读写操作。</p>
<p>1）创建 JAVA 工程目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/sdbadmin/s3/lib</span><br></pre></td></tr></table></figure></div>

<p>2）进入工程目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /home/sdbadmin/s3</span><br></pre></td></tr></table></figure></div>

<p>3）拷贝 S3 接口需要的 jar 包；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cp /home/sdbadmin/package/s3/* ./lib</span><br></pre></td></tr></table></figure></div>

<p>4）复制以下代码到实验环境终端执行，生成创建桶和上传文件的 Init.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /home/sdbadmin/s3/Init.java &lt;&lt; EOF</span><br><span class="line">package com.sequoiadb.samples;</span><br><span class="line"></span><br><span class="line">import com.amazonaws.auth.AWSCredentials;</span><br><span class="line">import com.amazonaws.auth.AWSStaticCredentialsProvider;</span><br><span class="line">import com.amazonaws.auth.BasicAWSCredentials;</span><br><span class="line">import com.amazonaws.client.builder.AwsClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.model.PutObjectRequest;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class Init &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        //初始化客户端, 生成一个与SequoiaS3的连接, 此处需要修改endPoint的地址和端口, 使之指向SequoiaS3的地址和端口.</span><br><span class="line">        AWSCredentials credentials = new BasicAWSCredentials("ABCDEFGHIJKLMNOPQRST", "abcdefghijklmnopqrstuvwxyz0123456789ABCD");</span><br><span class="line">        String endPoint = "http://127.0.0.1:8002";</span><br><span class="line">        AwsClientBuilder.EndpointConfiguration endpointConfiguration = new AwsClientBuilder.EndpointConfiguration(endPoint, null);</span><br><span class="line">        AmazonS3 s3 = AmazonS3ClientBuilder.standard()</span><br><span class="line">                .withEndpointConfiguration(endpointConfiguration)</span><br><span class="line">                .withCredentials(new AWSStaticCredentialsProvider(credentials))</span><br><span class="line">                .build();</span><br><span class="line">        //创建一个名为"javabucket"的桶</span><br><span class="line">        s3.createBucket("javabucket");</span><br><span class="line">        //从本地上传文件 sequoia-s3-3.4.jar 到"javabucket"的存储桶中，并命名为"objectname"</span><br><span class="line">        PutObjectRequest request = new PutObjectRequest("javabucket", "objectname", new File("/opt/sequoiadb/tools/sequoias3/sequoia-s3-3.4.jar"));</span><br><span class="line">        s3.putObject(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<p>5）复制以下代码到实验环境终端执行，生成查询桶内对象列表和下载对象的 GetObject.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /home/sdbadmin/s3/GetObject.java &lt;&lt; EOF</span><br><span class="line">package com.sequoiadb.samples;</span><br><span class="line"></span><br><span class="line">import com.amazonaws.auth.AWSCredentials;</span><br><span class="line">import com.amazonaws.auth.AWSStaticCredentialsProvider;</span><br><span class="line">import com.amazonaws.auth.BasicAWSCredentials;</span><br><span class="line">import com.amazonaws.client.builder.AwsClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.model.GetObjectRequest;</span><br><span class="line">import com.amazonaws.services.s3.model.PutObjectRequest;</span><br><span class="line">import com.amazonaws.services.s3.model.S3Object;</span><br><span class="line">import com.amazonaws.services.s3.model.S3ObjectInputStream;</span><br><span class="line">import com.amazonaws.services.s3.model.ListObjectsV2Result;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class GetObject &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        AWSCredentials credentials = new BasicAWSCredentials("ABCDEFGHIJKLMNOPQRST", "abcdefghijklmnopqrstuvwxyz0123456789ABCD");</span><br><span class="line">        String endPoint = "http://127.0.0.1:8002";</span><br><span class="line">        AwsClientBuilder.EndpointConfiguration endpointConfiguration = new AwsClientBuilder.EndpointConfiguration(endPoint, null);</span><br><span class="line">        AmazonS3 s3 = AmazonS3ClientBuilder.standard()</span><br><span class="line">                .withEndpointConfiguration(endpointConfiguration)</span><br><span class="line">                .withCredentials(new AWSStaticCredentialsProvider(credentials))</span><br><span class="line">                .build();</span><br><span class="line">       //查询名为"bucketname"的桶中所有对象名称</span><br><span class="line">       ListObjectsV2Result listObj = s3.listObjectsV2("javabucket");</span><br><span class="line">        System.out.println("ListObjectsV2Result: "+listObj);</span><br><span class="line">        //从"javabucket"获得"objectname"对象, 并将对象内容存储在本地文件中</span><br><span class="line">        GetObjectRequest request = new GetObjectRequest("javabucket", "objectname");</span><br><span class="line">        S3Object result = s3.getObject(request);</span><br><span class="line">        S3ObjectInputStream s3is = result.getObjectContent();</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(new File("/home/sdbadmin/s3/java_test_s3.jar"));</span><br><span class="line">        byte[] read_buf = new byte[1024];</span><br><span class="line">        int read_len = 0;</span><br><span class="line">        while ((read_len = s3is.read(read_buf)) &gt; 0) &#123;</span><br><span class="line">            fos.write(read_buf, 0, read_len);</span><br><span class="line">        &#125;</span><br><span class="line">        s3is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<p>6）复制以下代码到实验环境终端执行，生成删除对象和桶的 DeleteBucket.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /home/sdbadmin/s3/DeleteBucket.java &lt;&lt; EOF</span><br><span class="line">package com.sequoiadb.samples;</span><br><span class="line"></span><br><span class="line">import com.amazonaws.auth.AWSCredentials;</span><br><span class="line">import com.amazonaws.auth.AWSStaticCredentialsProvider;</span><br><span class="line">import com.amazonaws.auth.BasicAWSCredentials;</span><br><span class="line">import com.amazonaws.client.builder.AwsClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3;</span><br><span class="line">import com.amazonaws.services.s3.AmazonS3ClientBuilder;</span><br><span class="line">import com.amazonaws.services.s3.model.PutObjectRequest;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class DeleteBucket &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        AWSCredentials credentials = new BasicAWSCredentials("ABCDEFGHIJKLMNOPQRST", "abcdefghijklmnopqrstuvwxyz0123456789ABCD");</span><br><span class="line">        String endPoint = "http://127.0.0.1:8002";</span><br><span class="line">        AwsClientBuilder.EndpointConfiguration endpointConfiguration = new AwsClientBuilder.EndpointConfiguration(endPoint, null);</span><br><span class="line">        AmazonS3 s3 = AmazonS3ClientBuilder.standard()</span><br><span class="line">                .withEndpointConfiguration(endpointConfiguration)</span><br><span class="line">                .withCredentials(new AWSStaticCredentialsProvider(credentials))</span><br><span class="line">                .build();</span><br><span class="line">        //删除"javabucket"桶中名为"objectname"的对象</span><br><span class="line">        s3.deleteObject("javabucket", "objectname");</span><br><span class="line">        //删除名为"javabucket"的存储桶</span><br><span class="line">        s3.deleteBucket("javabucket");</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<p>7）查询是否已经生成以上 JAVA 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls -trl /home/sdbadmin/s3/Init.java</span><br><span class="line">ls -trl /home/sdbadmin/s3/GetObject.java</span><br><span class="line">ls -trl /home/sdbadmin/s3/DeleteBucket.java</span><br></pre></td></tr></table></figure></div>

<h3 id="编译运行代码"><a href="#编译运行代码" class="headerlink" title="编译运行代码"></a>编译运行代码</h3><p>上一小节已经创建了 JAVA 工程和代码并且拷贝了 JAVA 驱动，接下来我们对代码进行编译运行。</p>
<p>1）编译 Init.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">javac -cp .:./lib/* -d . Init.java</span><br></pre></td></tr></table></figure></div>

<p>2）运行 Init 类代码，创建”javabucket”桶和上传文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">java -cp .:./lib/* com.sequoiadb.samples.Init</span><br></pre></td></tr></table></figure></div>

<p>3）编译 GetObject.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">javac -cp .:./lib/* -d . GetObject.java</span><br></pre></td></tr></table></figure></div>

<p>4）运行 GetObject 类代码，查询桶内对象列表和获取对象；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">java -cp .:./lib/* com.sequoiadb.samples.GetObject</span><br></pre></td></tr></table></figure></div>

<p>5）查看对象是否下载成功；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls -trl</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/f37ae04baeb95945f3f5a8c23dc874e4-0" alt="图片描述"></p>
<p>6）编译 DeleteBucket.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">javac -cp .:./lib/* -d . DeleteBucket.java</span><br></pre></td></tr></table></figure></div>

<p>7）运行 DeleteBucket 类代码，查询桶内对象列表和获取对象；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">java -cp .:./lib/* com.sequoiadb.samples.DeleteBucket</span><br></pre></td></tr></table></figure></div>

<p>8）检查桶是否存在，确认结果中是否存在桶 javabucket；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">curl -v GET "http://localhost:8002" -H "Host: localhost:8002" -H "Authorization: AWS ABCDEFGHIJKLMNOPQRST:abcdefghijklmnopqrstuvwxyz0123456789ABCD"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/55c381bdc9032f06bed1ae4b9fe20852-0" alt="图片描述"></p>
]]></content>
      <categories>
        <category>-SequoiaDB-S3</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -S3</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB-Spark实现在线联机业务与后台统计分析业务的相互隔离</title>
    <url>/2020/12/04/SequoiaDB-Spark%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BA%BF%E8%81%94%E6%9C%BA%E4%B8%9A%E5%8A%A1%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90%E4%B8%9A%E5%8A%A1%E7%9A%84%E7%9B%B8%E4%BA%92%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<h3 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h3><p>创建 SequoiaDB 集合空间和集合与 SparkSQL 进行关联，并插入部分记录作为后续的实验数据。</p>
<h4 id="创建数据库和数据表"><a href="#创建数据库和数据表" class="headerlink" title="创建数据库和数据表"></a>创建数据库和数据表</h4><p>进入 MySQL Shell，在 MySQL 实例中创建数据库 company，以及 employee 表。</p>
<p>1）使用 Linux 命令进入 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）创建 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）切换到 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>4）创建 employee 表，将同步在 SequoiaDB 巨杉数据引擎中创建分区表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>5）向 employee 表中写入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span> </span><br><span class="line">( <span class="number">10001</span>, <span class="string">'Georgi'</span>, <span class="number">48</span> ),</span><br><span class="line">( <span class="number">10002</span>, <span class="string">'Bezalel'</span>, <span class="number">21</span> ),</span><br><span class="line">( <span class="number">10003</span>, <span class="string">'Parto'</span>, <span class="number">33</span> ),</span><br><span class="line">( <span class="number">10004</span>, <span class="string">'Chirstian'</span>, <span class="number">40</span> ),</span><br><span class="line">( <span class="number">10005</span>, <span class="string">'Kyoichi'</span>, <span class="number">23</span> ),</span><br><span class="line">( <span class="number">10006</span>, <span class="string">'Anneke'</span>, <span class="number">19</span> ),</span><br><span class="line">( <span class="number">10007</span>, <span class="string">'Ileana'</span>, <span class="number">28</span> ),</span><br><span class="line">( <span class="number">10008</span>, <span class="string">'Liz'</span>, <span class="number">38</span> ),</span><br><span class="line">( <span class="number">10009</span>, <span class="string">'Parish'</span>, <span class="number">31</span> ),</span><br><span class="line">( <span class="number">10010</span>, <span class="string">'Odette'</span>, <span class="number">23</span> );</span><br></pre></td></tr></table></figure></div>

<p>6）退出 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="选取优先读备的协调节点"><a href="#选取优先读备的协调节点" class="headerlink" title="选取优先读备的协调节点"></a>选取优先读备的协调节点</h3><p>给 SparkSQL 配置一个专用的协调节点进行数据访问，使用该协调节点进行统计分析查询。</p>
<p>1）在 Linux Shell 查看当前集群中的协调节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdblist -l | grep -E "Name|coord"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/14c1646ff6dde5af09bf40593a8dd414-0" alt="1542-7"></p>
<p>2）查看 MySQL 实例使用的协调节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root -e "SHOW VARIABLES LIKE 'sequoiadb_conn%';"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/6c7b7aafcde4275cf39035b2afcfa541-0" alt="1542-8"></p>
<p>发现集群中有协调节点 11810、21810、31810 三个，MySQL 实例使用 11810 节点，于是在创建 SparkSQL 表时配置专用协调节点 21810。</p>
<h3 id="在-SparkSQL-中建表"><a href="#在-SparkSQL-中建表" class="headerlink" title="在 SparkSQL 中建表"></a>在 SparkSQL 中建表</h3><p>进入 SparkSQL Beeline Shell，在 SparkSQL 实例中创建 employee 表并与 SequoiaDB 中的集合空间、集合关联。</p>
<p>1）查看 Spark 的 Worker 和 Master 是否已经启动；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/3b2fda51ba13a1f1befdd61746844f44-0" alt="图片描述"></p>
<blockquote>
<p>Note:</p>
<p>如果显示的进程名称与预期不符，请稍等初始化完成并重试该步骤。</p>
</blockquote>
<p>2）登录 Beeline 连接到 SparkSQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/spark/bin/beeline -u 'jdbc:hive2://localhost:10000'</span><br></pre></td></tr></table></figure></div>

<p>3）创建并切换至 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>4）创建 employee 表；</p>
<p>创建 employee 表，并且与 SequoiaDB 中的集合 company.employee 进行关联；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno  <span class="built_in">INT</span>,</span><br><span class="line">ename  <span class="keyword">STRING</span>,</span><br><span class="line">age    <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">USING</span> com.sequoiadb.spark OPTIONS </span><br><span class="line">(</span><br><span class="line">host <span class="string">'localhost:21810'</span>,</span><br><span class="line">collectionspace <span class="string">'company'</span>,</span><br><span class="line">collection <span class="string">'employee'</span>,</span><br><span class="line">preferredinstance <span class="string">'S'</span>,</span><br><span class="line">preferredinstancemode <span class="string">'random'</span>,</span><br><span class="line">preferredinstancestrict <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>通过指定 <code>host</code> 可以限定查询连接的协调节点，设置 <code>preferredinstance</code> 参数为 “S” 表示查询时优先读取备数据节点的数据，更详细的参数配置可参考 <a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190712-edition_id-304" target="_blank" rel="noopener">SequoiaDB-SparkSQL 参数说明</a>。</p>
</blockquote>
<p>5）退出 Beeline Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">!quit</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/c6ed22f6000bb73cf874c187c1be79b2-0" alt="1542-11"></p>
<h3 id="确定数据组-group1-主节点"><a href="#确定数据组-group1-主节点" class="headerlink" title="确定数据组 group1 主节点"></a>确定数据组 group1 主节点</h3><p>使用 SequoiaDB 的系统命令 sdblist 确定数据组 group1 的主节点，以便确认联机交易跟统计分析是否在同数据组的不同数据节点上执行。</p>
<p>在 Linux Shell 中执行以下命令，确认数据组 group1 的主节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdblist -l | grep -E "Name|group1"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/e283603c167cd635a60814801a748020-0" alt="1542-6"></p>
<p>从查询结果可以看出，数据组 group1 中，31820 节点是主节点，11820、21820 两个节点是备节点。</p>
<h3 id="验证联机业务与统计分析的相互隔离"><a href="#验证联机业务与统计分析的相互隔离" class="headerlink" title="验证联机业务与统计分析的相互隔离"></a>验证联机业务与统计分析的相互隔离</h3><p>分别在 MySQL 端、SparkSQL 端进行对表 employee 的查询操作，会发现在不同的 SQL 实例上进行查询，在同数据组内，会从不同的数据节点上进行数据读取。下面以数据组 group1 为例进行验证。</p>
<h4 id="检查数据组-group1-各数据节点的数据读取量"><a href="#检查数据组-group1-各数据节点的数据读取量" class="headerlink" title="检查数据组 group1 各数据节点的数据读取量"></a>检查数据组 group1 各数据节点的数据读取量</h4><p>1）使用嵌入命令模式连接 SequoiaDB 巨杉数据库协调节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db = new Sdb("localhost", 11810)'</span><br></pre></td></tr></table></figure></div>

<p>2）使用 snapshot ( SDB_LIST_COLLECTIONS ) 查询集合 company.employee 在数据组 group1 各数据节点的数据读取量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db.snapshot( SDB_LIST_COLLECTIONS , &#123; Name: "company.employee" &#125; )' | grep -E "NodeName|TotalDataRead|GroupName"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/e0960bcbbb0b761ada9d86664f4689ba-0" alt="1542-12"></p>
<h4 id="在-MySQL-端查询-employee-表并观察数据读取状况"><a href="#在-MySQL-端查询-employee-表并观察数据读取状况" class="headerlink" title="在 MySQL 端查询 employee 表并观察数据读取状况"></a>在 MySQL 端查询 employee 表并观察数据读取状况</h4><p>1）使用 Linux 命令进入 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）对 employee 表进行全表查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> company.employee;</span><br></pre></td></tr></table></figure></div>

<p>3）退出 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/5a84dbef951087dfb0a41af05e53815a-0" alt="1542-13"></p>
<p>4）使用 snapshot ( SDB_LIST_COLLECTIONS ) 查询集合 company.employee 在数据组 group1 各数据节点的数据读取量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db.snapshot( SDB_LIST_COLLECTIONS , &#123; Name: "company.employee" &#125; )' | grep -E "NodeName|TotalDataRead|GroupName"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/1944ad76a539ff6d5645779b0060da35-0" alt="1542-14"></p>
<p>从查询结果可以看出，MySQL 实例上的查询，在数据组 group1 中，主节点 31820 上的数据查询量增加了，备节点 11820、21820 两个节点上的查询量未增加。</p>
<h4 id="在-SparkSQL-端查询-employee-表并观察数据读取状况"><a href="#在-SparkSQL-端查询-employee-表并观察数据读取状况" class="headerlink" title="在 SparkSQL 端查询 employee 表并观察数据读取状况"></a>在 SparkSQL 端查询 employee 表并观察数据读取状况</h4><p>1）登录 Beeline 连接到 SparkSQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/spark/bin/beeline -u 'jdbc:hive2://localhost:10000'</span><br></pre></td></tr></table></figure></div>

<p>2）切换到 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）对 employee 表进行全表查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>4）退出 Beeline Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">!quit</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/35be29c8a40f9d402d7b588771fc0cd7-0" alt="1542-15"></p>
<p>5）使用 snapshot ( SDB_LIST_COLLECTIONS ) 查询集合 company.employee 在数据组 group1 各数据节点的数据读取量；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db.snapshot( SDB_LIST_COLLECTIONS , &#123; Name: "company.employee" &#125; )' | grep -E "NodeName|TotalDataRead|GroupName"</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1542/1207281/e1a7d0b384be9edffd17541360b446e3-0" alt="1542-16"></p>
<p>从查询结果可以看出，SparkSQL 实例上的查询，在数据组 group1 中，主节点 31820 上的数据查询量没有增加，备节点 21820 上的查询量增加。</p>
<blockquote>
<p>Note:</p>
<p>本环境中数据节点采用三副本架构，包括一个主节点和两个备节点；配置优先从备节点中读取数据，会在两个可选备节点中随机选取其中一个，所以从 SaprkSQL 实例上的查询，数据查询量增加的不一定是 21820 还可能是 11820。</p>
</blockquote>
]]></content>
      <categories>
        <category>-SequoiaDB-Spark</category>
      </categories>
      <tags>
        <tag>-SequoiaDB -Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB之NFS文件系统部署与应用开发</title>
    <url>/2020/12/04/SequoiaDB%E4%B9%8BNFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="SequoiaDB文件系统引擎概述"><a href="#SequoiaDB文件系统引擎概述" class="headerlink" title="SequoiaDB文件系统引擎概述"></a>SequoiaDB文件系统引擎概述</h3><ul>
<li>SequoiaFS 文件系统是 SequoiaDB 巨杉数据库基于 FUSE 在 Linux 系统下实现的一套文件系统，支持通用的文件操作 API。</li>
<li>用户可以通过 SequoiaFS 将本地目录挂载到 SequoiaDB 的目标集合，在挂载目录下可以使用通用文件系统 API 对文件和目录进行操作。SequoiaFS 使用 SequoiaDB 的元数据集合存储文件和目录的属性，使用大对象（LOB）存储文件的内容，实现类似 NFS 的分布式网络文件系统。</li>
</ul>
<p><img src="http://doc.sequoiadb.com/cn/index/Public/Home/images/304/Database_Instance/Object_Instance/File_Instance/model.png" alt="img"></p>
<h3 id="创建集合空间和集合"><a href="#创建集合空间和集合" class="headerlink" title="创建集合空间和集合"></a>创建集合空间和集合</h3><p>进入 SequoiaDB Shell，在 SequoiaDB 中创建测试用的集合空间和集合 fscs.fscl，用于存放存储在巨杉数据库中的文件系统文件。</p>
<p>1）通过 Linux 命令行进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建 fs_domain 逻辑域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"fs_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 fscs 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"fscs"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"fs_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建 fscl 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.fscs.createCL(<span class="string">"fscl"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span>&#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="检查FUSE版本"><a href="#检查FUSE版本" class="headerlink" title="检查FUSE版本"></a>检查FUSE版本</h3><ol>
<li><p>查看是否安装 FUSE</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># which fusermount</span></span><br></pre></td></tr></table></figure></div>

<p>复制</p>
</li>
<li><p>查看 FUSE 版本号</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fusermount --version</span></span><br></pre></td></tr></table></figure></div>

<p>复制</p>
</li>
</ol>
<blockquote>
<p><strong>注意：</strong></p>
<p>若未安装 FUSE 或 FUSE 版本号低于 2.8.6，需进行 <a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1597232326-edition_id-304#FUSE安装" target="_blank" rel="noopener">FUSE安装</a>。</p>
</blockquote>
<h3 id="FUSE安装"><a href="#FUSE安装" class="headerlink" title="FUSE安装"></a>FUSE安装</h3><p>CentOS 7、Red Hat 7、SUSE 11.3 和 Ubuntu 14 及其以上版本的操作系统可参考包管理器安装，其他系统可参考源码安装或尝试其他方式自行安装。</p>
<ul>
<li><p>对于 CentOS 7/Red Hat 7 及其更高版本系统：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install fuse</span></span><br></pre></td></tr></table></figure></div>

<p>复制</p>
</li>
<li><p>对于 SUSE 11.3 及其更高版本系统：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zypper install fuse</span></span><br></pre></td></tr></table></figure></div>

<p>复制</p>
</li>
<li><p>对于 Ubuntu 14 及其更高版本系统：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="BASH"><figure class="iseeu highlight /bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get install fuse</span></span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="创建挂载点及配置文件"><a href="#创建挂载点及配置文件" class="headerlink" title="创建挂载点及配置文件"></a>创建挂载点及配置文件</h3><p>SequoiaFS 实例将集合 fscl 通过映射的方式挂载到 /opt/sequoiadb/sequoiafs/mountpoint 目录，从而在挂载目录下实现通过通用文件系统 API 对文件和目录进行操作。</p>
<p>1）创建挂载点 mountpoint；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/sequoiadb/sequoiafs/mountpoint</span><br></pre></td></tr></table></figure></div>

<p>2）以 sdbadmin 用户登录，创建sequoiafs的配置文件目录和日志目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/sequoiadb/sequoiafs/conf/fscs_fscl/001/</span><br><span class="line">mkdir -p /opt/sequoiadb/sequoiafs/log/fscs_fscl/001/</span><br></pre></td></tr></table></figure></div>

<p>3）生成一个空的配置文件，SequoiaFS 服务在启动时会将指定的值写入该文件中，其他参数使用缺省值；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">touch /opt/sequoiadb/sequoiafs/conf/fscs_fscl/001/sequoiafs.conf</span><br></pre></td></tr></table></figure></div>

<h3 id="启动-SequoiaFS-服务"><a href="#启动-SequoiaFS-服务" class="headerlink" title="启动 SequoiaFS 服务"></a>启动 SequoiaFS 服务</h3><p>启动服务之后 mountpoint 目录下的所有文件信息会存放在远程数据库节点上，可以在数据库的目录元数据集合及文件元数据集合中查看，文件内容会以 LOB对象 的形式存放在目标集合下。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sequoiafs /opt/sequoiadb/sequoiafs/mountpoint -i localhost:11810 -l fscs.fscl --autocreate -c /opt/sequoiadb/sequoiafs/conf/fscs_fscl/001/ --diagpath  /opt/sequoiadb/sequoiafs/log/fscs_fscl/001/ -o big_writes -o max_write=131072 -o max_read=131072</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>指定数据库的协调节点通过 -i (或 –hosts) 进行指定； 目录元数据集合可以通过 -d (或–metadircollection) 进行指定；<br>文件元数据集合可以通过 -f (或–metafilecollection) 进行指定；<br>以上参数可以直接通过指定–autocreate默认生成，该例指定默认生成；<br>挂载目录时，除了目标集合collection外，还需要指定一系列参数，具体参数选项详情请查看选项。<a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1525956060-edition_id-304" target="_blank" rel="noopener">SequoiaFS 实例参数配置</a></p>
</blockquote>
<h3 id="查看挂载目录和和底层存储信息"><a href="#查看挂载目录和和底层存储信息" class="headerlink" title="查看挂载目录和和底层存储信息"></a>查看挂载目录和和底层存储信息</h3><p>上一小节已经完成了目录的挂载，接下来我们对挂载的信息和 SequoiaDB 巨杉数据库的底层数据进行查看，确认在巨杉数据库底层是否已经自动生成与挂载相关的信息相关的集合。</p>
<p>1）本地 SequoiaFS 节点通过 mount 可以看到挂载信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mount</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/aa7ecdf03f8bf80c473504b90b51888f-0" alt="图片描述"></p>
<p>可以看到 /opt/sequoiadb/sequoiafs/mountpoint 已经通过 sequoiafs 已经挂载上了，文件系统类型为 fuse.sequoiafs。</p>
<p>2）通过 Linux 命令行进入 SequoiaDB Shell ，在 SequoiaDB 节点可以查看相关挂载信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>3）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>4）查看创建的集合信息</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.list(SDB_LIST_COLLECTIONS);</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/ad49bf17717b8bcc068dc0901a40c3a0-0" alt="图片描述"></p>
<p>5）sequoiafs.maphistory 为映射挂载历史信息表，记录历史挂载的关键数据信息。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.sequoiafs.maphistory.find();</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/12c82c8168559074e614f0821e0241de-0" alt="图片描述"></p>
<blockquote>
<p>Note:</p>
<ul>
<li>对于每次 mount，可以通过 sequoiafs.maphistory 查看映射挂载历史信息。</li>
<li>历史信息记录中描述说明：SourceCL：目标映射集合名称，DirMetaCL：目录元数据集合名称，FileMetaCL：文件元数据集合名称，Address：FS节点地址，MountPoint：FS节点挂载时的目录。</li>
<li>sequoiafs.fscl_dir 和 fscl_file 分别为目录和文件的元数据集合表，由于 SequoiaFS 启动挂载时指定了–autocreate，所以这里是默认生成的，用以记录 FS 挂载目录下的目录和文件信息。</li>
</ul>
</blockquote>
<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="挂载目录下文件、目录操作"><a href="#挂载目录下文件、目录操作" class="headerlink" title="挂载目录下文件、目录操作"></a>挂载目录下文件、目录操作</h3><p>使用 Linux 命令直接在挂载的目录进行文件和目录的操作。</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>进入到 /opt/sequoiadb/sequoiafs/mountpoint/ 中，创建目录 fsdir 并查看。</p>
<p>1）进入挂载目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiadb/sequoiafs/mountpoint/</span><br></pre></td></tr></table></figure></div>

<p>2）创建目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir fsdir</span><br></pre></td></tr></table></figure></div>

<p>3）查看目录是否存在；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls -trl</span><br></pre></td></tr></table></figure></div>

<h4 id="创建文件并写入内容"><a href="#创建文件并写入内容" class="headerlink" title="创建文件并写入内容"></a>创建文件并写入内容</h4><p>进入到 /opt/sequoiadb/sequoiafs/mountpoint/fsdir 中，创建文件 fsfile 并写入内容。</p>
<p>1）进入创建的 fsdir 目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /opt/sequoiadb/sequoiafs/mountpoint/fsdir</span><br></pre></td></tr></table></figure></div>

<p>2）使用 echo 重定向内容创建文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">echo 'hello, this is a fsfile!' &gt;&gt; fsfile.txt</span><br></pre></td></tr></table></figure></div>

<p>3）查看文件内容是否存在；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat fsfile.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="查看挂载目录创建的文件及存储内容"><a href="#查看挂载目录创建的文件及存储内容" class="headerlink" title="查看挂载目录创建的文件及存储内容"></a>查看挂载目录创建的文件及存储内容</h3><p>确认在本地 FS 节点进行操作的文件是否已经存储在了对应的集合空间下。</p>
<p>1）通过 Linux 命令行进入 SequoiaDB Shell；，查看文件和目录是否在 SequoiaDB 数据库存储引擎中存储情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）查看数据库中文件存储情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.sequoiafs.fscl_file142361856883863522.find();</span><br></pre></td></tr></table></figure></div>

<p>操作截图： <img src="https://doc.shiyanlou.com/courses/1543/1207281/8bce1243af73bcec52b07aa68dbfba39-0" alt="图片描述"></p>
<p>4）查看数据库中目录存储情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.sequoiafs.fscl_dir142361856883863522.find();</span><br></pre></td></tr></table></figure></div>

<p>操作截图： <img src="https://doc.shiyanlou.com/courses/1543/1207281/c9ffb482b15b93081188fc9ceb193a4f-0" alt="图片描述"></p>
<blockquote>
<p>Note:</p>
<p>fscl_file142361856883863522,fscl_dir142361856883863522是自动产生的，有可能和课程中产生的不一样，可以使用: db.list(SDB_LIST_COLLECTIONS)查看。</p>
</blockquote>
<p>5）查看集合中的 LOB 信息， 文件已经保存为一条 LOB 记录</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.fscs.fscl.listLobs();</span><br></pre></td></tr></table></figure></div>

<p>操作截图： <img src="https://doc.shiyanlou.com/courses/1543/1207281/7c26afd653e490bea49d5703dbdf3aee-0" alt="图片描述"></p>
<p>6）退出SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="创建-JAVA-工程项目"><a href="#创建-JAVA-工程项目" class="headerlink" title="创建 JAVA 工程项目"></a>创建 JAVA 工程项目</h3><p>本小节学习使用 JAVA 开发语言对挂载后的目录进行创建目录和复制文件的操作。</p>
<p>1）创建 JAVA 工程目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/sdbadmin/nfs</span><br></pre></td></tr></table></figure></div>

<p>2）进入工程目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cd /home/sdbadmin/nfs</span><br></pre></td></tr></table></figure></div>

<p>4）复制以下代码到实验环境终端执行生成 CopyFile.java 文件，用于操作 NFS 文件系统；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /home/sdbadmin/nfs/CopyFile.java &lt;&lt; EOF</span><br><span class="line">package com.sequoiadb.samples;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line"></span><br><span class="line">public class CopyFile &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        // 创建目录</span><br><span class="line">        File dir = new File("/opt/sequoiadb/sequoiafs/mountpoint/fsdir/cpdir");</span><br><span class="line">        if (!dir.exists()) &#123;</span><br><span class="line">            dir.mkdirs();</span><br><span class="line">            System.out.println("Directory created successfully");</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println("Directory already exists");</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 复制文件到新目录</span><br><span class="line">        File source = new File("/opt/sequoiadb/sequoiafs/mountpoint/fsdir/fsfile.txt");</span><br><span class="line">        File dest = new File("/opt/sequoiadb/sequoiafs/mountpoint/fsdir/cpdir/fsfile.txt");</span><br><span class="line">        InputStream input = null;</span><br><span class="line">        OutputStream output = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            input = new FileInputStream(source);</span><br><span class="line">            output = new FileOutputStream(dest);</span><br><span class="line">            byte[] buf = new byte[1024];</span><br><span class="line">            int bytesRead;</span><br><span class="line">            while ((bytesRead = input.read(buf)) != -1) &#123;</span><br><span class="line">                output.write(buf, 0, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println("File copied successfully");</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            input.close();</span><br><span class="line">            output.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></div>

<p>4）查询是否已经生成 CopyFile.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">ls -trl /home/sdbadmin/nfs/CopyFile.java</span><br></pre></td></tr></table></figure></div>

<h3 id="编译运行代码"><a href="#编译运行代码" class="headerlink" title="编译运行代码"></a>编译运行代码</h3><p>上一小节已经创建了 JAVA 工程和代码，接下来我们对代码进行编译运行。</p>
<p>1）编译 Select.java 文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">javac -d . CopyFile.java</span><br></pre></td></tr></table></figure></div>

<p>2）运行 Select 类代码，查询数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">java -cp .:./lib/* com.sequoiadb.samples.CopyFile</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/6b34774a859252ad1b42362afc06e364-0" alt="图片描述"></p>
<p>3）检查复制后的文件内容；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">cat /opt/sequoiadb/sequoiafs/mountpoint/fsdir/cpdir/fsfile.txt</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1543/1207281/8e06dd411bdd61dbdb7acaa3130a27cd-0" alt="图片描述"></p>
]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB之HTAP混合交易分析业务管理</title>
    <url>/2020/12/07/SequoiaDB%E4%B9%8BHTAP%E6%B7%B7%E5%90%88%E4%BA%A4%E6%98%93%E5%88%86%E6%9E%90%E4%B8%9A%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="HTAP混合交易概述"><a href="#HTAP混合交易概述" class="headerlink" title="HTAP混合交易概述"></a>HTAP混合交易概述</h3><ul>
<li><p>在 HTAP 场景下数据库产品的资源隔离能力至关重要，目前巨杉数据库的资源隔离方案有：</p>
<ol>
<li>基于多租户架构规划：一个数据库通常承载着多种业务系统，为了避免不同业务之间的性能影响，根据业务系统的存储量、并发大小、数据生命周期等划分不同的数据域承载相应的数据读写；</li>
<li>基于副本的资源隔离：不同业务通过连接不同的分区副本，实现 OLTP 与 OLAP 业务资源隔离，进而提高整体性能；</li>
</ol>
</li>
<li><p>由于业务形式的发展，越来越多的需求需要对交易数据进行实时分析，例如推荐、决策、监控等，传统的处理办法是使用 ETL 的方式把 OLTP 业务产生的数据同步到 OLAP 的数据数据库，导致了数据需要在不同的数据库之间流转，耗费时间成本的同时需要耗费人力成本运维多套数据库产品。</p>
</li>
<li><p>SequoiaDB 巨杉数据库采用“计算存储分离”架构，支持 MySQL、PostgreSQL 与 SparkSQL 三种关系型数据库实例、类 MongoDB 的 JSON 文档类数据库实例、以及 S3 对象存储与 Posix 文件系统的非结构化数据实例。在事务场景可以利用 SDBAPI、MySQL 和 PGSQL 实例对数据进行操作，在分析场景借助分布式计算框架 Spark 的并发计算性能，提高计算效率。</p>
</li>
</ul>
<h3 id="在-MySQL-实例创建表"><a href="#在-MySQL-实例创建表" class="headerlink" title="在 MySQL 实例创建表"></a>在 MySQL 实例创建表</h3><p>在 SequoiaSQL-MySQL 实例中创建的表将会默认使用 SequoiaDB 数据库存储引擎。</p>
<p>1）登录 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）创建数据库，并切换到该数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）创建包含自增主键字段的 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>4）向表中插入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Jacky"</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Alice"</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure></div>

<p>5）查看数据情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>6）查看 MySQL 实例读写数据连接的协调节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%sequoiadb_conn_addr%'</span>;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>MySQL 的访问隔离是通过其连接的协调节点预读策略实现的。</p>
</blockquote>
<p>7）退出 MySQL Shell ；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="SequoiaDB-巨杉数据库访问隔离设置"><a href="#SequoiaDB-巨杉数据库访问隔离设置" class="headerlink" title="SequoiaDB 巨杉数据库访问隔离设置"></a>SequoiaDB 巨杉数据库访问隔离设置</h3><p>数据库访问隔离功能的实现主要是通过修改数据库节点配置参数 instanceid 、 preferedinstance 和 preferedinstancemode、preferedstrict 来实现。</p>
<p>关于数据库配置的更多说明，请参考如下链接：</p>
<ul>
<li><a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190643-edition_id-0" target="_blank" rel="noopener">SequoiaDB 数据库配置</a></li>
</ul>
<h4 id="修改数据节点配置"><a href="#修改数据节点配置" class="headerlink" title="修改数据节点配置"></a>修改数据节点配置</h4><p>1）使用 Linux 命令行进去 SequoiaDB Shell ；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 javascript 语法连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>以下 3-5 步骤会报 -264 错误，这个是因为修改数据节点 instanceid 参数需要重启节点后才生效，可通过 getLastErrObj() 接口获取详细信息。</p>
</blockquote>
<p>3）修改 11820 数据节点实例 id 为 1；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">instanceid</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">svcname</span>: &#123; <span class="string">"$in"</span>: [ <span class="string">"11820"</span> ] &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）修改 21820 数据节点实例 id 为 2；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">instanceid</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">svcname</span>: &#123; <span class="string">"$in"</span>: [ <span class="string">"21820"</span> ] &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）修改 31820 数据节点实例 id 为 3；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">instanceid</span>: <span class="number">3</span> &#125;, &#123; <span class="attr">svcname</span>: &#123; <span class="string">"$in"</span>: [ <span class="string">"31820"</span> ] &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/d78b71b1173338e910be20b3473d27c1-0" alt="870-4"></p>
<h4 id="修改协调节点配置"><a href="#修改协调节点配置" class="headerlink" title="修改协调节点配置"></a>修改协调节点配置</h4><p>1）修改 11810 协调节点读取数据时的读取策略；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">preferedinstance</span>: <span class="string">"1,2,3"</span>, <span class="attr">preferedinstancemode</span>: <span class="string">"ordered"</span>, <span class="attr">preferedstrict</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">GroupName</span>: <span class="string">"SYSCoord"</span>, <span class="attr">svcname</span>: <span class="string">"11810"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>2）修改 21810 协调节点读取数据时的读取策略；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">preferedinstance</span>: <span class="string">"2,1,3"</span>, <span class="attr">preferedinstancemode</span>: <span class="string">"ordered"</span>, <span class="attr">preferedstrict</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">GroupName</span>: <span class="string">"SYSCoord"</span>, <span class="attr">svcname</span>: <span class="string">"21810"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>3）修改 31810 协调节点读取数据时的读取策略；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.updateConf( &#123; <span class="attr">preferedinstance</span>: <span class="string">"3,2,1"</span>, <span class="attr">preferedinstancemode</span>: <span class="string">"ordered"</span>, <span class="attr">preferedstrict</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">GroupName</span>: <span class="string">"SYSCoord"</span>, <span class="attr">svcname</span>: <span class="string">"31810"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>preferedinstance 指定执行读请求时优先选择的实例。上面命令为三个协调节点分配了不同的读取策略。例如：31810优先读取实例id为3的数据节点，即31820。</p>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/ef839743ac102e0cd6ade064e60a8f8d-0" alt="870-5"></p>
<p>4）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="重启-SequoiaDB-数据节点"><a href="#重启-SequoiaDB-数据节点" class="headerlink" title="重启 SequoiaDB 数据节点"></a>重启 SequoiaDB 数据节点</h3><p>数据节点 instanceid 参数为需要节点重启后生效，修改完参数后，重启数据节点。</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstop -r data</span><br><span class="line">sdbstart -r data</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/919f5910a8233044cda38364371ae28a-0" alt="870-3"></p>
<h3 id="查看节点参数修改状态"><a href="#查看节点参数修改状态" class="headerlink" title="查看节点参数修改状态"></a>查看节点参数修改状态</h3><p>1）进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）使用 javascript 语法连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db=<span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）查看数据节点参数修改状态；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.snapshot(SDB_SNAP_CONFIGS, &#123; <span class="attr">Role</span>: <span class="string">"data"</span> &#125;, &#123; <span class="attr">NodeName</span>: <span class="string">""</span>, <span class="attr">instanceid</span>: <span class="string">""</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>此时，所有数据节点的 instanceid 均已修改完成。</p>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/566e0319e020de4bf4e5f9ccd2d4a7ba-0" alt="870-6"></p>
<p>4）查看协调节点参数修改状态；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.snapshot(SDB_SNAP_CONFIGS, &#123; <span class="attr">Role</span>: <span class="string">"coord"</span> &#125;, &#123; <span class="attr">NodeName</span>: <span class="string">""</span>, <span class="attr">preferedinstance</span>: <span class="string">""</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/4136d9ffbd913cbe0140505b7b61dd5d-0" alt="870-6"></p>
<p>此时，所有数据节点的 preferedinstance 均已修改完成。</p>
<p>5）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="SparkSQL-设置"><a href="#SparkSQL-设置" class="headerlink" title="SparkSQL 设置"></a>SparkSQL 设置</h3><p>SparkSQL 用于处理 OLAP 类的业务，例如推荐、决策、监控等。</p>
<p>1）登录 Beeline 客户端，连接 SparkSQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/spark/bin/beeline -u 'jdbc:hive2://localhost:10000'</span><br></pre></td></tr></table></figure></div>

<p>2）创建 company 数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）在 SparkSQL 中创建表并设置预读数据节点实例 id 顺序为优先使用实例 3，再使用实例 2；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> company.employee</span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span>,</span><br><span class="line">ename <span class="keyword">STRING</span>,</span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">USING</span> com.sequoiadb.spark OPTIONS </span><br><span class="line">(</span><br><span class="line">host <span class="string">'localhost:11810'</span>,</span><br><span class="line">collectionspace <span class="string">'company'</span>,</span><br><span class="line">collection <span class="string">'employee'</span>,</span><br><span class="line">username <span class="string">''</span>,</span><br><span class="line"><span class="keyword">password</span> <span class="string">''</span>,</span><br><span class="line">preferredinstance <span class="string">'3,2'</span>,</span><br><span class="line">preferredinstancemode <span class="string">'ordered'</span>,</span><br><span class="line">preferredinstancestrict <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>更多的 SparkSQL 创建表参数说明，请参考如下链接：</p>
<p><a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190712-edition_id-304" target="_blank" rel="noopener">巨杉数据库 Spark 实例建表说明</a></p>
<p>3）数据的查询，此时 SparkSQL 从副本 3 读取数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> company.employee;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/8a092beecee3d6b5b1a46ac393367ba4-0" alt="870-7"></p>
]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB之多维分区</title>
    <url>/2020/12/07/SequoiaDB%E4%B9%8B%E5%A4%9A%E7%BB%B4%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h3 id="多维分区概述"><a href="#多维分区概述" class="headerlink" title="多维分区概述"></a>多维分区概述</h3><h4 id="分区方式介绍"><a href="#分区方式介绍" class="headerlink" title="分区方式介绍"></a>分区方式介绍</h4><ul>
<li>水平分区：用户可以通过将一个集合中的数据切分到多个复制组中，以达到并行计算的目的。</li>
<li>垂直分区：用户也可以将一个集合全局关系的属性分成若干子集，并在这些子集上作投影运算，将这些子集映射到另外的集合上，从而实现集合关系的垂直切分。</li>
<li>多维分区是指将集合先通过垂直分区映射到多个子集合中，再通过水平分区将子集合切分到多个复制组中的方式。</li>
</ul>
<h4 id="多维分区的优势"><a href="#多维分区的优势" class="headerlink" title="多维分区的优势"></a>多维分区的优势</h4><p>通常流水类数据选择创建多维分区表进行存放，把不同时间段的数据分布在不同的数据组。多维分区表的好处有：</p>
<p>1）当访问某时间范围的数据能够直接定位到子分区，避免扫描全表数据从而降低 IO。</p>
<p>2）在集群扩容时，把扩展的子表创建在新的机器，无需执行rebalance的操作即可完成表存储空间的扩容。</p>
<h3 id="创建多维分区表"><a href="#创建多维分区表" class="headerlink" title="创建多维分区表"></a>创建多维分区表</h3><p>多维分区表是一个包含有垂直分区和水平分区的分区表，由主集合和子集合两部分组成。主集合为一个逻辑结构，用于连接所有子集合。真正的数据存储于交易日志子集合之中。</p>
<p>1）通过 Linux 命令行进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain( <span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="string">"AutoSplit"</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建主集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="string">"Domain"</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建主集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"translog"</span>, &#123; <span class="string">"IsMainCL"</span>: <span class="literal">true</span>, <span class="string">"ShardingKey"</span>: &#123;<span class="string">"tx_time"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"range"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）创建子集合空间；</p>
<p>创建子集合空间 year2020 ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"year2020"</span>, &#123; <span class="string">"Domain"</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>创建子集合空间 year2021 ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"year2021"</span>, &#123; <span class="string">"Domain"</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>7）创建两个子集合；</p>
<p>创建子集合 year2020.translog ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.year2020.createCL(<span class="string">"translog"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>创建子集合 year2021.translog ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.year2021.createCL(<span class="string">"translog"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>8）挂载子集合；</p>
<p>挂载子集合 year2020.translog ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.translog.attachCL(<span class="string">"year2020.translog"</span>, &#123; <span class="string">"LowBound"</span>: &#123; <span class="string">"tx_time"</span>: MinKey() &#125;, <span class="attr">UpBound</span>: &#123; <span class="attr">tx_time</span>: &#123; <span class="string">"$date"</span>: <span class="string">"2021-01-01"</span> &#125; &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>挂载子集合 year2021.translog ：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.translog.attachCL(<span class="string">"year2021.translog"</span>, &#123; <span class="attr">LowBound</span>: &#123; <span class="string">"tx_time"</span>: &#123; <span class="string">"$date"</span>: <span class="string">"2021-01-01"</span> &#125; &#125;, <span class="string">"UpBound"</span>: &#123; <span class="string">"tx_time"</span>: MaxKey() &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>挂载完成后，子集合 year2020.translog 保存小于 2021年的数据，而子集合 year2021.translog 保存大于等于 2021 年的数据。</p>
<blockquote>
<p>Note:</p>
<p>挂载语句中的 <code>$date</code> 表示字段 tx_time 的数据类型为 date 型。</p>
</blockquote>
<p>更多数据类型请参考如下链接：</p>
<ul>
<li><a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1519612299-edition_id-304" target="_blank" rel="noopener">SequoiaDB 数据类型</a></li>
</ul>
<p>9）插入数据；</p>
<p>从主集合插入 2020 年 3 月份的数据：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.translog.insert( &#123; <span class="string">"serial_no"</span>: <span class="number">1</span>, <span class="string">"order_id"</span>: <span class="string">"20200302001"</span>, <span class="string">"bus_pay_no"</span>: <span class="string">"7312a297-21b4-1328-7834-ss21a251708"</span>, <span class="string">"tx_time"</span>: &#123; <span class="string">"$date"</span>: <span class="string">"2020-03-02"</span> &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>从主集合插入 2021 年 1 月份的数据：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.translog.insert( &#123; <span class="string">"serial_no"</span>: <span class="number">2</span>, <span class="string">"order_id"</span>: <span class="string">"20210101008"</span>, <span class="string">"bus_pay_no"</span>: <span class="string">"4321a297-15b4-4528-9034-cc21a256708"</span>, <span class="string">"tx_time"</span>: &#123; <span class="string">"$date"</span>: <span class="string">"2021-01-01"</span> &#125; &#125; );</span><br></pre></td></tr></table></figure></div>

<p>10）查询两个子集合数据分布；</p>
<p>year2020.translog 子集合数据量：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.year2020.translog.count();</span><br></pre></td></tr></table></figure></div>

<p>year2021.translog 子集合数据量：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.year2021.translog.count();</span><br></pre></td></tr></table></figure></div>

<p>11）关闭 db 连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.close();</span><br></pre></td></tr></table></figure></div>

<p>12）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<h3 id="MySQL-实例关联多维分区表"><a href="#MySQL-实例关联多维分区表" class="headerlink" title="MySQL 实例关联多维分区表"></a>MySQL 实例关联多维分区表</h3><p>由于 company 集合空间和 translog 集合在 SequoiaDB 数据库已存在，此时 MySQL 的 CREATE DATABASE 和 CREATE TABLE 语句只是映射了 SequoiaDB 的集合空间和集合，做了关联操作。</p>
<p>1）登录 MySQL 实例；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）MySQL 创建数据库；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<p>3）MySQL 创建表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> translog</span><br><span class="line">(</span><br><span class="line">serial_no <span class="built_in">INT</span>,</span><br><span class="line">order_id <span class="built_in">VARCHAR</span>(<span class="number">24</span>),</span><br><span class="line">bus_pay_no <span class="built_in">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">tx_time <span class="built_in">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>4）数据查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> translog;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>此时可以查询到已存在的数据。</p>
</blockquote>
<p>5）MySQL 实例中插入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> translog <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'20200521009'</span>, <span class="string">'3221a297-78b4-2528-7980-cc42a976605'</span>, <span class="string">'2020-05-21'</span>);</span><br></pre></td></tr></table></figure></div>

<p>6）数据查询；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> translog;</span><br></pre></td></tr></table></figure></div>

<p>通过 MySQL 实例向 translog 表插入的数据，数据最终会保存在 SequoiaDB 巨杉数据库中。</p>
<p>7）退出 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="查看分区的数据"><a href="#查看分区的数据" class="headerlink" title="查看分区的数据"></a>查看分区的数据</h3><p>1）查看year2020集合空间的数据，有两条</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.year2020.translog.find()</span><br></pre></td></tr></table></figure></div>

<p>2）查看year2021集合空间的数据，只有一条</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.year2021.translog.find()</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB之弹性扩展能力操作</title>
    <url>/2020/12/07/SequoiaDB%E4%B9%8B%E5%BC%B9%E6%80%A7%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="创建域、集合空间、集合"><a href="#创建域、集合空间、集合" class="headerlink" title="创建域、集合空间、集合"></a>创建域、集合空间、集合</h3><p>创建数据域、集合空间和集合，为集群扩容后数据重分布做准备。</p>
<p>1）通过 Linux 命令行进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）创建 company_domain 逻辑域；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createDomain(<span class="string">"company_domain"</span>, [ <span class="string">"group1"</span>, <span class="string">"group2"</span>, <span class="string">"group3"</span> ], &#123; <span class="attr">AutoSplit</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）创建 company 集合空间；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.createCS(<span class="string">"company"</span>, &#123; <span class="attr">Domain</span>: <span class="string">"company_domain"</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>5）创建 employee 集合；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"employee"</span>, &#123; <span class="string">"ShardingKey"</span>: &#123; <span class="string">"_id"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>6）使用 JavaScript 的 for 循环向 employee 集合中写入 1000 条数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> record = &#123; <span class="attr">empno</span>: i, <span class="attr">ename</span>: <span class="string">"TEST"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line">    db.company.employee.insert(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>7）通过查看集合快照信息，获取集合分区情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.snapshot(SDB_SNAP_COLLECTIONS, &#123; <span class="string">"Name"</span>: <span class="string">"company.employee"</span> &#125;, &#123; <span class="string">"Details.GroupName"</span>: <span class="string">""</span>, <span class="string">"Details.Group.TotalRecords"</span>: <span class="string">""</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/8b81119c35d1090b77725a9ad118f084-0" alt="810-4"></p>
<h3 id="分区组弹性扩展语法"><a href="#分区组弹性扩展语法" class="headerlink" title="分区组弹性扩展语法"></a>分区组弹性扩展语法</h3><p>本次实验所有展均在一台服务器上完成，多服务器扩展原理与此相同。下面是对创建分区组和增加节点的语法说明。</p>
<p>1）新建一个分区组语法；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="DELPHI"><figure class="iseeu highlight /delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = db.createRG( &lt; <span class="keyword">name</span> &gt; );</span><br></pre></td></tr></table></figure></div>

<p>参数描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>描述</th>
<th>是否必填</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>string</td>
<td>分区组名，同一个数据库对象中，分区组名唯一。</td>
<td>是</td>
</tr>
</tbody></table>
<p>2）在当前分区组中创建节点语法；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="ROUTEROS"><figure class="iseeu highlight /routeros"><table><tr><td class="code"><pre><span class="line">rg.createNode( &lt; host &gt;, &lt;<span class="built_in"> service </span>&gt;, &lt; dbpath &gt;, [<span class="built_in"> config </span>] );</span><br></pre></td></tr></table></figure></div>

<p>参数描述：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>描述</th>
<th>是否必填</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>string</td>
<td>指定节点的主机名。</td>
<td>是</td>
</tr>
<tr>
<td>service</td>
<td>int/string</td>
<td>节点端口号。</td>
<td>是</td>
</tr>
<tr>
<td>dbpath</td>
<td>string</td>
<td>1. 数据文件路径，用于存放节点数据文件，请确保数据管理员（安装时创建，默认为 sdbadmin ）用户有写权限； 2. 如果配置路径不以“/”开头，数据文件存放路径将是数据库管理员用户（默认为 sdbadmin ）的主目录（默认为 /home/sequoiadb ）+ 配置的路径。</td>
<td>是</td>
</tr>
<tr>
<td>config</td>
<td>Json 对象</td>
<td>节点配置信息，如配置日志大小，是否打开事务等，具体可参考数据库配置。</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="新增数据分区"><a href="#新增数据分区" class="headerlink" title="新增数据分区"></a>新增数据分区</h3><p>1）新增数据组；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataRG = db.createRG(<span class="string">"group4"</span>);</span><br></pre></td></tr></table></figure></div>

<p>2）添加数据节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">dataRG.createNode(<span class="string">"sdbserver1"</span>, <span class="number">11850</span>, <span class="string">"/opt/sequoiadb/database/data/11850/"</span>, &#123; <span class="attr">logfilenum</span>: <span class="number">5</span>, <span class="attr">transactionon</span>: <span class="literal">true</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>3）启动数据节点组；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">dataRG.start();</span><br></pre></td></tr></table></figure></div>

<p>4）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>

<p>5）查看数据库扩展后状态</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdblist  -t all -l -m local</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/74e8c86c2ed3a0c49fa6787d6ef5a8df-0" alt="810-5"></p>
<p>此时新增的数据节点已经加入集群。</p>
<blockquote>
<p>Note:</p>
<p>如果是在新服务器上进行扩容，新增服务器的 hostname 和 ip 地址需要被添加到所有服务器的 /etc/hostname 文件中。</p>
</blockquote>
<h3 id="原有集合数据重分布"><a href="#原有集合数据重分布" class="headerlink" title="原有集合数据重分布"></a>原有集合数据重分布</h3><p>集群扩容后，需要把原有数据域进行修改，新增数据组，并可通过 split 对已存在集合进行数据重新打散，达到集合数据均匀分布。</p>
<p>1）通过 Linux 命令行进入 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb</span><br></pre></td></tr></table></figure></div>

<p>2）通过 javascript 语言连接协调节点，获取数据库连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> db = <span class="keyword">new</span> Sdb(<span class="string">"localhost"</span>, <span class="number">11810</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）数据域 company_domain 增加数据组；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.getDomain(<span class="string">"company_domain"</span>).addGroups( &#123; <span class="attr">Groups</span>: [ <span class="string">'group4'</span> ] &#125; );</span><br></pre></td></tr></table></figure></div>

<p>4）查看域信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.listDomains();</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/65317644a3ad523658769eb3ab4853b8-0" alt="810-6"></p>
<p>5）将集合的部分数据迁移到新的数据组上；</p>
<p>将 group1 数据组部分数据切分到新的数据组中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.split(<span class="string">"group1"</span>, <span class="string">"group4"</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></div>

<p>将 group2 数据组部分数据切分到新的数据组中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.split(<span class="string">"group2"</span>, <span class="string">"group4"</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></div>

<p>将 group3 数据组部分数据切分到新的数据组中：</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.employee.split(<span class="string">"group3"</span>, <span class="string">"group4"</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Note:</p>
<p>以上split的含义是把 group1、group2 和 group3 上的数据分别移 25% 到 group4 上。 split 方法的详细说明请参考：<a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190844-edition_id-304" target="_blank" rel="noopener">split 方法说明</a>。</p>
</blockquote>
<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/73af5fca8e6a3c2d3b5dfff972d3b6aa-0" alt="810-7"></p>
<p>6）通过查看集合快照信息，获取集合分区情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.snapshot(SDB_SNAP_COLLECTIONS, &#123; <span class="string">"Name"</span>: <span class="string">"company.employee"</span> &#125;, &#123; <span class="string">"Details.GroupName"</span>: <span class="string">""</span>, <span class="string">"Details.Group.TotalRecords"</span>: <span class="string">""</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/e04e5f473943124007868656c7bee1ae-0" alt="810-8"></p>
<h3 id="新增数据自动打散"><a href="#新增数据自动打散" class="headerlink" title="新增数据自动打散"></a>新增数据自动打散</h3><p>company.employee 集合后续写入的数据会自动均匀打散 group1、group2、group3 和 group4 4个数据组中。</p>
<p>1）使用 JavaScript 的 for 循环向 employee 集合中写入 1000 条数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1000</span>; i &lt; <span class="number">2000</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> record = &#123; <span class="attr">empno</span>: i, <span class="attr">ename</span>: <span class="string">"TEST"</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;;</span><br><span class="line">    db.company.employee.insert(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>2）通过查看集合快照信息，获取集合分区情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.snapshot(SDB_SNAP_COLLECTIONS, &#123; <span class="string">"Name"</span>: <span class="string">"company.employee"</span> &#125;, &#123; <span class="string">"Details.GroupName"</span>: <span class="string">""</span>, <span class="string">"Details.Group.TotalRecords"</span>: <span class="string">""</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/24df47ccf97981976a71e2d70311f852-0" alt="810-7"></p>
<h3 id="新建集合自动拓展到新分区"><a href="#新建集合自动拓展到新分区" class="headerlink" title="新建集合自动拓展到新分区"></a>新建集合自动拓展到新分区</h3><p>在 company_domain 数据域中新创建的集合会按照数据域中包含的数据组自动均匀的分布到所有数据组里。</p>
<p>1）创建集合，分区方式为 hash ，分区键为 serial_no；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.company.createCL(<span class="string">"log"</span>, &#123;<span class="string">"ShardingKey"</span>: &#123; <span class="string">"serial_no"</span>: <span class="number">1</span> &#125;, <span class="string">"ShardingType"</span>: <span class="string">"hash"</span>, <span class="string">"ReplSize"</span>: <span class="number">-1</span>, <span class="string">"Compressed"</span>: <span class="literal">true</span>, <span class="string">"CompressionType"</span>: <span class="string">"lzw"</span>, <span class="string">"AutoSplit"</span>: <span class="literal">true</span>, <span class="string">"EnsureShardingIndex"</span>: <span class="literal">false</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>3）使用 JavaScript 的 for 循环向 log 集合中写入 1000 条数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> record = &#123; <span class="attr">serial_no</span>: i, <span class="attr">account_id</span>: i + <span class="number">1000</span>, <span class="attr">description</span>: <span class="string">"description log"</span>, <span class="attr">tx_time</span>: <span class="string">"2020-02-29 00:00:00"</span> &#125;;</span><br><span class="line">    db.company.log.insert(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>4）通过查看集合信息，获取数据分布；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.snapshot(SDB_SNAP_COLLECTIONS, &#123; <span class="string">"Name"</span>: <span class="string">"company.log"</span> &#125;, &#123; <span class="string">"Details.GroupName"</span>: <span class="string">""</span>, <span class="string">"Details.Group.TotalRecords"</span>: <span class="string">""</span> &#125; );</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1544/1207281/534b52e7a3c9c9f17c274a39e6f60f51-0" alt="810-7"></p>
<p>5）关闭 db 连接；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">db.close();</span><br></pre></td></tr></table></figure></div>

<p>6）退出 SequoiaDB Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="JAVASCRIPT"><figure class="iseeu highlight /javascript"><table><tr><td class="code"><pre><span class="line">quit;</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SeuqoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>SequoiaDB之诊断日志分析</title>
    <url>/2020/12/07/SequoiaDB%E4%B9%8B%E8%AF%8A%E6%96%AD%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<ul>
<li>模拟集群节点故障时如何正确的使用 SeuoqiaDB 巨杉数据库的诊断日志，高效准确的定位问题所在。</li>
</ul>
<h3 id="创建数据库及数据表"><a href="#创建数据库及数据表" class="headerlink" title="创建数据库及数据表"></a>创建数据库及数据表</h3><p>进入 MySQL Shell ，连接 SequoiaSQL-MySQL 实例并创建表，为接下来日志诊断分析做准备。</p>
<h4 id="登录-MySQL-Shell"><a href="#登录-MySQL-Shell" class="headerlink" title="登录 MySQL Shell"></a>登录 MySQL Shell</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> company;</span><br><span class="line"><span class="keyword">USE</span> company;</span><br></pre></td></tr></table></figure></div>

<h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p>在 SequoiaSQL-MySQL 实例中创建的表将会默认使用 SequoiaDB 巨杉数据库存储引擎，包含主键或唯一键的表将会默认以唯一键作为分区键进行自动分区。</p>
<p>1）创建包含自增主键字段的 employee 表；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee </span><br><span class="line">(</span><br><span class="line">empno <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>, </span><br><span class="line">ename <span class="built_in">VARCHAR</span>(<span class="number">128</span>), </span><br><span class="line">age <span class="built_in">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>2）基本的数据写入操作；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Jacky"</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Alice"</span>, <span class="number">18</span>);</span><br></pre></td></tr></table></figure></div>

<p>3）查看数据情况；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employee;</span><br></pre></td></tr></table></figure></div>

<p>4）退出 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="模拟节点故障"><a href="#模拟节点故障" class="headerlink" title="模拟节点故障"></a>模拟节点故障</h3><p>目前集群为正常状态，我们停止一个数据节点 11820 模拟节点故障的情况。</p>
<p>1）停止 11820 数据节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstop -p 11820</span><br></pre></td></tr></table></figure></div>

<p>2）登录 MySQL Shell ；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>3）查询数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> company.employee;</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/c6dfe09b2166840427eef975f22156bc-0" alt="890-4"></p>
<p>根据图片中的错误码 40250 计算得出 SequoiaDB 对应错误码为 -250（节点处于业务故障状态）。</p>
<p>关于 SequoiaSQL-MySQL 错误码的详细信息，请参考如下链接：</p>
<ul>
<li><a href="http://doc.sequoiadb.com/cn/index-cat_id-1555382544-edition_id-304" target="_blank" rel="noopener">SequoiaSQL-MySQL 错误码</a></li>
</ul>
<p>4）退出 MySQL Shell；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>

<h3 id="通过快照查询集群情况"><a href="#通过快照查询集群情况" class="headerlink" title="通过快照查询集群情况"></a>通过快照查询集群情况</h3><p>在 SequoiaDB 中，快照是一种得到系统当前状态的命令，当集群故障时我们可以使用快照进行初步分析节点；</p>
<p>1）使用嵌入命令模式连接 SequoiaDB 巨杉数据库协调节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db = new Sdb("localhost", 11810)'</span><br></pre></td></tr></table></figure></div>

<p>2）查询数据库快照列出当前数据库节点的数据库监视信息；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db.snapshot(SDB_SNAP_DATABASE, &#123;&#125;, &#123; "ErrNodes": "" &#125; )'</span><br></pre></td></tr></table></figure></div>

<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/aaad4214d372849500f784006118b5b4-0" alt="890-2"></p>
<p>从上图中我们可以看出集群中存在错误节点为 11820。</p>
<h3 id="错误日志分析"><a href="#错误日志分析" class="headerlink" title="错误日志分析"></a>错误日志分析</h3><p>查找协调节点日志文件所在的文件夹，打开日志文件 sdbdiag.log。</p>
<p>1）查询协调节点日志文件目录；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db.list(SDB_LIST_GROUPS, &#123; "GroupName": "SYSCoord" &#125; )'</span><br></pre></td></tr></table></figure></div>

<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/68ab1e51b1ac37ec8b6ade19a74daf6f-0" alt="890-2"></p>
<p>2）打开协调节点日志文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">vi  /opt/sequoiadb/database/coord/11810/diaglog/sdbdiag.log</span><br></pre></td></tr></table></figure></div>

<p>如有关键字 ERROR，则说明数据库有报错，并根据 rc 后面的错误代码查看具体错误信息，本次错误代码为 -79。</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/d50ab94ac2cc7b9bc917b5ad922b1d04-0" alt="890-5"></p>
<blockquote>
<p>Note:</p>
<p>每次虚拟机环境初始化，数据节点 id 和 所属数据组 id 序号都会有变化。</p>
</blockquote>
<p>具体错误代码请参考如下链接：</p>
<ul>
<li><a href="http://doc.sequoiadb.com/cn/sequoiadb-cat_id-1432190985-edition_id-0" target="_blank" rel="noopener">SequoiaDB 错误码</a></li>
</ul>
<p>根据 NodeID 定位到发生错误的具体节点,查看该节点的诊断日志文件。</p>
<p>3）根据协调节点日志文件中错误信息，定位具体服务节点，其中 GroupID 和 NodeID 以日志文件中的具体值为准;</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdb 'db.list(SDB_LIST_GROUPS, &#123; GroupID: 1002, "Group.NodeID": 1002&#125;, &#123;&#125; );'</span><br></pre></td></tr></table></figure></div>

<p>4）打开 11820 数据节点日志文件；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">more /opt/sequoiadb/database/data/11820/diaglog/sdbdiag.log</span><br></pre></td></tr></table></figure></div>

<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/156005c5baf40ff51a327f1c34f2975b-0" alt="890-5"></p>
<blockquote>
<p>Note:</p>
<p>按键盘 <code>shift + g</code> 去到文件最后可以看到节点为正常停止。</p>
</blockquote>
<p>5）group1 数据节点服务未启动 ， 启动 group1 的 11820 节点；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">sdbstart -p 11820</span><br></pre></td></tr></table></figure></div>

<p>操作截图：</p>
<p><img src="https://doc.shiyanlou.com/courses/1538/1207281/bf6b6afd57ba0324b9560db4ff01fe04-0" alt="890-7"></p>
<h3 id="验证集群是否可用"><a href="#验证集群是否可用" class="headerlink" title="验证集群是否可用"></a>验证集群是否可用</h3><p>1）登录 MySQL Shell ；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line">/opt/sequoiasql/mysql/bin/mysql -h 127.0.0.1 -P 3306 -u root</span><br></pre></td></tr></table></figure></div>

<p>2）查询数据并向表中插入数据；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> company.employee;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> company.employee (ename, age) <span class="keyword">VALUES</span> (<span class="string">"Ben"</span>, <span class="number">21</span>);</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此时数据服务已经恢复正常，能够正常写入和查询；</p>
</blockquote>
<p>3）退出 MySQL Shell ；</p>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SQL"><figure class="iseeu highlight /sql"><table><tr><td class="code"><pre><span class="line">\q</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>-SequoiaDB</category>
      </categories>
      <tags>
        <tag>-SequoiaDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark的设计与运行原理</title>
    <url>/2020/12/09/Spark%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>在具体讲解Spark运行架构之前，需要先了解几个重要的概念：<ol>
<li>RDD：是弹性分布式数据集（Resilient Distributed Dataset）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型；</li>
<li>DAG：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系；</li>
<li>Executor：是运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程序存储数据；</li>
<li>应用：用户编写的Spark应用程序；</li>
<li>任务：运行在Executor上的工作单元；</li>
<li>作业：一个作业包含多个RDD及作用于相应RDD上的各种操作；</li>
<li>阶段：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”。</li>
</ol>
</li>
</ul>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul>
<li>如下图所示，驱动程序（Driver Program）表示任务控制节点和用户的程序，而SparkContext负责和资源管理器（Cluster Manager）的通信以及进行资源的申请、任务的分配和监控等。</li>
<li>Spark运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（Worker Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor）。其中，集群资源管理器可以是Spark自带的资源管理器，也可以是YARN或Mesos等资源管理框架。</li>
<li>与Hadoop MapReduce计算框架相比，Spark所采用的Executor有两个优点：<ol>
<li>利用多线程来执行具体的任务（Hadoop MapReduce采用的是进程模型），减少任务的启动开销；</li>
<li>Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，当需要多轮迭代计算时，可以将中间结果存储到这个存储模块里，下次需要时，就可以直接读该存储模块里的数据，而不需要读写到HDFS等文件系统里，因而有效减少了IO开销；或者在交互式查询场景下，预先将表缓存到该存储系统上，从而可以提高读写IO性能。</li>
</ol>
</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-5-Spark%E8%BF%90%E8%A1%8C%E6%9E%B6%E6%9E%84.jpg" alt="图示"></p>
<ul>
<li>总体而言，如下图所示，在Spark中，一个应用（Application）由一个任务控制节点（Driver）和若干个作业（Job）构成，一个作业由多个阶段（Stage）构成，一个阶段由多个任务（Task）组成。当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后，执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-6-Spark%E4%B8%AD%E5%90%84%E7%A7%8D%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E5%85%B3%E7%B3%BB.jpg" alt="img"></p>
<h3 id="Spark运行基本流程"><a href="#Spark运行基本流程" class="headerlink" title="Spark运行基本流程"></a>Spark运行基本流程</h3><ul>
<li>如下图所示，Spark的基本运行流程如下：<ol>
<li>当一个Spark应用被提交时，首先需要为这个应用构建起基本的运行环境，即由任务控制节点（Driver）创建一个SparkContext，由SparkContext负责和资源管理器（Cluster Manager）的通信以及进行资源的申请、任务的分配和监控等。SparkContext会向资源管理器注册并申请运行Executor的资源；</li>
<li>资源管理器为Executor分配资源，并启动Executor进程，Executor运行情况将随着“心跳”发送到资源管理器上；</li>
<li>SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAG调度器（DAGScheduler）进行解析，将DAG图分解成多个“阶段”（每个阶段都是一个任务集），并且计算出各个阶段之间的依赖关系，然后把一个个“任务集”提交给底层的任务调度器（TaskScheduler）进行处理；Executor向SparkContext申请任务，任务调度器将任务分发给Executor运行，同时，SparkContext将应用程序代码发放给Executor；</li>
<li>任务在Executor上运行，把执行结果反馈给任务调度器，然后反馈给DAG调度器，运行完毕后写入数据并释放所有资源。</li>
</ol>
</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-7-Spark%E8%BF%90%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="img"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Spark运行架构具有以下特点：<ol>
<li>每个应用都有自己专属的Executor进程，并且该进程在应用运行期间一直驻留。Executor进程以多线程的方式运行任务，减少了多进程任务频繁的启动开销，使得任务执行变得非常高效和可靠；</li>
<li>Spark运行过程与资源管理器无关，只要能够获取Executor进程并保持通信即可；</li>
<li>Executor上有一个BlockManager存储模块，类似于键值存储系统（把内存和磁盘共同作为存储设备），在处理迭代计算任务时，不需要把中间结果写入到HDFS等文件系统，而是直接放在这个存储系统上，后续有需要时就可以直接读取；在交互式查询场景下，也可以把表提前缓存到这个存储系统上，提高读写IO性能；</li>
<li>任务采用了数据本地性和推测执行等优化机制。数据本地性是尽量将计算移到数据所在的节点上进行，即“计算向数据靠拢”，因为移动计算比移动数据所占的网络资源要少得多。而且，Spark采用了延时调度机制，可以在更大的程度上实现执行过程优化。比如，拥有数据的节点当前正被其他的任务占用，那么，在这种情况下是否需要将数据移动到其他的空闲节点呢？答案是不一定。因为，如果经过预测发现当前节点结束当前任务的时间要比移动数据的时间还要少，那么，调度就会等待，直到当前节点可用。</li>
</ol>
</li>
</ul>
<hr>
<p>转载于：<a href="http://dblab.xmu.edu.cn/blog/1711-2/" target="_blank" rel="noopener">子雨大数据</a></p>
]]></content>
      <categories>
        <category>-Spark</category>
      </categories>
      <tags>
        <tag>-Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark之RDD的设计与运行原理</title>
    <url>/2020/12/09/Spark%E4%B9%8BRDD%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="RDD设计背景"><a href="#RDD设计背景" class="headerlink" title="RDD设计背景"></a>RDD设计背景</h3><ul>
<li>在实际应用中，存在许多迭代式算法（比如机器学习、图算法等）和交互式数据挖掘工具，这些应用场景的共同之处是，不同计算阶段之间会重用中间结果，即一个阶段的输出结果会作为下一个阶段的输入。但是，目前的MapReduce框架都是把中间结果写入到HDFS中，带来了大量的数据复制、磁盘IO和序列化开销。</li>
<li>虽然，类似Pregel等图计算框架也是将结果保存在内存当中，但是，这些框架只能支持一些特定的计算模式，并没有提供一种通用的数据抽象。RDD就是为了满足这种需求而出现的，它提供了一个抽象的数据架构，我们不必担心底层数据的分布式特性，只需将具体的应用逻辑表达为一系列转换处理，不同RDD之间的转换操作形成依赖关系，可以实现管道化，从而避免了中间结果的存储，大大降低了数据复制、磁盘IO和序列化开销。</li>
</ul>
<h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><h4 id="RDD的概念"><a href="#RDD的概念" class="headerlink" title="RDD的概念"></a>RDD的概念</h4><ul>
<li>一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可以分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。RDD提供了一种高度受限的共享内存模型，即RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和groupBy）而创建得到新的RDD。</li>
</ul>
<h4 id="Action和Transformation"><a href="#Action和Transformation" class="headerlink" title="Action和Transformation"></a>Action和Transformation</h4><ul>
<li>RDD提供了一组丰富的操作以支持常见的数据运算，分为“行动”（Action）和“转换”（Transformation）两种类型，<ol>
<li>Action：用于执行计算并指定输出的形式，</li>
<li>Transformation：指定RDD之间的相互依赖关系。</li>
</ol>
</li>
<li>两类操作的主要区别是，转换操作（比如map、filter、groupBy、join等）接受RDD并返回RDD，而行动操作（比如count、collect等）接受RDD但是返回非RDD（即输出一个值或结果）。</li>
<li>RDD提供的转换接口都非常简单，都是类似map、filter、groupBy、join等粗粒度的数据转换操作，而不是针对某个数据项的细粒度修改。因此，RDD比较适合对于数据集中元素执行相同操作的批处理式应用，而不适合用于需要异步、细粒度状态的应用，比如Web应用系统、增量式的网页爬虫等。正因为这样，这种粗粒度转换接口设计，会使人直觉上认为RDD的功能很受限、不够强大。但是，实际上RDD已经被实践证明可以很好地应用于许多并行计算应用中，可以具备很多现有计算框架（比如MapReduce、SQL、Pregel等）的表达能力，并且可以应用于这些框架处理不了的交互式数据挖掘应用。</li>
</ul>
<h4 id="RDD的执行"><a href="#RDD的执行" class="headerlink" title="RDD的执行"></a>RDD的执行</h4><ul>
<li><p>Spark用Scala语言实现了RDD的API，程序员可以通过调用API实现对RDD的各种操作。RDD典型的执行过程如下：</p>
<ol>
<li>RDD读入外部数据源（或者内存中的集合）进行创建；</li>
<li>RDD经过一系列的“转换”操作，每一次都会产生不同的RDD，供给下一个“转换”使用；</li>
<li>最后一个RDD经“行动”操作进行处理，并输出到外部数据源（或者变成Scala集合或标量）。</li>
</ol>
</li>
<li><p>需要说明的是，RDD采用了惰性调用，即在RDD的执行过程中（如下图所示），真正的计算发生在RDD的“行动”操作，对于“行动”之前的所有“转换”操作，Spark只是记录下“转换”操作应用的一些基础数据集以及RDD生成的轨迹，即相互之间的依赖关系，而不会触发真正的计算。</p>
</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-8-Spark%E7%9A%84%E8%BD%AC%E6%8D%A2%E5%92%8C%E8%A1%8C%E5%8A%A8%E6%93%8D%E4%BD%9C.jpg" alt="Spark的转换和行动操作"></p>
<ul>
<li>例如，在图9-9中，从输入中逻辑上生成A和C两个RDD，经过一系列“转换”操作，逻辑上生成了F（也是一个RDD），之所以说是逻辑上，是因为这时候计算并没有发生，Spark只是记录了RDD之间的生成和依赖关系。当F要进行输出时，也就是当F进行“行动”操作的时候，Spark才会根据RDD的依赖关系生成DAG，并从起点开始真正的计算。</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-9-RDD%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B.jpg" alt="图9-9 RDD执行过程的一个实例"></p>
<ul>
<li>上述这一系列处理称为一个“血缘关系（Lineage）”，即DAG拓扑排序的结果。采用惰性调用，通过血缘关系连接起来的一系列RDD操作就可以实现管道化（pipeline），避免了多次转换操作之间数据同步的等待，而且不用担心有过多的中间数据，因为这些具有血缘关系的操作都管道化了，一个操作得到的结果不需要保存为中间数据，而是直接管道式地流入到下一个操作进行处理。同时，这种通过血缘关系把一系列操作进行管道化连接的设计方式，也使得管道中每次操作的计算变得相对简单，保证了每个操作在处理逻辑上的单一性；相反，在MapReduce的设计中，为了尽可能地减少MapReduce过程，在单个MapReduce中会写入过多复杂的逻辑。</li>
</ul>
<h3 id="使用Python执行Spark程序"><a href="#使用Python执行Spark程序" class="headerlink" title="使用Python执行Spark程序"></a>使用Python执行Spark程序</h3><ul>
<li>例1：一个Spark的“Hello World”程序，这里以一个“Hello World”入门级Spark程序来解释RDD执行过程，这个程序的功能是读取一个HDFS文件，计算出包含字符串“Hello World”的行数。</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="SHELL"><figure class="iseeu highlight /shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动pyspark</span></span><br><span class="line">PYSPARK_PYTHON=python3 ./bin/pyspark</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Spark 2.1.0仅支持Python 2.7+/3.4+的版本。本系列教程统一使用Python 3.4以上的版本。在Ubuntu 16.04中已经自带了Python 3.5,就不用再安装Python.如果你的系统中仍未安装好Python 3.4以上的版本，请安装Python 3.4以上的版本，在pyspark的交互环境下，输入如下代码</li>
</ul>
<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-rel="LIVECODESERVER"><figure class="iseeu highlight /livecodeserver"><table><tr><td class="code"><pre><span class="line">fileRDD = sc.textFile(<span class="string">'hdfs://localhost:9000/test.txt'</span>)</span><br><span class="line">def <span class="keyword">contains</span>(<span class="built_in">line</span>):</span><br><span class="line">...     <span class="literal">return</span> <span class="string">'hello world'</span> <span class="keyword">in</span> <span class="built_in">line</span></span><br><span class="line">filterRDD = fileRDD.<span class="built_in">filter</span>(<span class="keyword">contains</span>)</span><br><span class="line">filterRDD.cache()</span><br><span class="line">filterRDD.count()</span><br></pre></td></tr></table></figure></div>

<ul>
<li>可以看出，一个Spark应用程序，基本是基于RDD的一系列计算操作。第1行代码从HDFS文件中读取数据创建一个RDD；第2、3行定义一个过滤函数;第4行代码对fileRDD进行转换操作得到一个新的RDD，即filterRDD；第5行代码表示对filterRDD进行持久化，把它保存在内存或磁盘中（这里采用cache接口把数据集保存在内存中），方便后续重复使用，当数据被反复访问时（比如查询一些热点数据，或者运行迭代算法），这是非常有用的，而且通过cache()可以缓存非常大的数据集，支持跨越几十甚至上百个节点；第5行代码中的count()是一个行动操作，用于计算一个RDD集合中包含的元素个数。这个程序的执行过程如下：<ol>
<li>创建这个Spark程序的执行上下文，即创建SparkContext对象；</li>
<li>从外部数据源（即HDFS文件）中读取数据创建fileRDD对象；</li>
<li>构建起fileRDD和filterRDD之间的依赖关系，形成DAG图，这时候并没有发生真正的计算，只是记录转换的轨迹；</li>
<li>执行到第6行代码时，count()是一个行动类型的操作，触发真正的计算，开始实际执行从fileRDD到filterRDD的转换操作，并把结果持久化到内存中，最后计算出filterRDD中包含的元素个数。</li>
</ol>
</li>
</ul>
<h3 id="RDD特性"><a href="#RDD特性" class="headerlink" title="RDD特性"></a>RDD特性</h3><ul>
<li>总体而言，Spark采用RDD以后能够实现高效计算的主要原因如下：<ol>
<li>高效的容错性。现有的分布式共享内存、键值存储、内存数据库等，为了实现容错，必须在集群节点之间进行数据复制或者记录日志，也就是在节点之间会发生大量的数据传输，这对于数据密集型应用而言会带来很大的开销。在RDD的设计中，数据只读，不可修改，如果需要修改数据，必须从父RDD转换到子RDD，由此在不同RDD之间建立了血缘关系。所以，RDD是一种天生具有容错机制的特殊集合，不需要通过数据冗余的方式（比如检查点）实现容错，而只需通过RDD父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，这样就避免了数据复制的高开销，而且重算过程可以在不同节点之间并行进行，实现了高效的容错。此外，RDD提供的转换操作都是一些粗粒度的操作（比如map、filter和join），RDD依赖关系只需要记录这种粗粒度的转换操作，而不需要记录具体的数据和各种细粒度操作的日志（比如对哪个数据项进行了修改），这就大大降低了数据密集型应用中的容错开销；</li>
<li>中间结果持久化到内存。数据在内存中的多个RDD操作之间进行传递，不需要“落地”到磁盘上，避免了不必要的读写磁盘开销；</li>
<li>存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化开销。</li>
</ol>
</li>
</ul>
<h3 id="RDD之间的依赖关系"><a href="#RDD之间的依赖关系" class="headerlink" title="RDD之间的依赖关系"></a>RDD之间的依赖关系</h3><ul>
<li><p>RDD中不同的操作会使得不同RDD中的分区会产生不同的依赖。RDD中的依赖关系分为窄依赖（Narrow Dependency）与宽依赖（Wide Dependency），下图展示了两种依赖之间的区别：</p>
<ol>
<li>窄依赖表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区；比如下图(a)中，RDD1是RDD2的父RDD，RDD2是子RDD，RDD1的分区1，对应于RDD2的一个分区（即分区4）；再比如，RDD6和RDD7都是RDD8的父RDD，RDD6中的分区（分区15）和RDD7中的分区（分区18），两者都对应于RDD8中的一个分区（分区21）。</li>
<li>宽依赖则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区。比如下图(b)中，RDD9是RDD12的父RDD，RDD9中的分区24对应了RDD12中的两个分区（即分区27和分区28）。<br>总体而言，如果父RDD的一个分区只被一个子RDD的一个分区所使用就是窄依赖，否则就是宽依赖。窄依赖典型的操作包括map、filter、union等，宽依赖典型的操作包括groupByKey、sortByKey等。对于连接（join）操作，可以分为两种情况。</li>
<li>对输入进行协同划分，属于窄依赖（如下图(a)所示）。所谓协同划分（co-partitioned）是指多个父RDD的某一分区的所有“键（key）”，落在子RDD的同一个分区内，不会产生同一个父RDD的某一分区，落在子RDD的两个分区的情况。</li>
<li>对输入做非协同划分，属于宽依赖，如下图(b)所示。</li>
</ol>
</li>
<li><p>对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。对于宽依赖的RDD，则通常伴随着Shuffle操作，即首先需要计算好所有父分区数据，然后在节点之间进行Shuffle。</p>
</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-10-%E7%AA%84%E4%BE%9D%E8%B5%96%E4%B8%8E%E5%AE%BD%E4%BE%9D%E8%B5%96%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="下图 窄依赖与宽依赖的区别"></p>
<ul>
<li>Spark的这种依赖关系设计，使其具有了天生的容错性，大大加快了Spark的执行速度。因为，RDD数据集通过“血缘关系”记住了它是如何从其它RDD中演变过来的，血缘关系记录的是粗颗粒度的转换操作行为，当这个RDD的部分分区数据丢失时，它可以通过血缘关系获取足够的信息来重新运算和恢复丢失的数据分区，由此带来了性能的提升。相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可（不需要重新计算所有分区），而且可以并行地在不同节点进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销较大。此外，Spark还提供了数据检查点和记录日志，用于持久化中间RDD，从而使得在进行失败恢复时不需要追溯到最开始的阶段。在进行故障恢复时，Spark会对数据检查点开销和重新计算RDD分区的开销进行比较，从而自动选择最优的恢复策略。</li>
</ul>
<h3 id="阶段的划分"><a href="#阶段的划分" class="headerlink" title="阶段的划分"></a>阶段的划分</h3><ul>
<li>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段，具体划分方法是：在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算（具体的阶段划分算法请参见AMP实验室发表的论文《Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing》）。例如，如图9-11所示，假设从HDFS中读入数据生成3个不同的RDD（即A、C和E），通过一系列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从RDD A到RDD B的转换以及从RDD B和F到RDD G的转换，都属于宽依赖，因此，在宽依赖处断开后可以得到三个阶段，即阶段1、阶段2和阶段3。可以看出，在阶段2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作，比如，分区7通过map操作生成的分区9，可以不用等待分区8到分区9这个转换操作的计算结束，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-11-%E6%A0%B9%E6%8D%AERDD%E5%88%86%E5%8C%BA%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%88%92%E5%88%86%E9%98%B6%E6%AE%B5.jpg" alt="图9-11根据RDD分区的依赖关系划分阶段"></p>
<ul>
<li>由上述论述可知，把一个DAG图划分成多个“阶段”以后，每个阶段都代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集合。每个任务集合会被提交给任务调度器（TaskScheduler）进行处理，由任务调度器将任务分发给Executor运行。</li>
</ul>
<h3 id="RDD运行过程"><a href="#RDD运行过程" class="headerlink" title="RDD运行过程"></a>RDD运行过程</h3><ul>
<li>通过上述对RDD概念、依赖关系和阶段划分的介绍，结合之前介绍的Spark运行基本流程，这里再总结一下RDD在Spark架构中的运行过程（如下图所示）：<ol>
<li>创建RDD对象；</li>
<li>SparkContext负责计算RDD之间的依赖关系，构建DAG；</li>
<li>DAGScheduler负责把DAG图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的Executor去执行。</li>
</ol>
</li>
</ul>
<p><img src="http://dblab.xmu.edu.cn/blog/wp-content/uploads/2016/11/%E5%9B%BE9-12-RDD%E5%9C%A8Spark%E4%B8%AD%E7%9A%84%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="图9-12 RDD在Spark中的运行过程"></p>
<hr>
<p>转载于：<a href="http://dblab.xmu.edu.cn/blog/1681-1/" target="_blank" rel="noopener">子雨大数据</a></p>
]]></content>
      <categories>
        <category>-Spark</category>
      </categories>
      <tags>
        <tag>-Spark</tag>
      </tags>
  </entry>
</search>
